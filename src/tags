!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A0	rand.c	/^#define A0	/;"	d	language:C	file:
A1	rand.c	/^#define A1	/;"	d	language:C	file:
A2	rand.c	/^#define A2	/;"	d	language:C	file:
ACTIVE_EXPIRE_CYCLE_FAST	server.h	/^#define ACTIVE_EXPIRE_CYCLE_FAST /;"	d	language:C
ACTIVE_EXPIRE_CYCLE_FAST_DURATION	server.h	/^#define ACTIVE_EXPIRE_CYCLE_FAST_DURATION /;"	d	language:C
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP	server.h	/^#define ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP /;"	d	language:C
ACTIVE_EXPIRE_CYCLE_SLOW	server.h	/^#define ACTIVE_EXPIRE_CYCLE_SLOW /;"	d	language:C
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC	server.h	/^#define ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC /;"	d	language:C
ADDEQU	rand.c	/^#define ADDEQU(/;"	d	language:C	file:
AE_ALL_EVENTS	ae.h	/^#define AE_ALL_EVENTS /;"	d	language:C
AE_DELETED_EVENT_ID	ae.h	/^#define AE_DELETED_EVENT_ID /;"	d	language:C
AE_DONT_WAIT	ae.h	/^#define AE_DONT_WAIT /;"	d	language:C
AE_ERR	ae.h	/^#define AE_ERR /;"	d	language:C
AE_FILE_EVENTS	ae.h	/^#define AE_FILE_EVENTS /;"	d	language:C
AE_NOMORE	ae.h	/^#define AE_NOMORE /;"	d	language:C
AE_NONE	ae.h	/^#define AE_NONE /;"	d	language:C
AE_NOTUSED	ae.h	/^#define AE_NOTUSED(/;"	d	language:C
AE_OK	ae.h	/^#define AE_OK /;"	d	language:C
AE_READABLE	ae.h	/^#define AE_READABLE /;"	d	language:C
AE_TIME_EVENTS	ae.h	/^#define AE_TIME_EVENTS /;"	d	language:C
AE_WRITABLE	ae.h	/^#define AE_WRITABLE /;"	d	language:C
AF_LOCAL	anet.h	/^#define AF_LOCAL /;"	d	language:C
AL_START_HEAD	adlist.h	/^#define AL_START_HEAD /;"	d	language:C
AL_START_HEAD	quicklist.h	/^#define AL_START_HEAD /;"	d	language:C
AL_START_TAIL	adlist.h	/^#define AL_START_TAIL /;"	d	language:C
AL_START_TAIL	quicklist.h	/^#define AL_START_TAIL /;"	d	language:C
ANET_CONNECT_BE_BINDING	anet.c	/^#define ANET_CONNECT_BE_BINDING /;"	d	language:C	file:
ANET_CONNECT_NONBLOCK	anet.c	/^#define ANET_CONNECT_NONBLOCK /;"	d	language:C	file:
ANET_CONNECT_NONE	anet.c	/^#define ANET_CONNECT_NONE /;"	d	language:C	file:
ANET_ERR	anet.h	/^#define ANET_ERR /;"	d	language:C
ANET_ERR_LEN	anet.h	/^#define ANET_ERR_LEN /;"	d	language:C
ANET_H	anet.h	/^#define ANET_H$/;"	d	language:C
ANET_IP_ONLY	anet.h	/^#define ANET_IP_ONLY /;"	d	language:C
ANET_NONE	anet.h	/^#define ANET_NONE /;"	d	language:C
ANET_OK	anet.h	/^#define ANET_OK /;"	d	language:C
AOF	modules/API.md	/^Replicate the specified command and arguments to slaves and AOF, as effect$/;"	v	language:C
AOF	modules/TYPES.md	/^in AOF, the type reporting via the `TYPE` command, and so forth.$/;"	v	language:C
AOF_AUTOSYNC_BYTES	server.h	/^#define AOF_AUTOSYNC_BYTES /;"	d	language:C
AOF_FSYNC_ALWAYS	server.h	/^#define AOF_FSYNC_ALWAYS /;"	d	language:C
AOF_FSYNC_EVERYSEC	server.h	/^#define AOF_FSYNC_EVERYSEC /;"	d	language:C
AOF_FSYNC_NO	server.h	/^#define AOF_FSYNC_NO /;"	d	language:C
AOF_OFF	server.h	/^#define AOF_OFF /;"	d	language:C
AOF_ON	server.h	/^#define AOF_ON /;"	d	language:C
AOF_REWRITE_ITEMS_PER_CMD	server.h	/^#define AOF_REWRITE_ITEMS_PER_CMD /;"	d	language:C
AOF_REWRITE_MIN_SIZE	server.h	/^#define AOF_REWRITE_MIN_SIZE /;"	d	language:C
AOF_REWRITE_PERC	server.h	/^#define AOF_REWRITE_PERC /;"	d	language:C
AOF_RW_BUF_BLOCK_SIZE	aof.c	/^#define AOF_RW_BUF_BLOCK_SIZE /;"	d	language:C	file:
AOF_WAIT_REWRITE	server.h	/^#define AOF_WAIT_REWRITE /;"	d	language:C
AOF_WRITE_LOG_ERROR_RATE	aof.c	/^#define AOF_WRITE_LOG_ERROR_RATE /;"	d	language:C	file:
API	modules/API.md	/^modules type API, since a single module may register multiple types.$/;"	v	language:C
API	modules/INTRO.md	/^Redis Modules: an introduction to the API$/;"	v	language:C
APIs	modules/INTRO.md	/^returned by other APIs, where it is specified that the returned string must$/;"	v	language:C
AVOID_ERRNO	lzfP.h	/^# define AVOID_ERRNO /;"	d	language:C
AutoMemEntry	module.c	/^struct AutoMemEntry {$/;"	s	language:C	file:
AutoMemEntry::ptr	module.c	/^    void *ptr;$/;"	m	language:C	struct:AutoMemEntry	file:	access:public
AutoMemEntry::type	module.c	/^    int type;$/;"	m	language:C	struct:AutoMemEntry	file:	access:public
B	geohash.c	/^    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,$/;"	l	language:C	file:
BFOVERFLOW_FAIL	bitops.c	/^#define BFOVERFLOW_FAIL /;"	d	language:C	file:
BFOVERFLOW_SAT	bitops.c	/^#define BFOVERFLOW_SAT /;"	d	language:C	file:
BFOVERFLOW_WRAP	bitops.c	/^#define BFOVERFLOW_WRAP /;"	d	language:C	file:
BIG_ENDIAN	config.h	/^#define	BIG_ENDIAN	/;"	d	language:C
BIG_ENDIAN	config.h	/^#define BIG_ENDIAN /;"	d	language:C
BIO_AOF_FSYNC	bio.h	/^#define BIO_AOF_FSYNC /;"	d	language:C
BIO_CLOSE_FILE	bio.h	/^#define BIO_CLOSE_FILE /;"	d	language:C
BIO_LAZY_FREE	bio.h	/^#define BIO_LAZY_FREE /;"	d	language:C
BIO_NUM_OPS	bio.h	/^#define BIO_NUM_OPS /;"	d	language:C
BITFIELDOP_GET	bitops.c	/^#define BITFIELDOP_GET /;"	d	language:C	file:
BITFIELDOP_INCRBY	bitops.c	/^#define BITFIELDOP_INCRBY /;"	d	language:C	file:
BITFIELDOP_SET	bitops.c	/^#define BITFIELDOP_SET /;"	d	language:C	file:
BITOP_AND	bitops.c	/^#define BITOP_AND /;"	d	language:C	file:
BITOP_NOT	bitops.c	/^#define BITOP_NOT /;"	d	language:C	file:
BITOP_OR	bitops.c	/^#define BITOP_OR /;"	d	language:C	file:
BITOP_XOR	bitops.c	/^#define BITOP_XOR /;"	d	language:C	file:
BLOCKED_LIST	server.h	/^#define BLOCKED_LIST /;"	d	language:C
BLOCKED_NONE	server.h	/^#define BLOCKED_NONE /;"	d	language:C
BLOCKED_WAIT	server.h	/^#define BLOCKED_WAIT /;"	d	language:C
BUFSIZE	sha1.c	/^#define BUFSIZE /;"	d	language:C	file:
BYTE_ORDER	config.h	/^#define BYTE_ORDER	/;"	d	language:C
BYTE_ORDER	config.h	/^#define BYTE_ORDER /;"	d	language:C
BalancedTreeType	modules/API.md	/^     static RedisModuleType *BalancedTreeType;$/;"	v	language:C	file:
C	rand.c	/^#define C	/;"	d	language:C	file:
CARRY	rand.c	/^#define CARRY(/;"	d	language:C	file:
CHAR64LONG16	sha1.c	/^    } CHAR64LONG16;$/;"	t	language:C	typeref:union:__anon38	file:
CHECK_INPUT	lzfP.h	/^# define CHECK_INPUT /;"	d	language:C
CLIENTS_CRON_MIN_ITERATIONS	server.c	/^#define CLIENTS_CRON_MIN_ITERATIONS /;"	d	language:C	file:
CLIENT_ASKING	server.h	/^#define CLIENT_ASKING /;"	d	language:C
CLIENT_BLOCKED	server.h	/^#define CLIENT_BLOCKED /;"	d	language:C
CLIENT_CLOSE_AFTER_REPLY	server.h	/^#define CLIENT_CLOSE_AFTER_REPLY /;"	d	language:C
CLIENT_CLOSE_ASAP	server.h	/^#define CLIENT_CLOSE_ASAP /;"	d	language:C
CLIENT_DIRTY_CAS	server.h	/^#define CLIENT_DIRTY_CAS /;"	d	language:C
CLIENT_DIRTY_EXEC	server.h	/^#define CLIENT_DIRTY_EXEC /;"	d	language:C
CLIENT_FORCE_AOF	server.h	/^#define CLIENT_FORCE_AOF /;"	d	language:C
CLIENT_FORCE_REPL	server.h	/^#define CLIENT_FORCE_REPL /;"	d	language:C
CLIENT_LUA	server.h	/^#define CLIENT_LUA /;"	d	language:C
CLIENT_LUA_DEBUG	server.h	/^#define CLIENT_LUA_DEBUG /;"	d	language:C
CLIENT_LUA_DEBUG_SYNC	server.h	/^#define CLIENT_LUA_DEBUG_SYNC /;"	d	language:C
CLIENT_MASTER	server.h	/^#define CLIENT_MASTER /;"	d	language:C
CLIENT_MASTER_FORCE_REPLY	server.h	/^#define CLIENT_MASTER_FORCE_REPLY /;"	d	language:C
CLIENT_MODULE	server.h	/^#define CLIENT_MODULE /;"	d	language:C
CLIENT_MONITOR	server.h	/^#define CLIENT_MONITOR /;"	d	language:C
CLIENT_MULTI	server.h	/^#define CLIENT_MULTI /;"	d	language:C
CLIENT_PENDING_WRITE	server.h	/^#define CLIENT_PENDING_WRITE /;"	d	language:C
CLIENT_PREVENT_AOF_PROP	server.h	/^#define CLIENT_PREVENT_AOF_PROP /;"	d	language:C
CLIENT_PREVENT_PROP	server.h	/^#define CLIENT_PREVENT_PROP /;"	d	language:C
CLIENT_PREVENT_REPL_PROP	server.h	/^#define CLIENT_PREVENT_REPL_PROP /;"	d	language:C
CLIENT_PRE_PSYNC	server.h	/^#define CLIENT_PRE_PSYNC /;"	d	language:C
CLIENT_PUBSUB	server.h	/^#define CLIENT_PUBSUB /;"	d	language:C
CLIENT_READONLY	server.h	/^#define CLIENT_READONLY /;"	d	language:C
CLIENT_REPLY_OFF	server.h	/^#define CLIENT_REPLY_OFF /;"	d	language:C
CLIENT_REPLY_SKIP	server.h	/^#define CLIENT_REPLY_SKIP /;"	d	language:C
CLIENT_REPLY_SKIP_NEXT	server.h	/^#define CLIENT_REPLY_SKIP_NEXT /;"	d	language:C
CLIENT_SLAVE	server.h	/^#define CLIENT_SLAVE /;"	d	language:C
CLIENT_TYPE_MASTER	server.h	/^#define CLIENT_TYPE_MASTER /;"	d	language:C
CLIENT_TYPE_NORMAL	server.h	/^#define CLIENT_TYPE_NORMAL /;"	d	language:C
CLIENT_TYPE_OBUF_COUNT	server.h	/^#define CLIENT_TYPE_OBUF_COUNT /;"	d	language:C
CLIENT_TYPE_PUBSUB	server.h	/^#define CLIENT_TYPE_PUBSUB /;"	d	language:C
CLIENT_TYPE_SLAVE	server.h	/^#define CLIENT_TYPE_SLAVE /;"	d	language:C
CLIENT_UNBLOCKED	server.h	/^#define CLIENT_UNBLOCKED /;"	d	language:C
CLIENT_UNIX_SOCKET	server.h	/^#define CLIENT_UNIX_SOCKET /;"	d	language:C
CLI_HELP_COMMAND	redis-cli.c	/^#define CLI_HELP_COMMAND /;"	d	language:C	file:
CLI_HELP_GROUP	redis-cli.c	/^#define CLI_HELP_GROUP /;"	d	language:C	file:
CLUSTERMSG_FLAG0_FORCEACK	cluster.h	/^#define CLUSTERMSG_FLAG0_FORCEACK /;"	d	language:C
CLUSTERMSG_FLAG0_PAUSED	cluster.h	/^#define CLUSTERMSG_FLAG0_PAUSED /;"	d	language:C
CLUSTERMSG_MIN_LEN	cluster.h	/^#define CLUSTERMSG_MIN_LEN /;"	d	language:C
CLUSTERMSG_TYPE_FAIL	cluster.h	/^#define CLUSTERMSG_TYPE_FAIL /;"	d	language:C
CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK	cluster.h	/^#define CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK /;"	d	language:C
CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST	cluster.h	/^#define CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST /;"	d	language:C
CLUSTERMSG_TYPE_MEET	cluster.h	/^#define CLUSTERMSG_TYPE_MEET /;"	d	language:C
CLUSTERMSG_TYPE_MFSTART	cluster.h	/^#define CLUSTERMSG_TYPE_MFSTART /;"	d	language:C
CLUSTERMSG_TYPE_PING	cluster.h	/^#define CLUSTERMSG_TYPE_PING /;"	d	language:C
CLUSTERMSG_TYPE_PONG	cluster.h	/^#define CLUSTERMSG_TYPE_PONG /;"	d	language:C
CLUSTERMSG_TYPE_PUBLISH	cluster.h	/^#define CLUSTERMSG_TYPE_PUBLISH /;"	d	language:C
CLUSTERMSG_TYPE_UPDATE	cluster.h	/^#define CLUSTERMSG_TYPE_UPDATE /;"	d	language:C
CLUSTER_BLACKLIST_TTL	cluster.c	/^#define CLUSTER_BLACKLIST_TTL /;"	d	language:C	file:
CLUSTER_BROADCAST_ALL	cluster.c	/^#define CLUSTER_BROADCAST_ALL /;"	d	language:C	file:
CLUSTER_BROADCAST_LOCAL_SLAVES	cluster.c	/^#define CLUSTER_BROADCAST_LOCAL_SLAVES /;"	d	language:C	file:
CLUSTER_CANT_FAILOVER_DATA_AGE	cluster.h	/^#define CLUSTER_CANT_FAILOVER_DATA_AGE /;"	d	language:C
CLUSTER_CANT_FAILOVER_EXPIRED	cluster.h	/^#define CLUSTER_CANT_FAILOVER_EXPIRED /;"	d	language:C
CLUSTER_CANT_FAILOVER_NONE	cluster.h	/^#define CLUSTER_CANT_FAILOVER_NONE /;"	d	language:C
CLUSTER_CANT_FAILOVER_RELOG_PERIOD	cluster.h	/^#define CLUSTER_CANT_FAILOVER_RELOG_PERIOD /;"	d	language:C
CLUSTER_CANT_FAILOVER_WAITING_DELAY	cluster.h	/^#define CLUSTER_CANT_FAILOVER_WAITING_DELAY /;"	d	language:C
CLUSTER_CANT_FAILOVER_WAITING_VOTES	cluster.h	/^#define CLUSTER_CANT_FAILOVER_WAITING_VOTES /;"	d	language:C
CLUSTER_DEFAULT_MIGRATION_BARRIER	cluster.h	/^#define CLUSTER_DEFAULT_MIGRATION_BARRIER /;"	d	language:C
CLUSTER_DEFAULT_NODE_TIMEOUT	cluster.h	/^#define CLUSTER_DEFAULT_NODE_TIMEOUT /;"	d	language:C
CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE	cluster.h	/^#define CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE /;"	d	language:C
CLUSTER_DEFAULT_SLAVE_VALIDITY	cluster.h	/^#define CLUSTER_DEFAULT_SLAVE_VALIDITY /;"	d	language:C
CLUSTER_FAIL	cluster.h	/^#define CLUSTER_FAIL /;"	d	language:C
CLUSTER_FAILOVER_DELAY	cluster.h	/^#define CLUSTER_FAILOVER_DELAY /;"	d	language:C
CLUSTER_FAIL_REPORT_VALIDITY_MULT	cluster.h	/^#define CLUSTER_FAIL_REPORT_VALIDITY_MULT /;"	d	language:C
CLUSTER_FAIL_UNDO_TIME_ADD	cluster.h	/^#define CLUSTER_FAIL_UNDO_TIME_ADD /;"	d	language:C
CLUSTER_FAIL_UNDO_TIME_MULT	cluster.h	/^#define CLUSTER_FAIL_UNDO_TIME_MULT /;"	d	language:C
CLUSTER_MAX_REJOIN_DELAY	cluster.c	/^#define CLUSTER_MAX_REJOIN_DELAY /;"	d	language:C	file:
CLUSTER_MF_PAUSE_MULT	cluster.h	/^#define CLUSTER_MF_PAUSE_MULT /;"	d	language:C
CLUSTER_MF_TIMEOUT	cluster.h	/^#define CLUSTER_MF_TIMEOUT /;"	d	language:C
CLUSTER_MIN_REJOIN_DELAY	cluster.c	/^#define CLUSTER_MIN_REJOIN_DELAY /;"	d	language:C	file:
CLUSTER_NAMELEN	cluster.h	/^#define CLUSTER_NAMELEN /;"	d	language:C
CLUSTER_NODE_FAIL	cluster.h	/^#define CLUSTER_NODE_FAIL /;"	d	language:C
CLUSTER_NODE_HANDSHAKE	cluster.h	/^#define CLUSTER_NODE_HANDSHAKE /;"	d	language:C
CLUSTER_NODE_MASTER	cluster.h	/^#define CLUSTER_NODE_MASTER /;"	d	language:C
CLUSTER_NODE_MEET	cluster.h	/^#define CLUSTER_NODE_MEET /;"	d	language:C
CLUSTER_NODE_MIGRATE_TO	cluster.h	/^#define CLUSTER_NODE_MIGRATE_TO /;"	d	language:C
CLUSTER_NODE_MYSELF	cluster.h	/^#define CLUSTER_NODE_MYSELF /;"	d	language:C
CLUSTER_NODE_NOADDR	cluster.h	/^#define CLUSTER_NODE_NOADDR /;"	d	language:C
CLUSTER_NODE_NULL_NAME	cluster.h	/^#define CLUSTER_NODE_NULL_NAME /;"	d	language:C
CLUSTER_NODE_PFAIL	cluster.h	/^#define CLUSTER_NODE_PFAIL /;"	d	language:C
CLUSTER_NODE_SLAVE	cluster.h	/^#define CLUSTER_NODE_SLAVE /;"	d	language:C
CLUSTER_OK	cluster.h	/^#define CLUSTER_OK /;"	d	language:C
CLUSTER_PORT_INCR	cluster.h	/^#define CLUSTER_PORT_INCR /;"	d	language:C
CLUSTER_PROTO_VER	cluster.h	/^#define CLUSTER_PROTO_VER /;"	d	language:C
CLUSTER_REDIR_ASK	cluster.h	/^#define CLUSTER_REDIR_ASK /;"	d	language:C
CLUSTER_REDIR_CROSS_SLOT	cluster.h	/^#define CLUSTER_REDIR_CROSS_SLOT /;"	d	language:C
CLUSTER_REDIR_DOWN_STATE	cluster.h	/^#define CLUSTER_REDIR_DOWN_STATE /;"	d	language:C
CLUSTER_REDIR_DOWN_UNBOUND	cluster.h	/^#define CLUSTER_REDIR_DOWN_UNBOUND /;"	d	language:C
CLUSTER_REDIR_MOVED	cluster.h	/^#define CLUSTER_REDIR_MOVED /;"	d	language:C
CLUSTER_REDIR_NONE	cluster.h	/^#define CLUSTER_REDIR_NONE /;"	d	language:C
CLUSTER_REDIR_UNSTABLE	cluster.h	/^#define CLUSTER_REDIR_UNSTABLE /;"	d	language:C
CLUSTER_SLAVE_MIGRATION_DELAY	cluster.h	/^#define CLUSTER_SLAVE_MIGRATION_DELAY /;"	d	language:C
CLUSTER_SLOTS	cluster.h	/^#define CLUSTER_SLOTS /;"	d	language:C
CLUSTER_TODO_FSYNC_CONFIG	cluster.h	/^#define CLUSTER_TODO_FSYNC_CONFIG /;"	d	language:C
CLUSTER_TODO_HANDLE_FAILOVER	cluster.h	/^#define CLUSTER_TODO_HANDLE_FAILOVER /;"	d	language:C
CLUSTER_TODO_SAVE_CONFIG	cluster.h	/^#define CLUSTER_TODO_SAVE_CONFIG /;"	d	language:C
CLUSTER_TODO_UPDATE_STATE	cluster.h	/^#define CLUSTER_TODO_UPDATE_STATE /;"	d	language:C
CLUSTER_WRITABLE_DELAY	cluster.c	/^#define CLUSTER_WRITABLE_DELAY /;"	d	language:C	file:
CMD_ADMIN	server.h	/^#define CMD_ADMIN /;"	d	language:C
CMD_ASKING	server.h	/^#define CMD_ASKING /;"	d	language:C
CMD_CALL_FULL	server.h	/^#define CMD_CALL_FULL /;"	d	language:C
CMD_CALL_NONE	server.h	/^#define CMD_CALL_NONE /;"	d	language:C
CMD_CALL_PROPAGATE	server.h	/^#define CMD_CALL_PROPAGATE /;"	d	language:C
CMD_CALL_PROPAGATE_AOF	server.h	/^#define CMD_CALL_PROPAGATE_AOF /;"	d	language:C
CMD_CALL_PROPAGATE_REPL	server.h	/^#define CMD_CALL_PROPAGATE_REPL /;"	d	language:C
CMD_CALL_SLOWLOG	server.h	/^#define CMD_CALL_SLOWLOG /;"	d	language:C
CMD_CALL_STATS	server.h	/^#define CMD_CALL_STATS /;"	d	language:C
CMD_DENYOOM	server.h	/^#define CMD_DENYOOM /;"	d	language:C
CMD_FAST	server.h	/^#define CMD_FAST /;"	d	language:C
CMD_LOADING	server.h	/^#define CMD_LOADING /;"	d	language:C
CMD_MODULE	server.h	/^#define CMD_MODULE /;"	d	language:C
CMD_MODULE_GETKEYS	server.h	/^#define CMD_MODULE_GETKEYS /;"	d	language:C
CMD_MODULE_NO_CLUSTER	server.h	/^#define CMD_MODULE_NO_CLUSTER /;"	d	language:C
CMD_NOSCRIPT	server.h	/^#define CMD_NOSCRIPT /;"	d	language:C
CMD_PUBSUB	server.h	/^#define CMD_PUBSUB /;"	d	language:C
CMD_RANDOM	server.h	/^#define CMD_RANDOM /;"	d	language:C
CMD_READONLY	server.h	/^#define CMD_READONLY /;"	d	language:C
CMD_SKIP_MONITOR	server.h	/^#define CMD_SKIP_MONITOR /;"	d	language:C
CMD_SORT_FOR_SCRIPT	server.h	/^#define CMD_SORT_FOR_SCRIPT /;"	d	language:C
CMD_STALE	server.h	/^#define CMD_STALE /;"	d	language:C
CMD_WRITE	server.h	/^#define CMD_WRITE /;"	d	language:C
COM	geohash_helper.c	/^#define COM /;"	d	language:C	file:
COMPRESS_MAX	quicklist.c	/^#define COMPRESS_MAX /;"	d	language:C	file:
CONFIG_AUTHPASS_MAX_LEN	server.h	/^#define CONFIG_AUTHPASS_MAX_LEN /;"	d	language:C
CONFIG_BGSAVE_RETRY_DELAY	server.h	/^#define CONFIG_BGSAVE_RETRY_DELAY /;"	d	language:C
CONFIG_BINDADDR_MAX	server.h	/^#define CONFIG_BINDADDR_MAX /;"	d	language:C
CONFIG_DEFAULT_ACTIVE_REHASHING	server.h	/^#define CONFIG_DEFAULT_ACTIVE_REHASHING /;"	d	language:C
CONFIG_DEFAULT_AOF_FILENAME	server.h	/^#define CONFIG_DEFAULT_AOF_FILENAME /;"	d	language:C
CONFIG_DEFAULT_AOF_FSYNC	server.h	/^#define CONFIG_DEFAULT_AOF_FSYNC /;"	d	language:C
CONFIG_DEFAULT_AOF_LOAD_TRUNCATED	server.h	/^#define CONFIG_DEFAULT_AOF_LOAD_TRUNCATED /;"	d	language:C
CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE	server.h	/^#define CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE /;"	d	language:C
CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC	server.h	/^#define CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC /;"	d	language:C
CONFIG_DEFAULT_CLIENT_TIMEOUT	server.h	/^#define CONFIG_DEFAULT_CLIENT_TIMEOUT /;"	d	language:C
CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT	server.h	/^#define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT /;"	d	language:C
CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP	server.h	/^#define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP /;"	d	language:C
CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT	server.h	/^#define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT /;"	d	language:C
CONFIG_DEFAULT_CLUSTER_CONFIG_FILE	server.h	/^#define CONFIG_DEFAULT_CLUSTER_CONFIG_FILE /;"	d	language:C
CONFIG_DEFAULT_DAEMONIZE	server.h	/^#define CONFIG_DEFAULT_DAEMONIZE /;"	d	language:C
CONFIG_DEFAULT_DBNUM	server.h	/^#define CONFIG_DEFAULT_DBNUM /;"	d	language:C
CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES	server.h	/^#define CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES /;"	d	language:C
CONFIG_DEFAULT_HZ	server.h	/^#define CONFIG_DEFAULT_HZ /;"	d	language:C
CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD	server.h	/^#define CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD /;"	d	language:C
CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION	server.h	/^#define CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION /;"	d	language:C
CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE	server.h	/^#define CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE /;"	d	language:C
CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL	server.h	/^#define CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL /;"	d	language:C
CONFIG_DEFAULT_LFU_DECAY_TIME	server.h	/^#define CONFIG_DEFAULT_LFU_DECAY_TIME /;"	d	language:C
CONFIG_DEFAULT_LFU_LOG_FACTOR	server.h	/^#define CONFIG_DEFAULT_LFU_LOG_FACTOR /;"	d	language:C
CONFIG_DEFAULT_LOGFILE	server.h	/^#define CONFIG_DEFAULT_LOGFILE /;"	d	language:C
CONFIG_DEFAULT_MAXMEMORY	server.h	/^#define CONFIG_DEFAULT_MAXMEMORY /;"	d	language:C
CONFIG_DEFAULT_MAXMEMORY_POLICY	server.h	/^#define CONFIG_DEFAULT_MAXMEMORY_POLICY /;"	d	language:C
CONFIG_DEFAULT_MAXMEMORY_SAMPLES	server.h	/^#define CONFIG_DEFAULT_MAXMEMORY_SAMPLES /;"	d	language:C
CONFIG_DEFAULT_MAX_CLIENTS	server.h	/^#define CONFIG_DEFAULT_MAX_CLIENTS /;"	d	language:C
CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG	server.h	/^#define CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG /;"	d	language:C
CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE	server.h	/^#define CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE /;"	d	language:C
CONFIG_DEFAULT_PID_FILE	server.h	/^#define CONFIG_DEFAULT_PID_FILE /;"	d	language:C
CONFIG_DEFAULT_PROTECTED_MODE	server.h	/^#define CONFIG_DEFAULT_PROTECTED_MODE /;"	d	language:C
CONFIG_DEFAULT_RDB_CHECKSUM	server.h	/^#define CONFIG_DEFAULT_RDB_CHECKSUM /;"	d	language:C
CONFIG_DEFAULT_RDB_COMPRESSION	server.h	/^#define CONFIG_DEFAULT_RDB_COMPRESSION /;"	d	language:C
CONFIG_DEFAULT_RDB_FILENAME	server.h	/^#define CONFIG_DEFAULT_RDB_FILENAME /;"	d	language:C
CONFIG_DEFAULT_REPL_BACKLOG_SIZE	server.h	/^#define CONFIG_DEFAULT_REPL_BACKLOG_SIZE /;"	d	language:C
CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT	server.h	/^#define CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT /;"	d	language:C
CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY	server.h	/^#define CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY /;"	d	language:C
CONFIG_DEFAULT_REPL_DISKLESS_SYNC	server.h	/^#define CONFIG_DEFAULT_REPL_DISKLESS_SYNC /;"	d	language:C
CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY	server.h	/^#define CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY /;"	d	language:C
CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD	server.h	/^#define CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD /;"	d	language:C
CONFIG_DEFAULT_REPL_TIMEOUT	server.h	/^#define CONFIG_DEFAULT_REPL_TIMEOUT /;"	d	language:C
CONFIG_DEFAULT_SERVER_PORT	server.h	/^#define CONFIG_DEFAULT_SERVER_PORT /;"	d	language:C
CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP	server.h	/^#define CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP /;"	d	language:C
CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT	server.h	/^#define CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT /;"	d	language:C
CONFIG_DEFAULT_SLAVE_LAZY_FLUSH	server.h	/^#define CONFIG_DEFAULT_SLAVE_LAZY_FLUSH /;"	d	language:C
CONFIG_DEFAULT_SLAVE_PRIORITY	server.h	/^#define CONFIG_DEFAULT_SLAVE_PRIORITY /;"	d	language:C
CONFIG_DEFAULT_SLAVE_READ_ONLY	server.h	/^#define CONFIG_DEFAULT_SLAVE_READ_ONLY /;"	d	language:C
CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA	server.h	/^#define CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA /;"	d	language:C
CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN	server.h	/^#define CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN /;"	d	language:C
CONFIG_DEFAULT_SLOWLOG_MAX_LEN	server.h	/^#define CONFIG_DEFAULT_SLOWLOG_MAX_LEN /;"	d	language:C
CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR	server.h	/^#define CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR /;"	d	language:C
CONFIG_DEFAULT_SYSLOG_ENABLED	server.h	/^#define CONFIG_DEFAULT_SYSLOG_ENABLED /;"	d	language:C
CONFIG_DEFAULT_SYSLOG_IDENT	server.h	/^#define CONFIG_DEFAULT_SYSLOG_IDENT /;"	d	language:C
CONFIG_DEFAULT_TCP_BACKLOG	server.h	/^#define CONFIG_DEFAULT_TCP_BACKLOG /;"	d	language:C
CONFIG_DEFAULT_TCP_KEEPALIVE	server.h	/^#define CONFIG_DEFAULT_TCP_KEEPALIVE /;"	d	language:C
CONFIG_DEFAULT_UNIX_SOCKET_PERM	server.h	/^#define CONFIG_DEFAULT_UNIX_SOCKET_PERM /;"	d	language:C
CONFIG_DEFAULT_VERBOSITY	server.h	/^#define CONFIG_DEFAULT_VERBOSITY /;"	d	language:C
CONFIG_FDSET_INCR	server.h	/^#define CONFIG_FDSET_INCR /;"	d	language:C
CONFIG_MAX_HZ	server.h	/^#define CONFIG_MAX_HZ /;"	d	language:C
CONFIG_MAX_LINE	server.h	/^#define CONFIG_MAX_LINE /;"	d	language:C
CONFIG_MIN_HZ	server.h	/^#define CONFIG_MIN_HZ /;"	d	language:C
CONFIG_MIN_RESERVED_FDS	server.h	/^#define CONFIG_MIN_RESERVED_FDS /;"	d	language:C
CONFIG_REPL_BACKLOG_MIN_SIZE	server.h	/^#define CONFIG_REPL_BACKLOG_MIN_SIZE /;"	d	language:C
CONFIG_REPL_SYNCIO_TIMEOUT	server.h	/^#define CONFIG_REPL_SYNCIO_TIMEOUT /;"	d	language:C
CONFIG_RUN_ID_SIZE	server.h	/^#define CONFIG_RUN_ID_SIZE /;"	d	language:C
CRC64_H	crc64.h	/^#define CRC64_H$/;"	d	language:C
CRON_DBS_PER_CALL	server.h	/^#define CRON_DBS_PER_CALL /;"	d	language:C
C_ERR	server.h	/^#define C_ERR /;"	d	language:C
C_OK	server.h	/^#define C_OK /;"	d	language:C
ClusterHashSlots	redis-trib.rb	/^ClusterHashSlots = 16384$/;"	v	language:C
D	debugmacro.h	/^#define D(/;"	d	language:C
D	quicklist.c	/^#define D(/;"	d	language:C	file:
DEG_TO_RAD	geohash_helper.c	/^const double DEG_TO_RAD = 0.017453292519943295769236907684886;$/;"	v	language:C
DICT_ERR	dict.h	/^#define DICT_ERR /;"	d	language:C
DICT_HT_INITIAL_SIZE	dict.h	/^#define DICT_HT_INITIAL_SIZE /;"	d	language:C
DICT_NOTUSED	dict.h	/^#define DICT_NOTUSED(/;"	d	language:C
DICT_OK	dict.h	/^#define DICT_OK /;"	d	language:C
DICT_STATS_VECTLEN	dict.c	/^#define DICT_STATS_VECTLEN /;"	d	language:C	file:
D_R	geohash_helper.c	/^#define D_R /;"	d	language:C	file:
DoubleArrayRDBLoad	modules/TYPES.md	/^    void *DoubleArrayRDBLoad(RedisModuleIO *io, int encver) {$/;"	f	language:C	signature:(RedisModuleIO *io, int encver)
DoubleArrayRDBSave	modules/TYPES.md	/^    void DoubleArrayRDBSave(RedisModuleIO *io, void *ptr) {$/;"	f	language:C	signature:(RedisModuleIO *io, void *ptr)
E	hyperloglog.c	/^    double E = 0;$/;"	l	language:C
E	hyperloglog.c	/^    double E, alpha = 0.7213\/(1+1.079\/m);$/;"	l	language:C
EARTH_RADIUS_IN_METERS	geohash_helper.c	/^const double EARTH_RADIUS_IN_METERS = 6372797.560856;$/;"	v	language:C
ECCENT	geohash_helper.c	/^#define ECCENT /;"	d	language:C	file:
EMPTYDB_ASYNC	server.h	/^#define EMPTYDB_ASYNC /;"	d	language:C
EMPTYDB_NO_FLAGS	server.h	/^#define EMPTYDB_NO_FLAGS /;"	d	language:C
ERR	quicklist.c	/^#define ERR(/;"	d	language:C	file:
ERROR	quicklist.c	/^#define ERROR /;"	d	language:C	file:
ERROR	redis-check-aof.c	/^#define ERROR(/;"	d	language:C	file:
EVPOOL_CACHED_SDS_SIZE	evict.c	/^#define EVPOOL_CACHED_SDS_SIZE /;"	d	language:C	file:
EVPOOL_SIZE	evict.c	/^#define EVPOOL_SIZE /;"	d	language:C	file:
EvictionPoolLRU	evict.c	/^static struct evictionPoolEntry *EvictionPoolLRU;$/;"	v	language:C	typeref:struct:evictionPoolEntry	file:
FILL_MAX	quicklist.c	/^#define FILL_MAX /;"	d	language:C	file:
FRST	lzf_c.c	/^# define FRST(/;"	d	language:C	file:
Finally	modules/INTRO.md	/^Finally, you can unload (and later reload if you wish) a module using the$/;"	v	language:C
GEOHASH_EAST	geohash.h	/^    GEOHASH_EAST,$/;"	e	language:C	enum:__anon13
GEOHASH_HELPER_HPP_	geohash_helper.h	/^#define GEOHASH_HELPER_HPP_$/;"	d	language:C
GEOHASH_H_	geohash.h	/^#define GEOHASH_H_$/;"	d	language:C
GEOHASH_NORTH	geohash.h	/^    GEOHASH_NORTH = 0,$/;"	e	language:C	enum:__anon13
GEOHASH_NORT_EAST	geohash.h	/^    GEOHASH_NORT_EAST$/;"	e	language:C	enum:__anon13
GEOHASH_NORT_WEST	geohash.h	/^    GEOHASH_NORT_WEST,$/;"	e	language:C	enum:__anon13
GEOHASH_SOUTH	geohash.h	/^    GEOHASH_SOUTH,$/;"	e	language:C	enum:__anon13
GEOHASH_SOUTH_EAST	geohash.h	/^    GEOHASH_SOUTH_EAST,$/;"	e	language:C	enum:__anon13
GEOHASH_SOUTH_WEST	geohash.h	/^    GEOHASH_SOUTH_WEST,$/;"	e	language:C	enum:__anon13
GEOHASH_WEST	geohash.h	/^    GEOHASH_WEST,$/;"	e	language:C	enum:__anon13
GEO_LAT_MAX	geohash.h	/^#define GEO_LAT_MAX /;"	d	language:C
GEO_LAT_MIN	geohash.h	/^#define GEO_LAT_MIN /;"	d	language:C
GEO_LONG_MAX	geohash.h	/^#define GEO_LONG_MAX /;"	d	language:C
GEO_LONG_MIN	geohash.h	/^#define GEO_LONG_MIN /;"	d	language:C
GEO_STEP_MAX	geohash.h	/^#define GEO_STEP_MAX /;"	d	language:C
GISNOTZERO	geohash_helper.h	/^#define GISNOTZERO(/;"	d	language:C
GISZERO	geohash_helper.h	/^#define GISZERO(/;"	d	language:C
GNUC_VERSION	config.h	/^#define GNUC_VERSION /;"	d	language:C
GZERO	geohash_helper.h	/^#define GZERO(/;"	d	language:C
GeoDirection	geohash.h	/^} GeoDirection;$/;"	t	language:C	typeref:enum:__anon13
GeoHashArea	geohash.h	/^} GeoHashArea;$/;"	t	language:C	typeref:struct:__anon16
GeoHashBits	geohash.h	/^} GeoHashBits;$/;"	t	language:C	typeref:struct:__anon14
GeoHashBitsComparator	geohash_helper.h	/^int GeoHashBitsComparator(const GeoHashBits *a, const GeoHashBits *b);$/;"	p	language:C	signature:(const GeoHashBits *a, const GeoHashBits *b)
GeoHashFix52Bits	geohash_helper.h	/^typedef uint64_t GeoHashFix52Bits;$/;"	t	language:C
GeoHashNeighbors	geohash.h	/^} GeoHashNeighbors;$/;"	t	language:C	typeref:struct:__anon17
GeoHashRadius	geohash_helper.h	/^} GeoHashRadius;$/;"	t	language:C	typeref:struct:__anon18
GeoHashRange	geohash.h	/^} GeoHashRange;$/;"	t	language:C	typeref:struct:__anon15
GeoHashVarBits	geohash_helper.h	/^typedef uint64_t GeoHashVarBits;$/;"	t	language:C
HASHISZERO	geohash.h	/^#define HASHISZERO(/;"	d	language:C
HASHTABLE_MIN_FILL	server.h	/^#define HASHTABLE_MIN_FILL /;"	d	language:C
HASH_SET_COPY	server.h	/^#define HASH_SET_COPY /;"	d	language:C
HASH_SET_COPY	t_hash.c	/^#define HASH_SET_COPY /;"	d	language:C	file:
HASH_SET_TAKE_FIELD	server.h	/^#define HASH_SET_TAKE_FIELD /;"	d	language:C
HASH_SET_TAKE_FIELD	t_hash.c	/^#define HASH_SET_TAKE_FIELD /;"	d	language:C	file:
HASH_SET_TAKE_VALUE	server.h	/^#define HASH_SET_TAKE_VALUE /;"	d	language:C
HASH_SET_TAKE_VALUE	t_hash.c	/^#define HASH_SET_TAKE_VALUE /;"	d	language:C	file:
HAVE_ATOMIC	config.h	/^#define HAVE_ATOMIC$/;"	d	language:C
HAVE_BACKTRACE	config.h	/^#define HAVE_BACKTRACE /;"	d	language:C
HAVE_EPOLL	config.h	/^#define HAVE_EPOLL /;"	d	language:C
HAVE_EVPORT	config.h	/^#define HAVE_EVPORT /;"	d	language:C
HAVE_KQUEUE	config.h	/^#define HAVE_KQUEUE /;"	d	language:C
HAVE_MALLOC_SIZE	zmalloc.h	/^#define HAVE_MALLOC_SIZE /;"	d	language:C
HAVE_MSG_NOSIGNAL	config.h	/^#define HAVE_MSG_NOSIGNAL /;"	d	language:C
HAVE_PROC_MAPS	config.h	/^#define HAVE_PROC_MAPS /;"	d	language:C
HAVE_PROC_SMAPS	config.h	/^#define HAVE_PROC_SMAPS /;"	d	language:C
HAVE_PROC_SOMAXCONN	config.h	/^#define HAVE_PROC_SOMAXCONN /;"	d	language:C
HAVE_PROC_STAT	config.h	/^#define HAVE_PROC_STAT /;"	d	language:C
HAVE_SETPROCTITLE	setproctitle.c	/^#define HAVE_SETPROCTITLE /;"	d	language:C	file:
HAVE_SYNC_FILE_RANGE	config.h	/^#define HAVE_SYNC_FILE_RANGE /;"	d	language:C
HAVE_TASKINFO	config.h	/^#define HAVE_TASKINFO /;"	d	language:C
HIGH	rand.c	/^#define HIGH(/;"	d	language:C	file:
HI_BIT	rand.c	/^#define HI_BIT	/;"	d	language:C	file:
HLL_BITS	hyperloglog.c	/^#define HLL_BITS /;"	d	language:C	file:
HLL_DENSE	hyperloglog.c	/^#define HLL_DENSE /;"	d	language:C	file:
HLL_DENSE_GET_REGISTER	hyperloglog.c	/^#define HLL_DENSE_GET_REGISTER(/;"	d	language:C	file:
HLL_DENSE_SET_REGISTER	hyperloglog.c	/^#define HLL_DENSE_SET_REGISTER(/;"	d	language:C	file:
HLL_DENSE_SIZE	hyperloglog.c	/^#define HLL_DENSE_SIZE /;"	d	language:C	file:
HLL_HDR_SIZE	hyperloglog.c	/^#define HLL_HDR_SIZE /;"	d	language:C	file:
HLL_INVALIDATE_CACHE	hyperloglog.c	/^#define HLL_INVALIDATE_CACHE(/;"	d	language:C	file:
HLL_MAX_ENCODING	hyperloglog.c	/^#define HLL_MAX_ENCODING /;"	d	language:C	file:
HLL_P	hyperloglog.c	/^#define HLL_P /;"	d	language:C	file:
HLL_P_MASK	hyperloglog.c	/^#define HLL_P_MASK /;"	d	language:C	file:
HLL_RAW	hyperloglog.c	/^#define HLL_RAW /;"	d	language:C	file:
HLL_REGISTERS	hyperloglog.c	/^#define HLL_REGISTERS /;"	d	language:C	file:
HLL_REGISTER_MAX	hyperloglog.c	/^#define HLL_REGISTER_MAX /;"	d	language:C	file:
HLL_SPARSE	hyperloglog.c	/^#define HLL_SPARSE /;"	d	language:C	file:
HLL_SPARSE_IS_VAL	hyperloglog.c	/^#define HLL_SPARSE_IS_VAL(/;"	d	language:C	file:
HLL_SPARSE_IS_XZERO	hyperloglog.c	/^#define HLL_SPARSE_IS_XZERO(/;"	d	language:C	file:
HLL_SPARSE_IS_ZERO	hyperloglog.c	/^#define HLL_SPARSE_IS_ZERO(/;"	d	language:C	file:
HLL_SPARSE_VAL_BIT	hyperloglog.c	/^#define HLL_SPARSE_VAL_BIT /;"	d	language:C	file:
HLL_SPARSE_VAL_LEN	hyperloglog.c	/^#define HLL_SPARSE_VAL_LEN(/;"	d	language:C	file:
HLL_SPARSE_VAL_MAX_LEN	hyperloglog.c	/^#define HLL_SPARSE_VAL_MAX_LEN /;"	d	language:C	file:
HLL_SPARSE_VAL_MAX_VALUE	hyperloglog.c	/^#define HLL_SPARSE_VAL_MAX_VALUE /;"	d	language:C	file:
HLL_SPARSE_VAL_SET	hyperloglog.c	/^#define HLL_SPARSE_VAL_SET(/;"	d	language:C	file:
HLL_SPARSE_VAL_VALUE	hyperloglog.c	/^#define HLL_SPARSE_VAL_VALUE(/;"	d	language:C	file:
HLL_SPARSE_XZERO_BIT	hyperloglog.c	/^#define HLL_SPARSE_XZERO_BIT /;"	d	language:C	file:
HLL_SPARSE_XZERO_LEN	hyperloglog.c	/^#define HLL_SPARSE_XZERO_LEN(/;"	d	language:C	file:
HLL_SPARSE_XZERO_MAX_LEN	hyperloglog.c	/^#define HLL_SPARSE_XZERO_MAX_LEN /;"	d	language:C	file:
HLL_SPARSE_XZERO_SET	hyperloglog.c	/^#define HLL_SPARSE_XZERO_SET(/;"	d	language:C	file:
HLL_SPARSE_ZERO_LEN	hyperloglog.c	/^#define HLL_SPARSE_ZERO_LEN(/;"	d	language:C	file:
HLL_SPARSE_ZERO_MAX_LEN	hyperloglog.c	/^#define HLL_SPARSE_ZERO_MAX_LEN /;"	d	language:C	file:
HLL_SPARSE_ZERO_SET	hyperloglog.c	/^#define HLL_SPARSE_ZERO_SET(/;"	d	language:C	file:
HLL_TEST_CYCLES	hyperloglog.c	/^#define HLL_TEST_CYCLES /;"	d	language:C	file:
HLL_VALID_CACHE	hyperloglog.c	/^#define HLL_VALID_CACHE(/;"	d	language:C	file:
HLOG	lzfP.h	/^# define HLOG /;"	d	language:C
HSIZE	lzf_c.c	/^#define HSIZE /;"	d	language:C	file:
HelloHCopy_RedisCommand	modules/helloworld.c	/^int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloLeftPad_RedisCommand	modules/helloworld.c	/^int HelloLeftPad_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloLexRange_RedisCommand	modules/helloworld.c	/^int HelloLexRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloListSpliceAuto_RedisCommand	modules/helloworld.c	/^int HelloListSpliceAuto_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloListSplice_RedisCommand	modules/helloworld.c	/^int HelloListSplice_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloListSumLen_RedisCommand	modules/helloworld.c	/^int HelloListSumLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloMoreExpire_RedisCommand	modules/helloworld.c	/^int HelloMoreExpire_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloPushCall2_RedisCommand	modules/helloworld.c	/^int HelloPushCall2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloPushCall_RedisCommand	modules/helloworld.c	/^int HelloPushCall_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloPushNative_RedisCommand	modules/helloworld.c	/^int HelloPushNative_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloRandArray_RedisCommand	modules/helloworld.c	/^int HelloRandArray_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloRepl1_RedisCommand	modules/helloworld.c	/^int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloRepl2_RedisCommand	modules/helloworld.c	/^int HelloRepl2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloSimple_RedisCommand	modules/helloworld.c	/^int HelloSimple_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloToggleCase_RedisCommand	modules/helloworld.c	/^int HelloToggleCase_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloType	modules/hellotype.c	/^static RedisModuleType *HelloType;$/;"	v	language:C	file:
HelloTypeAofRewrite	modules/hellotype.c	/^void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {$/;"	f	language:C	signature:(RedisModuleIO *aof, RedisModuleString *key, void *value)
HelloTypeDigest	modules/hellotype.c	/^void HelloTypeDigest(RedisModuleDigest *digest, void *value) {$/;"	f	language:C	signature:(RedisModuleDigest *digest, void *value)
HelloTypeFree	modules/hellotype.c	/^void HelloTypeFree(void *value) {$/;"	f	language:C	signature:(void *value)
HelloTypeInsert	modules/hellotype.c	/^void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {$/;"	f	language:C	signature:(struct HelloTypeObject *o, int64_t ele)
HelloTypeInsert_RedisCommand	modules/hellotype.c	/^int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloTypeLen_RedisCommand	modules/hellotype.c	/^int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloTypeNode	modules/hellotype.c	/^struct HelloTypeNode {$/;"	s	language:C	file:
HelloTypeNode::next	modules/hellotype.c	/^    struct HelloTypeNode *next;$/;"	m	language:C	struct:HelloTypeNode	typeref:struct:HelloTypeNode::HelloTypeNode	file:	access:public
HelloTypeNode::value	modules/hellotype.c	/^    int64_t value;$/;"	m	language:C	struct:HelloTypeNode	file:	access:public
HelloTypeObject	modules/hellotype.c	/^struct HelloTypeObject {$/;"	s	language:C	file:
HelloTypeObject::head	modules/hellotype.c	/^    struct HelloTypeNode *head;$/;"	m	language:C	struct:HelloTypeObject	typeref:struct:HelloTypeObject::HelloTypeNode	file:	access:public
HelloTypeObject::len	modules/hellotype.c	/^    size_t len; \/* Number of elements added. *\/$/;"	m	language:C	struct:HelloTypeObject	file:	access:public
HelloTypeRange_RedisCommand	modules/hellotype.c	/^int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloTypeRdbLoad	modules/hellotype.c	/^void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {$/;"	f	language:C	signature:(RedisModuleIO *rdb, int encver)
HelloTypeRdbSave	modules/hellotype.c	/^void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {$/;"	f	language:C	signature:(RedisModuleIO *rdb, void *value)
HelloTypeReleaseObject	modules/hellotype.c	/^void HelloTypeReleaseObject(struct HelloTypeObject *o) {$/;"	f	language:C	signature:(struct HelloTypeObject *o)
HelloZsumRange_RedisCommand	modules/helloworld.c	/^int HelloZsumRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
HelloworldRand_RedisCommand	modules/INTRO.md	/^    int HelloworldRand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
ID	modules/API.md	/^   having the same ID, otherwise the ID will be different.$/;"	v	language:C
IDX	lzf_c.c	/^#  define IDX(/;"	d	language:C	file:
INIT_HTAB	lzfP.h	/^# define INIT_HTAB /;"	d	language:C
INIT_SETPROCTITLE_REPLACEMENT	config.h	/^#define INIT_SETPROCTITLE_REPLACEMENT$/;"	d	language:C
INT24_MAX	ziplist.c	/^#define INT24_MAX /;"	d	language:C	file:
INT24_MIN	ziplist.c	/^#define INT24_MIN /;"	d	language:C	file:
INTSET_ENC_INT16	intset.c	/^#define INTSET_ENC_INT16 /;"	d	language:C	file:
INTSET_ENC_INT32	intset.c	/^#define INTSET_ENC_INT32 /;"	d	language:C	file:
INTSET_ENC_INT64	intset.c	/^#define INTSET_ENC_INT64 /;"	d	language:C	file:
LATENCY_DIST_DEFAULT_INTERVAL	redis-cli.c	/^#define LATENCY_DIST_DEFAULT_INTERVAL /;"	d	language:C	file:
LATENCY_GRAPH_COLS	latency.c	/^#define LATENCY_GRAPH_COLS /;"	d	language:C	file:
LATENCY_HISTORY_DEFAULT_INTERVAL	redis-cli.c	/^#define LATENCY_HISTORY_DEFAULT_INTERVAL /;"	d	language:C	file:
LATENCY_SAMPLE_RATE	redis-cli.c	/^#define LATENCY_SAMPLE_RATE /;"	d	language:C	file:
LATENCY_TS_LEN	latency.h	/^#define LATENCY_TS_LEN /;"	d	language:C
LAZYFREE_THRESHOLD	lazyfree.c	/^#define LAZYFREE_THRESHOLD /;"	d	language:C	file:
LDB_BREAKPOINTS_MAX	scripting.c	/^#define LDB_BREAKPOINTS_MAX /;"	d	language:C	file:
LDB_MAX_LEN_DEFAULT	scripting.c	/^#define LDB_MAX_LEN_DEFAULT /;"	d	language:C	file:
LDB_MAX_VALUES_DEPTH	scripting.c	/^#define LDB_MAX_VALUES_DEPTH /;"	d	language:C	file:
LFUDecrAndReturn	evict.c	/^unsigned long LFUDecrAndReturn(robj *o) {$/;"	f	language:C	signature:(robj *o)
LFUDecrAndReturn	evict.c	/^unsigned long LFUDecrAndReturn(robj *o);$/;"	p	language:C	file:	signature:(robj *o)
LFUGetTimeInMinutes	evict.c	/^unsigned long LFUGetTimeInMinutes(void) {$/;"	f	language:C	signature:(void)
LFUGetTimeInMinutes	server.h	/^unsigned long LFUGetTimeInMinutes(void);$/;"	p	language:C	signature:(void)
LFULogIncr	evict.c	/^uint8_t LFULogIncr(uint8_t counter) {$/;"	f	language:C	signature:(uint8_t counter)
LFULogIncr	server.h	/^uint8_t LFULogIncr(uint8_t value);$/;"	p	language:C	signature:(uint8_t value)
LFUTimeElapsed	evict.c	/^unsigned long LFUTimeElapsed(unsigned long ldt) {$/;"	f	language:C	signature:(unsigned long ldt)
LFU_DECR_INTERVAL	evict.c	/^#define LFU_DECR_INTERVAL /;"	d	language:C	file:
LFU_INIT_VAL	server.h	/^#define LFU_INIT_VAL /;"	d	language:C
LIST_HEAD	server.h	/^#define LIST_HEAD /;"	d	language:C
LIST_TAIL	server.h	/^#define LIST_TAIL /;"	d	language:C
LITTLE_ENDIAN	config.h	/^#define	LITTLE_ENDIAN	/;"	d	language:C
LITTLE_ENDIAN	config.h	/^#define LITTLE_ENDIAN /;"	d	language:C
LL_DEBUG	server.h	/^#define LL_DEBUG /;"	d	language:C
LL_NOTICE	server.h	/^#define LL_NOTICE /;"	d	language:C
LL_RAW	server.h	/^#define LL_RAW /;"	d	language:C
LL_VERBOSE	server.h	/^#define LL_VERBOSE /;"	d	language:C
LL_WARNING	server.h	/^#define LL_WARNING /;"	d	language:C
LOG_MAX_LEN	server.h	/^#define LOG_MAX_LEN /;"	d	language:C
LONG_STR_SIZE	server.h	/^#define LONG_STR_SIZE /;"	d	language:C
LOOKUP_NONE	server.h	/^#define LOOKUP_NONE /;"	d	language:C
LOOKUP_NOTOUCH	server.h	/^#define LOOKUP_NOTOUCH /;"	d	language:C
LOW	rand.c	/^#define LOW(/;"	d	language:C	file:
LRUTestGenKey	redis-cli.c	/^void LRUTestGenKey(char *buf, size_t buflen) {$/;"	f	language:C	signature:(char *buf, size_t buflen)
LRUTestMode	redis-cli.c	/^static void LRUTestMode(void) {$/;"	f	language:C	file:	signature:(void)
LRU_BITS	server.h	/^#define LRU_BITS /;"	d	language:C
LRU_CLOCK	server.h	/^#define LRU_CLOCK(/;"	d	language:C
LRU_CLOCK_MAX	server.h	/^#define LRU_CLOCK_MAX /;"	d	language:C
LRU_CLOCK_RESOLUTION	server.h	/^#define LRU_CLOCK_RESOLUTION /;"	d	language:C
LRU_CYCLE_PERIOD	redis-cli.c	/^#define LRU_CYCLE_PERIOD /;"	d	language:C	file:
LRU_CYCLE_PIPELINE_SIZE	redis-cli.c	/^#define LRU_CYCLE_PIPELINE_SIZE /;"	d	language:C	file:
LUA_CMD_OBJCACHE_MAX_LEN	scripting.c	/^#define LUA_CMD_OBJCACHE_MAX_LEN /;"	d	language:C	file:
LUA_CMD_OBJCACHE_SIZE	scripting.c	/^#define LUA_CMD_OBJCACHE_SIZE /;"	d	language:C	file:
LUA_GC_CYCLE_PERIOD	scripting.c	/^    #define LUA_GC_CYCLE_PERIOD /;"	d	language:C	file:
LUA_SCRIPT_TIME_LIMIT	server.h	/^#define LUA_SCRIPT_TIME_LIMIT /;"	d	language:C
LZFP_h	lzfP.h	/^#define LZFP_h$/;"	d	language:C
LZF_H	lzf.h	/^#define LZF_H$/;"	d	language:C
LZF_HSLOT	lzfP.h	/^  typedef const u8 *LZF_HSLOT;$/;"	t	language:C
LZF_HSLOT	lzfP.h	/^  typedef unsigned int LZF_HSLOT;$/;"	t	language:C
LZF_HSLOT_BIAS	lzfP.h	/^# define LZF_HSLOT_BIAS /;"	d	language:C
LZF_STATE	lzfP.h	/^typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];$/;"	t	language:C
LZF_STATE_ARG	lzfP.h	/^# define LZF_STATE_ARG /;"	d	language:C
LZF_USE_OFFSETS	lzfP.h	/^#  define LZF_USE_OFFSETS /;"	d	language:C
LZF_VERSION	lzf.h	/^#define LZF_VERSION /;"	d	language:C
MASK	rand.c	/^#define MASK	/;"	d	language:C	file:
MAXMEMORY_ALLKEYS_LFU	server.h	/^#define MAXMEMORY_ALLKEYS_LFU /;"	d	language:C
MAXMEMORY_ALLKEYS_LRU	server.h	/^#define MAXMEMORY_ALLKEYS_LRU /;"	d	language:C
MAXMEMORY_ALLKEYS_RANDOM	server.h	/^#define MAXMEMORY_ALLKEYS_RANDOM /;"	d	language:C
MAXMEMORY_FLAG_ALLKEYS	server.h	/^#define MAXMEMORY_FLAG_ALLKEYS /;"	d	language:C
MAXMEMORY_FLAG_LFU	server.h	/^#define MAXMEMORY_FLAG_LFU /;"	d	language:C
MAXMEMORY_FLAG_LRU	server.h	/^#define MAXMEMORY_FLAG_LRU /;"	d	language:C
MAXMEMORY_FLAG_NO_SHARED_INTEGERS	server.h	/^#define MAXMEMORY_FLAG_NO_SHARED_INTEGERS /;"	d	language:C
MAXMEMORY_NO_EVICTION	server.h	/^#define MAXMEMORY_NO_EVICTION /;"	d	language:C
MAXMEMORY_VOLATILE_LFU	server.h	/^#define MAXMEMORY_VOLATILE_LFU /;"	d	language:C
MAXMEMORY_VOLATILE_LRU	server.h	/^#define MAXMEMORY_VOLATILE_LRU /;"	d	language:C
MAXMEMORY_VOLATILE_RANDOM	server.h	/^#define MAXMEMORY_VOLATILE_RANDOM /;"	d	language:C
MAXMEMORY_VOLATILE_TTL	server.h	/^#define MAXMEMORY_VOLATILE_TTL /;"	d	language:C
MAX_ACCEPTS_PER_CALL	networking.c	/^#define MAX_ACCEPTS_PER_CALL /;"	d	language:C	file:
MAX_CLUSTER_ACCEPTS_PER_CALL	cluster.c	/^#define MAX_CLUSTER_ACCEPTS_PER_CALL /;"	d	language:C	file:
MAX_EVENT_BATCHSZ	ae_evport.c	/^#define MAX_EVENT_BATCHSZ /;"	d	language:C	file:
MAX_LIT	lzf_c.c	/^#define        MAX_LIT /;"	d	language:C	file:
MAX_OFF	lzf_c.c	/^#define        MAX_OFF /;"	d	language:C	file:
MAX_REF	lzf_c.c	/^#define        MAX_REF /;"	d	language:C	file:
MEMTEST_32BIT	memtest.c	/^#define MEMTEST_32BIT$/;"	d	language:C	file:
MEMTEST_64BIT	memtest.c	/^#define MEMTEST_64BIT$/;"	d	language:C	file:
MEMTEST_BACKUP_WORDS	memtest.c	/^#define MEMTEST_BACKUP_WORDS /;"	d	language:C	file:
MEMTEST_DECACHE_SIZE	memtest.c	/^#define MEMTEST_DECACHE_SIZE /;"	d	language:C	file:
MEMTEST_MAX_REGIONS	debug.c	/^#define MEMTEST_MAX_REGIONS /;"	d	language:C	file:
MERCATOR_MAX	geohash_helper.c	/^const double MERCATOR_MAX = 20037726.37;$/;"	v	language:C
MERCATOR_MIN	geohash_helper.c	/^const double MERCATOR_MIN = -20037726.37;$/;"	v	language:C
MIGRATE_SOCKET_CACHE_ITEMS	cluster.c	/^#define MIGRATE_SOCKET_CACHE_ITEMS /;"	d	language:C	file:
MIGRATE_SOCKET_CACHE_TTL	cluster.c	/^#define MIGRATE_SOCKET_CACHE_TTL /;"	d	language:C	file:
MIN_COMPRESS_BYTES	quicklist.c	/^#define MIN_COMPRESS_BYTES /;"	d	language:C	file:
MIN_COMPRESS_IMPROVE	quicklist.c	/^#define MIN_COMPRESS_IMPROVE /;"	d	language:C	file:
MODULE_LOOKUP_CACHE_SIZE	module.c	/^#define MODULE_LOOKUP_CACHE_SIZE /;"	d	language:C	file:
MUL	rand.c	/^#define MUL(/;"	d	language:C	file:
MYTYPE_ENCODING_VERSION	modules/TYPES.md	/^    #define MYTYPE_ENCODING_VERSION /;"	d	language:C	file:
ModuleTypeNameCharSet	module.c	/^const char *ModuleTypeNameCharSet =$/;"	v	language:C
MurmurHash64A	hyperloglog.c	/^uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {$/;"	f	language:C	signature:(const void * key, int len, unsigned int seed)
MyCommand_RedisCommand	modules/API.md	/^     int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
MyTypeFreeCallback	modules/TYPES.md	/^    void MyTypeFreeCallback(void *value) {$/;"	f	language:C	signature:(void *value)
N	rand.c	/^#define N	/;"	d	language:C	file:
NET_FIRST_BIND_ADDR	server.h	/^#define NET_FIRST_BIND_ADDR /;"	d	language:C
NET_IP_STR_LEN	server.h	/^#define NET_IP_STR_LEN /;"	d	language:C
NET_MAX_WRITES_PER_EVENT	server.h	/^#define NET_MAX_WRITES_PER_EVENT /;"	d	language:C
NET_PEER_ID_LEN	server.h	/^#define NET_PEER_ID_LEN /;"	d	language:C
NEXT	lzf_c.c	/^# define NEXT(/;"	d	language:C	file:
NOTIFY_ALL	server.h	/^#define NOTIFY_ALL /;"	d	language:C
NOTIFY_EVICTED	server.h	/^#define NOTIFY_EVICTED /;"	d	language:C
NOTIFY_EXPIRED	server.h	/^#define NOTIFY_EXPIRED /;"	d	language:C
NOTIFY_GENERIC	server.h	/^#define NOTIFY_GENERIC /;"	d	language:C
NOTIFY_HASH	server.h	/^#define NOTIFY_HASH /;"	d	language:C
NOTIFY_KEYEVENT	server.h	/^#define NOTIFY_KEYEVENT /;"	d	language:C
NOTIFY_KEYSPACE	server.h	/^#define NOTIFY_KEYSPACE /;"	d	language:C
NOTIFY_LIST	server.h	/^#define NOTIFY_LIST /;"	d	language:C
NOTIFY_SET	server.h	/^#define NOTIFY_SET /;"	d	language:C
NOTIFY_STRING	server.h	/^#define NOTIFY_STRING /;"	d	language:C
NOTIFY_ZSET	server.h	/^#define NOTIFY_ZSET /;"	d	language:C
NULL	modules/API.md	/^If the key is NULL, is not associated with a module type, or is empty,$/;"	v	language:C
OBJ_ENCODING_EMBSTR	server.h	/^#define OBJ_ENCODING_EMBSTR /;"	d	language:C
OBJ_ENCODING_EMBSTR_SIZE_LIMIT	object.c	/^#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT /;"	d	language:C	file:
OBJ_ENCODING_HT	server.h	/^#define OBJ_ENCODING_HT /;"	d	language:C
OBJ_ENCODING_INT	server.h	/^#define OBJ_ENCODING_INT /;"	d	language:C
OBJ_ENCODING_INTSET	server.h	/^#define OBJ_ENCODING_INTSET /;"	d	language:C
OBJ_ENCODING_LINKEDLIST	server.h	/^#define OBJ_ENCODING_LINKEDLIST /;"	d	language:C
OBJ_ENCODING_QUICKLIST	server.h	/^#define OBJ_ENCODING_QUICKLIST /;"	d	language:C
OBJ_ENCODING_RAW	server.h	/^#define OBJ_ENCODING_RAW /;"	d	language:C
OBJ_ENCODING_SKIPLIST	server.h	/^#define OBJ_ENCODING_SKIPLIST /;"	d	language:C
OBJ_ENCODING_ZIPLIST	server.h	/^#define OBJ_ENCODING_ZIPLIST /;"	d	language:C
OBJ_ENCODING_ZIPMAP	server.h	/^#define OBJ_ENCODING_ZIPMAP /;"	d	language:C
OBJ_HASH	server.h	/^#define OBJ_HASH /;"	d	language:C
OBJ_HASH_KEY	server.h	/^#define OBJ_HASH_KEY /;"	d	language:C
OBJ_HASH_MAX_ZIPLIST_ENTRIES	server.h	/^#define OBJ_HASH_MAX_ZIPLIST_ENTRIES /;"	d	language:C
OBJ_HASH_MAX_ZIPLIST_VALUE	server.h	/^#define OBJ_HASH_MAX_ZIPLIST_VALUE /;"	d	language:C
OBJ_HASH_VALUE	server.h	/^#define OBJ_HASH_VALUE /;"	d	language:C
OBJ_LIST	server.h	/^#define OBJ_LIST /;"	d	language:C
OBJ_LIST_COMPRESS_DEPTH	server.h	/^#define OBJ_LIST_COMPRESS_DEPTH /;"	d	language:C
OBJ_LIST_MAX_ZIPLIST_SIZE	server.h	/^#define OBJ_LIST_MAX_ZIPLIST_SIZE /;"	d	language:C
OBJ_MODULE	server.h	/^#define OBJ_MODULE /;"	d	language:C
OBJ_SET	server.h	/^#define OBJ_SET /;"	d	language:C
OBJ_SET_EX	t_string.c	/^#define OBJ_SET_EX /;"	d	language:C	file:
OBJ_SET_MAX_INTSET_ENTRIES	server.h	/^#define OBJ_SET_MAX_INTSET_ENTRIES /;"	d	language:C
OBJ_SET_NO_FLAGS	t_string.c	/^#define OBJ_SET_NO_FLAGS /;"	d	language:C	file:
OBJ_SET_NX	t_string.c	/^#define OBJ_SET_NX /;"	d	language:C	file:
OBJ_SET_PX	t_string.c	/^#define OBJ_SET_PX /;"	d	language:C	file:
OBJ_SET_XX	t_string.c	/^#define OBJ_SET_XX /;"	d	language:C	file:
OBJ_SHARED_BULKHDR_LEN	server.h	/^#define OBJ_SHARED_BULKHDR_LEN /;"	d	language:C
OBJ_SHARED_INTEGERS	server.h	/^#define OBJ_SHARED_INTEGERS /;"	d	language:C
OBJ_SHARED_REFCOUNT	server.h	/^#define OBJ_SHARED_REFCOUNT /;"	d	language:C
OBJ_STRING	server.h	/^#define OBJ_STRING /;"	d	language:C
OBJ_ZSET	server.h	/^#define OBJ_ZSET /;"	d	language:C
OBJ_ZSET_MAX_ZIPLIST_ENTRIES	server.h	/^#define OBJ_ZSET_MAX_ZIPLIST_ENTRIES /;"	d	language:C
OBJ_ZSET_MAX_ZIPLIST_VALUE	server.h	/^#define OBJ_ZSET_MAX_ZIPLIST_VALUE /;"	d	language:C
OK	quicklist.c	/^#define OK /;"	d	language:C	file:
OPVAL_DIRTY_LL	t_zset.c	/^#define OPVAL_DIRTY_LL /;"	d	language:C	file:
OPVAL_DIRTY_SDS	t_zset.c	/^#define OPVAL_DIRTY_SDS /;"	d	language:C	file:
OPVAL_VALID_LL	t_zset.c	/^#define OPVAL_VALID_LL /;"	d	language:C	file:
OUTPUT_CSV	redis-cli.c	/^#define OUTPUT_CSV /;"	d	language:C	file:
OUTPUT_RAW	redis-cli.c	/^#define OUTPUT_RAW /;"	d	language:C	file:
OUTPUT_STANDARD	redis-cli.c	/^#define OUTPUT_STANDARD /;"	d	language:C	file:
PDP_ENDIAN	config.h	/^#define	PDP_ENDIAN	/;"	d	language:C
PE	hyperloglog.c	/^    static double PE[64];$/;"	l	language:C	file:
PIPEMODE_WRITE_LOOP_MAX_BYTES	redis-cli.c	/^#define PIPEMODE_WRITE_LOOP_MAX_BYTES /;"	d	language:C	file:
PREFIX_SIZE	zmalloc.c	/^#define PREFIX_SIZE /;"	d	language:C	file:
PROPAGATE_AOF	server.h	/^#define PROPAGATE_AOF /;"	d	language:C
PROPAGATE_NONE	server.h	/^#define PROPAGATE_NONE /;"	d	language:C
PROPAGATE_REPL	server.h	/^#define PROPAGATE_REPL /;"	d	language:C
PROTO_INLINE_MAX_SIZE	server.h	/^#define PROTO_INLINE_MAX_SIZE /;"	d	language:C
PROTO_IOBUF_LEN	server.h	/^#define PROTO_IOBUF_LEN /;"	d	language:C
PROTO_MAX_QUERYBUF_LEN	server.h	/^#define PROTO_MAX_QUERYBUF_LEN /;"	d	language:C
PROTO_MBULK_BIG_ARG	server.h	/^#define PROTO_MBULK_BIG_ARG /;"	d	language:C
PROTO_REPLY_CHUNK_BYTES	server.h	/^#define PROTO_REPLY_CHUNK_BYTES /;"	d	language:C
PROTO_REQ_INLINE	server.h	/^#define PROTO_REQ_INLINE /;"	d	language:C
PROTO_REQ_MULTIBULK	server.h	/^#define PROTO_REQ_MULTIBULK /;"	d	language:C
PROTO_SHARED_SELECT_CMDS	server.h	/^#define PROTO_SHARED_SELECT_CMDS /;"	d	language:C
PSYNC_CONTINUE	replication.c	/^#define PSYNC_CONTINUE /;"	d	language:C	file:
PSYNC_FULLRESYNC	replication.c	/^#define PSYNC_FULLRESYNC /;"	d	language:C	file:
PSYNC_NOT_SUPPORTED	replication.c	/^#define PSYNC_NOT_SUPPORTED /;"	d	language:C	file:
PSYNC_WAIT_REPLY	replication.c	/^#define PSYNC_WAIT_REPLY /;"	d	language:C	file:
PSYNC_WRITE_ERROR	replication.c	/^#define PSYNC_WRITE_ERROR /;"	d	language:C	file:
QL_TEST_VERBOSE	quicklist.c	/^#define QL_TEST_VERBOSE /;"	d	language:C	file:
QUICKLIST_HEAD	quicklist.h	/^#define QUICKLIST_HEAD /;"	d	language:C
QUICKLIST_NOCOMPRESS	quicklist.h	/^#define QUICKLIST_NOCOMPRESS /;"	d	language:C
QUICKLIST_NODE_CONTAINER_NONE	quicklist.h	/^#define QUICKLIST_NODE_CONTAINER_NONE /;"	d	language:C
QUICKLIST_NODE_CONTAINER_ZIPLIST	quicklist.h	/^#define QUICKLIST_NODE_CONTAINER_ZIPLIST /;"	d	language:C
QUICKLIST_NODE_ENCODING_LZF	quicklist.h	/^#define QUICKLIST_NODE_ENCODING_LZF /;"	d	language:C
QUICKLIST_NODE_ENCODING_RAW	quicklist.h	/^#define QUICKLIST_NODE_ENCODING_RAW /;"	d	language:C
QUICKLIST_TAIL	quicklist.h	/^#define QUICKLIST_TAIL /;"	d	language:C
R0	sha1.c	/^#define R0(/;"	d	language:C	file:
R1	sha1.c	/^#define R1(/;"	d	language:C	file:
R2	sha1.c	/^#define R2(/;"	d	language:C	file:
R3	sha1.c	/^#define R3(/;"	d	language:C	file:
R4	sha1.c	/^#define R4(/;"	d	language:C	file:
RADIUS_COORDS	geo.c	/^#define RADIUS_COORDS /;"	d	language:C	file:
RADIUS_MEMBER	geo.c	/^#define RADIUS_MEMBER /;"	d	language:C	file:
RANDPTR_INITIAL_SIZE	redis-benchmark.c	/^#define RANDPTR_INITIAL_SIZE /;"	d	language:C	file:
RANGEISZERO	geohash.h	/^#define RANGEISZERO(/;"	d	language:C
RANGEPISZERO	geohash.h	/^#define RANGEPISZERO(/;"	d	language:C
RATIO	geohash_helper.c	/^#define RATIO /;"	d	language:C	file:
RDB_14BITLEN	rdb.h	/^#define RDB_14BITLEN /;"	d	language:C
RDB_32BITLEN	rdb.h	/^#define RDB_32BITLEN /;"	d	language:C
RDB_64BITLEN	rdb.h	/^#define RDB_64BITLEN /;"	d	language:C
RDB_6BITLEN	rdb.h	/^#define RDB_6BITLEN /;"	d	language:C
RDB_CHECK_DOING_CHECK_SUM	redis-check-rdb.c	/^#define RDB_CHECK_DOING_CHECK_SUM /;"	d	language:C	file:
RDB_CHECK_DOING_READ_AUX	redis-check-rdb.c	/^#define RDB_CHECK_DOING_READ_AUX /;"	d	language:C	file:
RDB_CHECK_DOING_READ_EXPIRE	redis-check-rdb.c	/^#define RDB_CHECK_DOING_READ_EXPIRE /;"	d	language:C	file:
RDB_CHECK_DOING_READ_KEY	redis-check-rdb.c	/^#define RDB_CHECK_DOING_READ_KEY /;"	d	language:C	file:
RDB_CHECK_DOING_READ_LEN	redis-check-rdb.c	/^#define RDB_CHECK_DOING_READ_LEN /;"	d	language:C	file:
RDB_CHECK_DOING_READ_OBJECT_VALUE	redis-check-rdb.c	/^#define RDB_CHECK_DOING_READ_OBJECT_VALUE /;"	d	language:C	file:
RDB_CHECK_DOING_READ_TYPE	redis-check-rdb.c	/^#define RDB_CHECK_DOING_READ_TYPE /;"	d	language:C	file:
RDB_CHECK_DOING_START	redis-check-rdb.c	/^#define RDB_CHECK_DOING_START /;"	d	language:C	file:
RDB_CHILD_TYPE_DISK	server.h	/^#define RDB_CHILD_TYPE_DISK /;"	d	language:C
RDB_CHILD_TYPE_NONE	server.h	/^#define RDB_CHILD_TYPE_NONE /;"	d	language:C
RDB_CHILD_TYPE_SOCKET	server.h	/^#define RDB_CHILD_TYPE_SOCKET /;"	d	language:C
RDB_ENCVAL	rdb.h	/^#define RDB_ENCVAL /;"	d	language:C
RDB_ENC_INT16	rdb.h	/^#define RDB_ENC_INT16 /;"	d	language:C
RDB_ENC_INT32	rdb.h	/^#define RDB_ENC_INT32 /;"	d	language:C
RDB_ENC_INT8	rdb.h	/^#define RDB_ENC_INT8 /;"	d	language:C
RDB_ENC_LZF	rdb.h	/^#define RDB_ENC_LZF /;"	d	language:C
RDB_EOF_MARK_SIZE	server.h	/^#define RDB_EOF_MARK_SIZE /;"	d	language:C
RDB_LENERR	rdb.h	/^#define RDB_LENERR /;"	d	language:C
RDB_LOAD_ENC	rdb.h	/^#define RDB_LOAD_ENC /;"	d	language:C
RDB_LOAD_NONE	rdb.h	/^#define RDB_LOAD_NONE /;"	d	language:C
RDB_LOAD_PLAIN	rdb.h	/^#define RDB_LOAD_PLAIN /;"	d	language:C
RDB_LOAD_SDS	rdb.h	/^#define RDB_LOAD_SDS /;"	d	language:C
RDB_OPCODE_AUX	rdb.h	/^#define RDB_OPCODE_AUX /;"	d	language:C
RDB_OPCODE_EOF	rdb.h	/^#define RDB_OPCODE_EOF /;"	d	language:C
RDB_OPCODE_EXPIRETIME	rdb.h	/^#define RDB_OPCODE_EXPIRETIME /;"	d	language:C
RDB_OPCODE_EXPIRETIME_MS	rdb.h	/^#define RDB_OPCODE_EXPIRETIME_MS /;"	d	language:C
RDB_OPCODE_RESIZEDB	rdb.h	/^#define RDB_OPCODE_RESIZEDB /;"	d	language:C
RDB_OPCODE_SELECTDB	rdb.h	/^#define RDB_OPCODE_SELECTDB /;"	d	language:C
RDB_TYPE_HASH	rdb.h	/^#define RDB_TYPE_HASH /;"	d	language:C
RDB_TYPE_HASH_ZIPLIST	rdb.h	/^#define RDB_TYPE_HASH_ZIPLIST /;"	d	language:C
RDB_TYPE_HASH_ZIPMAP	rdb.h	/^#define RDB_TYPE_HASH_ZIPMAP /;"	d	language:C
RDB_TYPE_LIST	rdb.h	/^#define RDB_TYPE_LIST /;"	d	language:C
RDB_TYPE_LIST_QUICKLIST	rdb.h	/^#define RDB_TYPE_LIST_QUICKLIST /;"	d	language:C
RDB_TYPE_LIST_ZIPLIST	rdb.h	/^#define RDB_TYPE_LIST_ZIPLIST /;"	d	language:C
RDB_TYPE_MODULE	rdb.h	/^#define RDB_TYPE_MODULE /;"	d	language:C
RDB_TYPE_SET	rdb.h	/^#define RDB_TYPE_SET /;"	d	language:C
RDB_TYPE_SET_INTSET	rdb.h	/^#define RDB_TYPE_SET_INTSET /;"	d	language:C
RDB_TYPE_STRING	rdb.h	/^#define RDB_TYPE_STRING /;"	d	language:C
RDB_TYPE_ZSET	rdb.h	/^#define RDB_TYPE_ZSET /;"	d	language:C
RDB_TYPE_ZSET_2	rdb.h	/^#define RDB_TYPE_ZSET_2 /;"	d	language:C
RDB_TYPE_ZSET_ZIPLIST	rdb.h	/^#define RDB_TYPE_ZSET_ZIPLIST /;"	d	language:C
RDB_VERSION	rdb.h	/^#define RDB_VERSION /;"	d	language:C
REDISMODULE_AM_FREED	module.c	/^#define REDISMODULE_AM_FREED /;"	d	language:C	file:
REDISMODULE_AM_KEY	module.c	/^#define REDISMODULE_AM_KEY /;"	d	language:C	file:
REDISMODULE_AM_REPLY	module.c	/^#define REDISMODULE_AM_REPLY /;"	d	language:C	file:
REDISMODULE_AM_STRING	module.c	/^#define REDISMODULE_AM_STRING /;"	d	language:C	file:
REDISMODULE_APIVER_1	redismodule.h	/^#define REDISMODULE_APIVER_1 /;"	d	language:C
REDISMODULE_API_FUNC	redismodule.h	/^#define REDISMODULE_API_FUNC(/;"	d	language:C
REDISMODULE_ARGV_REPLICATE	module.c	/^#define REDISMODULE_ARGV_REPLICATE /;"	d	language:C	file:
REDISMODULE_CORE	module.c	/^#define REDISMODULE_CORE /;"	d	language:C	file:
REDISMODULE_CTX_AUTO_MEMORY	module.c	/^#define REDISMODULE_CTX_AUTO_MEMORY /;"	d	language:C	file:
REDISMODULE_CTX_INIT	module.c	/^#define REDISMODULE_CTX_INIT /;"	d	language:C	file:
REDISMODULE_CTX_KEYS_POS_REQUEST	module.c	/^#define REDISMODULE_CTX_KEYS_POS_REQUEST /;"	d	language:C	file:
REDISMODULE_CTX_MULTI_EMITTED	module.c	/^#define REDISMODULE_CTX_MULTI_EMITTED /;"	d	language:C	file:
REDISMODULE_ERR	redismodule.h	/^#define REDISMODULE_ERR /;"	d	language:C
REDISMODULE_ERRORMSG_WRONGTYPE	redismodule.h	/^#define REDISMODULE_ERRORMSG_WRONGTYPE /;"	d	language:C
REDISMODULE_GET_API	redismodule.h	/^#define REDISMODULE_GET_API(/;"	d	language:C
REDISMODULE_H	redismodule.h	/^#define REDISMODULE_H$/;"	d	language:C
REDISMODULE_HASH_CFIELDS	redismodule.h	/^#define REDISMODULE_HASH_CFIELDS /;"	d	language:C
REDISMODULE_HASH_DELETE	redismodule.h	/^#define REDISMODULE_HASH_DELETE /;"	d	language:C
REDISMODULE_HASH_EXISTS	redismodule.h	/^#define REDISMODULE_HASH_EXISTS /;"	d	language:C
REDISMODULE_HASH_NONE	redismodule.h	/^#define REDISMODULE_HASH_NONE /;"	d	language:C
REDISMODULE_HASH_NX	redismodule.h	/^#define REDISMODULE_HASH_NX /;"	d	language:C
REDISMODULE_HASH_XX	redismodule.h	/^#define REDISMODULE_HASH_XX /;"	d	language:C
REDISMODULE_KEYTYPE_EMPTY	redismodule.h	/^#define REDISMODULE_KEYTYPE_EMPTY /;"	d	language:C
REDISMODULE_KEYTYPE_HASH	redismodule.h	/^#define REDISMODULE_KEYTYPE_HASH /;"	d	language:C
REDISMODULE_KEYTYPE_LIST	redismodule.h	/^#define REDISMODULE_KEYTYPE_LIST /;"	d	language:C
REDISMODULE_KEYTYPE_MODULE	redismodule.h	/^#define REDISMODULE_KEYTYPE_MODULE /;"	d	language:C
REDISMODULE_KEYTYPE_SET	redismodule.h	/^#define REDISMODULE_KEYTYPE_SET /;"	d	language:C
REDISMODULE_KEYTYPE_STRING	redismodule.h	/^#define REDISMODULE_KEYTYPE_STRING /;"	d	language:C
REDISMODULE_KEYTYPE_ZSET	redismodule.h	/^#define REDISMODULE_KEYTYPE_ZSET /;"	d	language:C
REDISMODULE_LIST_HEAD	redismodule.h	/^#define REDISMODULE_LIST_HEAD /;"	d	language:C
REDISMODULE_LIST_TAIL	redismodule.h	/^#define REDISMODULE_LIST_TAIL /;"	d	language:C
REDISMODULE_NEGATIVE_INFINITE	redismodule.h	/^#define REDISMODULE_NEGATIVE_INFINITE /;"	d	language:C
REDISMODULE_NO_EXPIRE	redismodule.h	/^#define REDISMODULE_NO_EXPIRE /;"	d	language:C
REDISMODULE_OK	redismodule.h	/^#define REDISMODULE_OK /;"	d	language:C
REDISMODULE_POOL_ALLOC_ALIGN	module.c	/^#define REDISMODULE_POOL_ALLOC_ALIGN /;"	d	language:C	file:
REDISMODULE_POOL_ALLOC_MIN_SIZE	module.c	/^#define REDISMODULE_POOL_ALLOC_MIN_SIZE /;"	d	language:C	file:
REDISMODULE_POSITIVE_INFINITE	redismodule.h	/^#define REDISMODULE_POSITIVE_INFINITE /;"	d	language:C
REDISMODULE_POSTPONED_ARRAY_LEN	modules/API.md	/^`REDISMODULE_POSTPONED_ARRAY_LEN`, because we don't know beforehand the number$/;"	v	language:C
REDISMODULE_POSTPONED_ARRAY_LEN	redismodule.h	/^#define REDISMODULE_POSTPONED_ARRAY_LEN /;"	d	language:C
REDISMODULE_READ	redismodule.h	/^#define REDISMODULE_READ /;"	d	language:C
REDISMODULE_REPLYFLAG_NESTED	module.c	/^#define REDISMODULE_REPLYFLAG_NESTED /;"	d	language:C	file:
REDISMODULE_REPLYFLAG_NONE	module.c	/^#define REDISMODULE_REPLYFLAG_NONE /;"	d	language:C	file:
REDISMODULE_REPLYFLAG_TOPARSE	module.c	/^#define REDISMODULE_REPLYFLAG_TOPARSE /;"	d	language:C	file:
REDISMODULE_REPLY_ARRAY	redismodule.h	/^#define REDISMODULE_REPLY_ARRAY /;"	d	language:C
REDISMODULE_REPLY_ERROR	redismodule.h	/^#define REDISMODULE_REPLY_ERROR /;"	d	language:C
REDISMODULE_REPLY_INTEGER	redismodule.h	/^#define REDISMODULE_REPLY_INTEGER /;"	d	language:C
REDISMODULE_REPLY_NULL	redismodule.h	/^#define REDISMODULE_REPLY_NULL /;"	d	language:C
REDISMODULE_REPLY_STRING	redismodule.h	/^#define REDISMODULE_REPLY_STRING /;"	d	language:C
REDISMODULE_REPLY_UNKNOWN	redismodule.h	/^#define REDISMODULE_REPLY_UNKNOWN /;"	d	language:C
REDISMODULE_TYPE_ENCVER	server.h	/^#define REDISMODULE_TYPE_ENCVER(/;"	d	language:C
REDISMODULE_TYPE_ENCVER_BITS	server.h	/^#define REDISMODULE_TYPE_ENCVER_BITS /;"	d	language:C
REDISMODULE_TYPE_ENCVER_MASK	server.h	/^#define REDISMODULE_TYPE_ENCVER_MASK /;"	d	language:C
REDISMODULE_TYPE_SIGN	server.h	/^#define REDISMODULE_TYPE_SIGN(/;"	d	language:C
REDISMODULE_WRITE	redismodule.h	/^#define REDISMODULE_WRITE /;"	d	language:C
REDISMODULE_ZADD_ADDED	redismodule.h	/^#define REDISMODULE_ZADD_ADDED /;"	d	language:C
REDISMODULE_ZADD_NOP	redismodule.h	/^#define REDISMODULE_ZADD_NOP /;"	d	language:C
REDISMODULE_ZADD_NX	redismodule.h	/^#define REDISMODULE_ZADD_NX /;"	d	language:C
REDISMODULE_ZADD_UPDATED	redismodule.h	/^#define REDISMODULE_ZADD_UPDATED /;"	d	language:C
REDISMODULE_ZADD_XX	redismodule.h	/^#define REDISMODULE_ZADD_XX /;"	d	language:C
REDISMODULE_ZSET_RANGE_LEX	module.c	/^#define REDISMODULE_ZSET_RANGE_LEX /;"	d	language:C	file:
REDISMODULE_ZSET_RANGE_NONE	module.c	/^#define REDISMODULE_ZSET_RANGE_NONE /;"	d	language:C	file:
REDISMODULE_ZSET_RANGE_POS	module.c	/^#define REDISMODULE_ZSET_RANGE_POS /;"	d	language:C	file:
REDISMODULE_ZSET_RANGE_SCORE	module.c	/^#define REDISMODULE_ZSET_RANGE_SCORE /;"	d	language:C	file:
REDIS_AGGR_MAX	t_zset.c	/^#define REDIS_AGGR_MAX /;"	d	language:C	file:
REDIS_AGGR_MIN	t_zset.c	/^#define REDIS_AGGR_MIN /;"	d	language:C	file:
REDIS_AGGR_SUM	t_zset.c	/^#define REDIS_AGGR_SUM /;"	d	language:C	file:
REDIS_CLI_DEFAULT_PIPE_TIMEOUT	redis-cli.c	/^#define REDIS_CLI_DEFAULT_PIPE_TIMEOUT /;"	d	language:C	file:
REDIS_CLI_HISTFILE_DEFAULT	redis-cli.c	/^#define REDIS_CLI_HISTFILE_DEFAULT /;"	d	language:C	file:
REDIS_CLI_HISTFILE_ENV	redis-cli.c	/^#define REDIS_CLI_HISTFILE_ENV /;"	d	language:C	file:
REDIS_CLI_KEEPALIVE_INTERVAL	redis-cli.c	/^#define REDIS_CLI_KEEPALIVE_INTERVAL /;"	d	language:C	file:
REDIS_CLI_RCFILE_DEFAULT	redis-cli.c	/^#define REDIS_CLI_RCFILE_DEFAULT /;"	d	language:C	file:
REDIS_CLI_RCFILE_ENV	redis-cli.c	/^#define REDIS_CLI_RCFILE_ENV /;"	d	language:C	file:
REDIS_COMPARE_BINARY	object.c	/^#define REDIS_COMPARE_BINARY /;"	d	language:C	file:
REDIS_COMPARE_COLL	object.c	/^#define REDIS_COMPARE_COLL /;"	d	language:C	file:
REDIS_CONFIG_REWRITE_SIGNATURE	config.c	/^#define REDIS_CONFIG_REWRITE_SIGNATURE /;"	d	language:C	file:
REDIS_LRAND48_MAX	rand.h	/^#define REDIS_LRAND48_MAX /;"	d	language:C
REDIS_RANDOM_H	rand.h	/^#define REDIS_RANDOM_H$/;"	d	language:C
REDIS_SENTINEL_PORT	sentinel.c	/^#define REDIS_SENTINEL_PORT /;"	d	language:C	file:
REDIS_STATIC	quicklist.c	/^#define REDIS_STATIC /;"	d	language:C	file:
REDIS_THREAD_STACK_SIZE	bio.c	/^#define REDIS_THREAD_STACK_SIZE /;"	d	language:C	file:
REDIS_VERSION	version.h	/^#define REDIS_VERSION /;"	d	language:C
REGISTER_API	module.c	/^#define REGISTER_API(/;"	d	language:C	file:
REPL_MAX_WRITTEN_BEFORE_FSYNC	replication.c	/^#define REPL_MAX_WRITTEN_BEFORE_FSYNC /;"	d	language:C	file:
REPL_STATE_CONNECT	server.h	/^#define REPL_STATE_CONNECT /;"	d	language:C
REPL_STATE_CONNECTED	server.h	/^#define REPL_STATE_CONNECTED /;"	d	language:C
REPL_STATE_CONNECTING	server.h	/^#define REPL_STATE_CONNECTING /;"	d	language:C
REPL_STATE_NONE	server.h	/^#define REPL_STATE_NONE /;"	d	language:C
REPL_STATE_RECEIVE_AUTH	server.h	/^#define REPL_STATE_RECEIVE_AUTH /;"	d	language:C
REPL_STATE_RECEIVE_CAPA	server.h	/^#define REPL_STATE_RECEIVE_CAPA /;"	d	language:C
REPL_STATE_RECEIVE_IP	server.h	/^#define REPL_STATE_RECEIVE_IP /;"	d	language:C
REPL_STATE_RECEIVE_PONG	server.h	/^#define REPL_STATE_RECEIVE_PONG /;"	d	language:C
REPL_STATE_RECEIVE_PORT	server.h	/^#define REPL_STATE_RECEIVE_PORT /;"	d	language:C
REPL_STATE_RECEIVE_PSYNC	server.h	/^#define REPL_STATE_RECEIVE_PSYNC /;"	d	language:C
REPL_STATE_SEND_AUTH	server.h	/^#define REPL_STATE_SEND_AUTH /;"	d	language:C
REPL_STATE_SEND_CAPA	server.h	/^#define REPL_STATE_SEND_CAPA /;"	d	language:C
REPL_STATE_SEND_IP	server.h	/^#define REPL_STATE_SEND_IP /;"	d	language:C
REPL_STATE_SEND_PORT	server.h	/^#define REPL_STATE_SEND_PORT /;"	d	language:C
REPL_STATE_SEND_PSYNC	server.h	/^#define REPL_STATE_SEND_PSYNC /;"	d	language:C
REPL_STATE_TRANSFER	server.h	/^#define REPL_STATE_TRANSFER /;"	d	language:C
REST	rand.c	/^#define REST(/;"	d	language:C	file:
RESTART_SERVER_CONFIG_REWRITE	server.h	/^#define RESTART_SERVER_CONFIG_REWRITE /;"	d	language:C
RESTART_SERVER_GRACEFULLY	server.h	/^#define RESTART_SERVER_GRACEFULLY /;"	d	language:C
RESTART_SERVER_NONE	server.h	/^#define RESTART_SERVER_NONE /;"	d	language:C
RM_Alloc	module.c	/^void *RM_Alloc(size_t bytes) {$/;"	f	language:C	signature:(size_t bytes)
RM_Alloc	modules/API.md	/^    void *RM_Alloc(size_t bytes);$/;"	p	language:C	file:	signature:(size_t bytes)
RM_AutoMemory	module.c	/^void RM_AutoMemory(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RM_AutoMemory	modules/API.md	/^    void RM_AutoMemory(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
RM_Call	module.c	/^RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
RM_CallReplyArrayElement	module.c	/^RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply, size_t idx)
RM_CallReplyArrayElement	modules/API.md	/^    RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply, size_t idx)
RM_CallReplyInteger	module.c	/^long long RM_CallReplyInteger(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
RM_CallReplyInteger	modules/API.md	/^    long long RM_CallReplyInteger(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
RM_CallReplyLength	module.c	/^size_t RM_CallReplyLength(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
RM_CallReplyProto	module.c	/^const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply, size_t *len)
RM_CallReplyProto	modules/API.md	/^    const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply, size_t *len)
RM_CallReplyStringPtr	module.c	/^const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply, size_t *len)
RM_CallReplyStringPtr	modules/API.md	/^    const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply, size_t *len)
RM_CallReplyType	module.c	/^int RM_CallReplyType(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
RM_Calloc	module.c	/^void *RM_Calloc(size_t nmemb, size_t size) {$/;"	f	language:C	signature:(size_t nmemb, size_t size)
RM_CloseKey	module.c	/^void RM_CloseKey(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_CloseKey	module.c	/^void RM_CloseKey(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_CreateCommand	module.c	/^int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep)
RM_CreateCommand	modules/API.md	/^    int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep)
RM_CreateDataType	module.c	/^moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, moduleTypeLoadFunc rdb_load, moduleTypeSaveFunc rdb_save, moduleTypeRewriteFunc aof_rewrite, moduleTypeDigestFunc digest, moduleTypeFreeFunc free) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *name, int encver, moduleTypeLoadFunc rdb_load, moduleTypeSaveFunc rdb_save, moduleTypeRewriteFunc aof_rewrite, moduleTypeDigestFunc digest, moduleTypeFreeFunc free)
RM_CreateDataType	modules/API.md	/^    moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, moduleTypeLoadFunc rdb_load, moduleTypeSaveFunc rdb_save, moduleTypeRewriteFunc aof_rewrite, moduleTypeDigestFunc digest, moduleTypeFreeFunc free);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *name, int encver, moduleTypeLoadFunc rdb_load, moduleTypeSaveFunc rdb_save, moduleTypeRewriteFunc aof_rewrite, moduleTypeDigestFunc digest, moduleTypeFreeFunc free)
RM_CreateString	module.c	/^RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len)$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *ptr, size_t len)
RM_CreateString	modules/API.md	/^    RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *ptr, size_t len)
RM_CreateStringFromCallReply	module.c	/^RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
RM_CreateStringFromCallReply	modules/API.md	/^    RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
RM_CreateStringFromLongLong	module.c	/^RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, long long ll)
RM_CreateStringFromLongLong	modules/API.md	/^    RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, long long ll)
RM_CreateStringFromString	module.c	/^RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const RedisModuleString *str)
RM_CreateStringFromString	modules/API.md	/^    RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const RedisModuleString *str)
RM_DeleteKey	module.c	/^int RM_DeleteKey(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_DeleteKey	modules/API.md	/^    int RM_DeleteKey(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_EmitAOF	module.c	/^void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {$/;"	f	language:C	signature:(RedisModuleIO *io, const char *cmdname, const char *fmt, ...)
RM_EmitAOF	modules/API.md	/^    void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, const char *cmdname, const char *fmt, ...)
RM_Free	module.c	/^void RM_Free(void *ptr) {$/;"	f	language:C	signature:(void *ptr)
RM_Free	modules/API.md	/^    void RM_Free(void *ptr);$/;"	p	language:C	file:	signature:(void *ptr)
RM_FreeCallReply	module.c	/^void RM_FreeCallReply(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
RM_FreeCallReply	module.c	/^void RM_FreeCallReply(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
RM_FreeCallReply	modules/API.md	/^    void RM_FreeCallReply(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
RM_FreeCallReply_Rec	module.c	/^void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){$/;"	f	language:C	signature:(RedisModuleCallReply *reply, int freenested)
RM_FreeCallReply_Rec	modules/API.md	/^    void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply, int freenested)
RM_FreeString	module.c	/^void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RM_FreeString	modules/API.md	/^    void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RM_GetApi	module.c	/^int RM_GetApi(const char *funcname, void **targetPtrPtr) {$/;"	f	language:C	signature:(const char *funcname, void **targetPtrPtr)
RM_GetApi	modules/API.md	/^    int RM_GetApi(const char *funcname, void **targetPtrPtr);$/;"	p	language:C	file:	signature:(const char *funcname, void **targetPtrPtr)
RM_GetClientId	module.c	/^unsigned long long RM_GetClientId(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RM_GetClientId	modules/API.md	/^    unsigned long long RM_GetClientId(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
RM_GetExpire	module.c	/^mstime_t RM_GetExpire(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_GetExpire	modules/API.md	/^    mstime_t RM_GetExpire(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_GetSelectedDb	module.c	/^int RM_GetSelectedDb(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RM_GetSelectedDb	modules/API.md	/^    int RM_GetSelectedDb(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
RM_HashGet	module.c	/^int RM_HashGet(RedisModuleKey *key, int flags, ...) {$/;"	f	language:C	signature:(RedisModuleKey *key, int flags, ...)
RM_HashSet	module.c	/^int RM_HashSet(RedisModuleKey *key, int flags, ...) {$/;"	f	language:C	signature:(RedisModuleKey *key, int flags, ...)
RM_HashSet	modules/API.md	/^    int RM_HashSet(RedisModuleKey *key, int flags, ...);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, int flags, ...)
RM_IsKeysPositionRequest	module.c	/^int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RM_IsKeysPositionRequest	modules/API.md	/^    int RM_IsKeysPositionRequest(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
RM_KeyAtPos	module.c	/^void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, int pos)
RM_KeyAtPos	modules/API.md	/^    void RM_KeyAtPos(RedisModuleCtx *ctx, int pos);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, int pos)
RM_KeyType	module.c	/^int RM_KeyType(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_KeyType	modules/API.md	/^    int RM_KeyType(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_ListPop	module.c	/^RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {$/;"	f	language:C	signature:(RedisModuleKey *key, int where)
RM_ListPop	modules/API.md	/^    RedisModuleString *RM_ListPop(RedisModuleKey *key, int where);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, int where)
RM_ListPush	module.c	/^int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {$/;"	f	language:C	signature:(RedisModuleKey *key, int where, RedisModuleString *ele)
RM_ListPush	modules/API.md	/^    int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, int where, RedisModuleString *ele)
RM_LoadDouble	module.c	/^double RM_LoadDouble(RedisModuleIO *io) {$/;"	f	language:C	signature:(RedisModuleIO *io)
RM_LoadDouble	modules/API.md	/^    double RM_LoadDouble(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RM_LoadSigned	module.c	/^int64_t RM_LoadSigned(RedisModuleIO *io) {$/;"	f	language:C	signature:(RedisModuleIO *io)
RM_LoadSigned	modules/API.md	/^    int64_t RM_LoadSigned(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RM_LoadString	module.c	/^RedisModuleString *RM_LoadString(RedisModuleIO *io) {$/;"	f	language:C	signature:(RedisModuleIO *io)
RM_LoadString	modules/API.md	/^    RedisModuleString *RM_LoadString(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RM_LoadStringBuffer	module.c	/^char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {$/;"	f	language:C	signature:(RedisModuleIO *io, size_t *lenptr)
RM_LoadStringBuffer	modules/API.md	/^    char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, size_t *lenptr)
RM_LoadUnsigned	module.c	/^uint64_t RM_LoadUnsigned(RedisModuleIO *io) {$/;"	f	language:C	signature:(RedisModuleIO *io)
RM_LoadUnsigned	modules/API.md	/^    uint64_t RM_LoadUnsigned(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RM_Log	module.c	/^void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...)
RM_ModuleTypeGetType	module.c	/^moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_ModuleTypeGetType	modules/API.md	/^    moduleType *RM_ModuleTypeGetType(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_ModuleTypeGetValue	module.c	/^void *RM_ModuleTypeGetValue(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_ModuleTypeGetValue	modules/API.md	/^    void *RM_ModuleTypeGetValue(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_ModuleTypeSetValue	module.c	/^int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {$/;"	f	language:C	signature:(RedisModuleKey *key, moduleType *mt, void *value)
RM_ModuleTypeSetValue	modules/API.md	/^    int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, moduleType *mt, void *value)
RM_OpenKey	module.c	/^void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, robj *keyname, int mode)
RM_OpenKey	modules/API.md	/^    void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, robj *keyname, int mode)
RM_PoolAlloc	module.c	/^void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, size_t bytes)
RM_PoolAlloc	modules/API.md	/^    void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, size_t bytes)
RM_Realloc	module.c	/^void* RM_Realloc(void *ptr, size_t bytes) {$/;"	f	language:C	signature:(void *ptr, size_t bytes)
RM_Realloc	modules/API.md	/^    void* RM_Realloc(void *ptr, size_t bytes);$/;"	p	language:C	file:	signature:(void *ptr, size_t bytes)
RM_Replicate	module.c	/^int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
RM_Replicate	modules/API.md	/^    int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
RM_ReplicateVerbatim	module.c	/^int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RM_ReplicateVerbatim	modules/API.md	/^    int RM_ReplicateVerbatim(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
RM_ReplySetArrayLength	module.c	/^void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, long len)
RM_ReplySetArrayLength	modules/API.md	/^    void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, long len)
RM_ReplyWithArray	module.c	/^int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, long len)
RM_ReplyWithArray	modules/API.md	/^    int RM_ReplyWithArray(RedisModuleCtx *ctx, long len);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, long len)
RM_ReplyWithCallReply	module.c	/^int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleCallReply *reply)
RM_ReplyWithCallReply	modules/API.md	/^    int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, RedisModuleCallReply *reply)
RM_ReplyWithDouble	module.c	/^int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, double d)
RM_ReplyWithDouble	modules/API.md	/^    int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, double d)
RM_ReplyWithError	module.c	/^int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *err)
RM_ReplyWithError	modules/API.md	/^    int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *err)
RM_ReplyWithLongLong	module.c	/^int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, long long ll)
RM_ReplyWithLongLong	modules/API.md	/^    int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, long long ll)
RM_ReplyWithNull	module.c	/^int RM_ReplyWithNull(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RM_ReplyWithNull	modules/API.md	/^    int RM_ReplyWithNull(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
RM_ReplyWithSimpleString	module.c	/^int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *msg)
RM_ReplyWithSimpleString	modules/API.md	/^    int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *msg)
RM_ReplyWithString	module.c	/^int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RM_ReplyWithString	modules/API.md	/^    int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RM_ReplyWithStringBuffer	module.c	/^int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *buf, size_t len)
RM_ReplyWithStringBuffer	modules/API.md	/^    int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *buf, size_t len)
RM_RetainString	module.c	/^void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RM_SaveDouble	module.c	/^void RM_SaveDouble(RedisModuleIO *io, double value) {$/;"	f	language:C	signature:(RedisModuleIO *io, double value)
RM_SaveDouble	modules/API.md	/^    void RM_SaveDouble(RedisModuleIO *io, double value);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, double value)
RM_SaveSigned	module.c	/^void RM_SaveSigned(RedisModuleIO *io, int64_t value) {$/;"	f	language:C	signature:(RedisModuleIO *io, int64_t value)
RM_SaveSigned	modules/API.md	/^    void RM_SaveSigned(RedisModuleIO *io, int64_t value);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, int64_t value)
RM_SaveString	module.c	/^void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {$/;"	f	language:C	signature:(RedisModuleIO *io, RedisModuleString *s)
RM_SaveString	modules/API.md	/^    void RM_SaveString(RedisModuleIO *io, RedisModuleString *s);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, RedisModuleString *s)
RM_SaveStringBuffer	module.c	/^void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {$/;"	f	language:C	signature:(RedisModuleIO *io, const char *str, size_t len)
RM_SaveStringBuffer	modules/API.md	/^    void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, const char *str, size_t len)
RM_SaveUnsigned	module.c	/^void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {$/;"	f	language:C	signature:(RedisModuleIO *io, uint64_t value)
RM_SaveUnsigned	modules/API.md	/^    void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, uint64_t value)
RM_SelectDb	module.c	/^int RM_SelectDb(RedisModuleCtx *ctx, int newid) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, int newid)
RM_SelectDb	modules/API.md	/^    int RM_SelectDb(RedisModuleCtx *ctx, int newid);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, int newid)
RM_SetExpire	module.c	/^int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {$/;"	f	language:C	signature:(RedisModuleKey *key, mstime_t expire)
RM_SetExpire	modules/API.md	/^    int RM_SetExpire(RedisModuleKey *key, mstime_t expire);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, mstime_t expire)
RM_SetModuleAttribs	module.c	/^void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver){$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *name, int ver, int apiver)
RM_Strdup	module.c	/^char *RM_Strdup(const char *str) {$/;"	f	language:C	signature:(const char *str)
RM_Strdup	modules/API.md	/^    char *RM_Strdup(const char *str);$/;"	p	language:C	file:	signature:(const char *str)
RM_StringAppendBuffer	module.c	/^int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len)
RM_StringCompare	module.c	/^int RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {$/;"	f	language:C	signature:(RedisModuleString *a, RedisModuleString *b)
RM_StringDMA	module.c	/^char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {$/;"	f	language:C	signature:(RedisModuleKey *key, size_t *len, int mode)
RM_StringDMA	modules/API.md	/^    char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, size_t *len, int mode)
RM_StringPtrLen	module.c	/^const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {$/;"	f	language:C	signature:(const RedisModuleString *str, size_t *len)
RM_StringSet	module.c	/^int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {$/;"	f	language:C	signature:(RedisModuleKey *key, RedisModuleString *str)
RM_StringSet	modules/API.md	/^    int RM_StringSet(RedisModuleKey *key, RedisModuleString *str);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, RedisModuleString *str)
RM_StringToDouble	module.c	/^int RM_StringToDouble(const RedisModuleString *str, double *d) {$/;"	f	language:C	signature:(const RedisModuleString *str, double *d)
RM_StringToDouble	modules/API.md	/^    int RM_StringToDouble(RedisModuleString *str, double *d);$/;"	p	language:C	file:	signature:(RedisModuleString *str, double *d)
RM_StringToLongLong	module.c	/^int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {$/;"	f	language:C	signature:(const RedisModuleString *str, long long *ll)
RM_StringToLongLong	modules/API.md	/^    int RM_StringToLongLong(RedisModuleString *str, long long *ll);$/;"	p	language:C	file:	signature:(RedisModuleString *str, long long *ll)
RM_StringTruncate	module.c	/^int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {$/;"	f	language:C	signature:(RedisModuleKey *key, size_t newlen)
RM_StringTruncate	modules/API.md	/^    int RM_StringTruncate(RedisModuleKey *key, size_t newlen);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, size_t newlen)
RM_ValueLength	module.c	/^size_t RM_ValueLength(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_ValueLength	modules/API.md	/^    size_t RM_ValueLength(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_WrongArity	module.c	/^int RM_WrongArity(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RM_WrongArity	modules/API.md	/^    int RM_WrongArity(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
RM_ZsetAdd	module.c	/^int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {$/;"	f	language:C	signature:(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr)
RM_ZsetAdd	modules/API.md	/^    int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr)
RM_ZsetAddFlagsFromCoreFlags	module.c	/^int RM_ZsetAddFlagsFromCoreFlags(int flags) {$/;"	f	language:C	signature:(int flags)
RM_ZsetAddFlagsFromCoreFlags	modules/API.md	/^    int RM_ZsetAddFlagsFromCoreFlags(int flags);$/;"	p	language:C	file:	signature:(int flags)
RM_ZsetAddFlagsToCoreFlags	module.c	/^int RM_ZsetAddFlagsToCoreFlags(int flags) {$/;"	f	language:C	signature:(int flags)
RM_ZsetAddFlagsToCoreFlags	modules/API.md	/^    int RM_ZsetAddFlagsToCoreFlags(int flags);$/;"	p	language:C	file:	signature:(int flags)
RM_ZsetFirstInLexRange	module.c	/^int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {$/;"	f	language:C	signature:(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max)
RM_ZsetFirstInLexRange	modules/API.md	/^    int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max)
RM_ZsetFirstInScoreRange	module.c	/^int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {$/;"	f	language:C	signature:(RedisModuleKey *key, double min, double max, int minex, int maxex)
RM_ZsetFirstInScoreRange	modules/API.md	/^    int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, double min, double max, int minex, int maxex)
RM_ZsetIncrby	module.c	/^int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {$/;"	f	language:C	signature:(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore)
RM_ZsetLastInLexRange	module.c	/^int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {$/;"	f	language:C	signature:(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max)
RM_ZsetLastInLexRange	modules/API.md	/^    int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max)
RM_ZsetLastInScoreRange	module.c	/^int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {$/;"	f	language:C	signature:(RedisModuleKey *key, double min, double max, int minex, int maxex)
RM_ZsetLastInScoreRange	modules/API.md	/^    int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, double min, double max, int minex, int maxex)
RM_ZsetRangeCurrentElement	module.c	/^RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {$/;"	f	language:C	signature:(RedisModuleKey *key, double *score)
RM_ZsetRangeCurrentElement	modules/API.md	/^    RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score);$/;"	p	language:C	file:	signature:(RedisModuleKey *key, double *score)
RM_ZsetRangeEndReached	module.c	/^int RM_ZsetRangeEndReached(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_ZsetRangeEndReached	modules/API.md	/^    int RM_ZsetRangeEndReached(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_ZsetRangeNext	module.c	/^int RM_ZsetRangeNext(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_ZsetRangeNext	modules/API.md	/^    int RM_ZsetRangeNext(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_ZsetRangePrev	module.c	/^int RM_ZsetRangePrev(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_ZsetRangePrev	modules/API.md	/^    int RM_ZsetRangePrev(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_ZsetRangeStop	module.c	/^void RM_ZsetRangeStop(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
RM_ZsetRangeStop	module.c	/^void RM_ZsetRangeStop(RedisModuleKey *kp);$/;"	p	language:C	file:	signature:(RedisModuleKey *kp)
RM_ZsetRangeStop	modules/API.md	/^    void RM_ZsetRangeStop(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
RM_ZsetRem	module.c	/^int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {$/;"	f	language:C	signature:(RedisModuleKey *key, RedisModuleString *ele, int *deleted)
RM_ZsetScore	module.c	/^int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {$/;"	f	language:C	signature:(RedisModuleKey *key, RedisModuleString *ele, double *score)
R_MAJOR	geohash_helper.c	/^#define R_MAJOR /;"	d	language:C	file:
R_MINOR	geohash_helper.c	/^#define R_MINOR /;"	d	language:C	file:
R_Nan	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	language:C
R_Nan	server.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x	language:C
R_NegInf	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	language:C
R_NegInf	server.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x	language:C
R_PosInf	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	language:C
R_PosInf	server.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x	language:C
R_Zero	server.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	language:C
R_Zero	server.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x	language:C
RedisModule	module.c	/^struct RedisModule {$/;"	s	language:C	file:
RedisModule	module.c	/^typedef struct RedisModule RedisModule;$/;"	t	language:C	typeref:struct:RedisModule	file:
RedisModule	server.h	/^struct RedisModule;$/;"	x	language:C
RedisModule::apiver	module.c	/^    int apiver;     \/* Module API version as requested during initialization.*\/$/;"	m	language:C	struct:RedisModule	file:	access:public
RedisModule::handle	module.c	/^    void *handle;   \/* Module dlopen() handle. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
RedisModule::name	module.c	/^    char *name;     \/* Module name. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
RedisModule::types	module.c	/^    list *types;    \/* Module data types. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
RedisModule::ver	module.c	/^    int ver;        \/* Module version. We use just progressive integers. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
RedisModuleCallReply	module.c	/^typedef struct RedisModuleCallReply {$/;"	s	language:C	file:
RedisModuleCallReply	module.c	/^} RedisModuleCallReply;$/;"	t	language:C	typeref:struct:RedisModuleCallReply	file:
RedisModuleCallReply	redismodule.h	/^typedef struct RedisModuleCallReply RedisModuleCallReply;$/;"	t	language:C	typeref:struct:RedisModuleCallReply
RedisModuleCallReply::__anon19::array	module.c	/^        struct RedisModuleCallReply *array; \/* Array of sub-reply elements. *\/$/;"	m	language:C	union:RedisModuleCallReply::__anon19	typeref:struct:RedisModuleCallReply::__anon19::RedisModuleCallReply	file:	access:public
RedisModuleCallReply::__anon19::ll	module.c	/^        long long ll;    \/* Reply value for integer reply. *\/$/;"	m	language:C	union:RedisModuleCallReply::__anon19	file:	access:public
RedisModuleCallReply::__anon19::str	module.c	/^        const char *str; \/* String pointer for string and error replies. This$/;"	m	language:C	union:RedisModuleCallReply::__anon19	file:	access:public
RedisModuleCallReply::ctx	module.c	/^    RedisModuleCtx *ctx;$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
RedisModuleCallReply::flags	module.c	/^    int flags;      \/* REDISMODULE_REPLYFLAG_...  *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
RedisModuleCallReply::len	module.c	/^    size_t len;     \/* Len of strings or num of elements of arrays. *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
RedisModuleCallReply::proto	module.c	/^    char *proto;    \/* Raw reply protocol. An SDS string at top-level object. *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
RedisModuleCallReply::protolen	module.c	/^    size_t protolen;\/* Length of protocol. *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
RedisModuleCallReply::type	module.c	/^    int type;       \/* REDISMODULE_REPLY_... *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
RedisModuleCallReply::val	module.c	/^    } val;$/;"	m	language:C	struct:RedisModuleCallReply	typeref:union:RedisModuleCallReply::__anon19	file:	access:public
RedisModuleCmdFunc	module.c	/^typedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);$/;"	t	language:C	file:
RedisModuleCmdFunc	redismodule.h	/^typedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, RedisModuleString **argv, int argc);$/;"	t	language:C
RedisModuleCommandDispatcher	module.c	/^void RedisModuleCommandDispatcher(client *c) {$/;"	f	language:C	signature:(client *c)
RedisModuleCommandProxy	module.c	/^struct RedisModuleCommandProxy {$/;"	s	language:C	file:
RedisModuleCommandProxy	module.c	/^typedef struct RedisModuleCommandProxy RedisModuleCommandProxy;$/;"	t	language:C	typeref:struct:RedisModuleCommandProxy	file:
RedisModuleCommandProxy::func	module.c	/^    RedisModuleCmdFunc func;$/;"	m	language:C	struct:RedisModuleCommandProxy	file:	access:public
RedisModuleCommandProxy::module	module.c	/^    struct RedisModule *module;$/;"	m	language:C	struct:RedisModuleCommandProxy	typeref:struct:RedisModuleCommandProxy::RedisModule	file:	access:public
RedisModuleCommandProxy::rediscmd	module.c	/^    struct redisCommand *rediscmd;$/;"	m	language:C	struct:RedisModuleCommandProxy	typeref:struct:RedisModuleCommandProxy::redisCommand	file:	access:public
RedisModuleCtx	module.c	/^struct RedisModuleCtx {$/;"	s	language:C	file:
RedisModuleCtx	module.c	/^typedef struct RedisModuleCtx RedisModuleCtx;$/;"	t	language:C	typeref:struct:RedisModuleCtx	file:
RedisModuleCtx	redismodule.h	/^typedef struct RedisModuleCtx RedisModuleCtx;$/;"	t	language:C	typeref:struct:RedisModuleCtx
RedisModuleCtx::amqueue	module.c	/^    struct AutoMemEntry *amqueue;   \/* Auto memory queue of objects to free. *\/$/;"	m	language:C	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::AutoMemEntry	file:	access:public
RedisModuleCtx::amqueue_len	module.c	/^    int amqueue_len;                \/* Number of slots in amqueue. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::amqueue_used	module.c	/^    int amqueue_used;               \/* Number of used slots in amqueue. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::client	module.c	/^    client *client;                 \/* Client calling a command. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::flags	module.c	/^    int flags;                      \/* REDISMODULE_CTX_... flags. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::getapifuncptr	module.c	/^    void *getapifuncptr;            \/* NOTE: Must be the first field. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::keys_count	module.c	/^    int keys_count;$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::keys_pos	module.c	/^    int *keys_pos;$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::module	module.c	/^    struct RedisModule *module;     \/* Module reference. *\/$/;"	m	language:C	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::RedisModule	file:	access:public
RedisModuleCtx::pa_head	module.c	/^    struct RedisModulePoolAllocBlock *pa_head;$/;"	m	language:C	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::RedisModulePoolAllocBlock	file:	access:public
RedisModuleCtx::postponed_arrays	module.c	/^    void **postponed_arrays;        \/* To set with RM_ReplySetArrayLength(). *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleCtx::postponed_arrays_count	module.c	/^    int postponed_arrays_count;     \/* Number of entries in postponed_arrays. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
RedisModuleDigest	redismodule.h	/^typedef struct RedisModuleDigest RedisModuleDigest;$/;"	t	language:C	typeref:struct:RedisModuleDigest
RedisModuleDigest	server.h	/^struct RedisModuleDigest;$/;"	x	language:C
RedisModuleIO	redismodule.h	/^typedef struct RedisModuleIO RedisModuleIO;$/;"	t	language:C	typeref:struct:RedisModuleIO
RedisModuleIO	server.h	/^struct RedisModuleIO;$/;"	x	language:C
RedisModuleIO	server.h	/^typedef struct RedisModuleIO {$/;"	s	language:C
RedisModuleIO	server.h	/^} RedisModuleIO;$/;"	t	language:C	typeref:struct:RedisModuleIO
RedisModuleIO::bytes	server.h	/^    size_t bytes;       \/* Bytes read \/ written so far. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
RedisModuleIO::error	server.h	/^    int error;          \/* True if error condition happened. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
RedisModuleIO::rio	server.h	/^    rio *rio;           \/* Rio stream. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
RedisModuleIO::type	server.h	/^    moduleType *type;   \/* Module type doing the operation. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
RedisModuleKey	module.c	/^struct RedisModuleKey {$/;"	s	language:C	file:
RedisModuleKey	module.c	/^typedef struct RedisModuleKey RedisModuleKey;$/;"	t	language:C	typeref:struct:RedisModuleKey	file:
RedisModuleKey	redismodule.h	/^typedef struct RedisModuleKey RedisModuleKey;$/;"	t	language:C	typeref:struct:RedisModuleKey
RedisModuleKey::ctx	module.c	/^    RedisModuleCtx *ctx;$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::db	module.c	/^    redisDb *db;$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::iter	module.c	/^    void *iter;     \/* Iterator. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::key	module.c	/^    robj *key;      \/* Key name object. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::mode	module.c	/^    int mode;       \/* Opening mode. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::value	module.c	/^    robj *value;    \/* Value object, or NULL if the key was not found. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::zcurrent	module.c	/^    void *zcurrent;         \/* Zset iterator current node. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::zend	module.c	/^    uint32_t zend;          \/* End pos for positional ranges. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::zer	module.c	/^    int zer;                \/* Zset iterator end reached flag$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::zlrs	module.c	/^    zlexrangespec zlrs;     \/* Lex range. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::zrs	module.c	/^    zrangespec zrs;         \/* Score range. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::zstart	module.c	/^    uint32_t zstart;        \/* Start pos for positional ranges. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModuleKey::ztype	module.c	/^    uint32_t ztype;         \/* REDISMODULE_ZSET_RANGE_* *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
RedisModulePoolAllocBlock	module.c	/^typedef struct RedisModulePoolAllocBlock {$/;"	s	language:C	file:
RedisModulePoolAllocBlock	module.c	/^} RedisModulePoolAllocBlock;$/;"	t	language:C	typeref:struct:RedisModulePoolAllocBlock	file:
RedisModulePoolAllocBlock::memory	module.c	/^    char memory[];$/;"	m	language:C	struct:RedisModulePoolAllocBlock	file:	access:public
RedisModulePoolAllocBlock::next	module.c	/^    struct RedisModulePoolAllocBlock *next;$/;"	m	language:C	struct:RedisModulePoolAllocBlock	typeref:struct:RedisModulePoolAllocBlock::RedisModulePoolAllocBlock	file:	access:public
RedisModulePoolAllocBlock::size	module.c	/^    uint32_t size;$/;"	m	language:C	struct:RedisModulePoolAllocBlock	file:	access:public
RedisModulePoolAllocBlock::used	module.c	/^    uint32_t used;$/;"	m	language:C	struct:RedisModulePoolAllocBlock	file:	access:public
RedisModuleString	redismodule.h	/^#define RedisModuleString /;"	d	language:C
RedisModuleString	redismodule.h	/^typedef struct RedisModuleString RedisModuleString;$/;"	t	language:C	typeref:struct:RedisModuleString
RedisModuleType	redismodule.h	/^typedef struct RedisModuleType RedisModuleType;$/;"	t	language:C	typeref:struct:RedisModuleType
RedisModuleType	server.h	/^typedef struct RedisModuleType {$/;"	s	language:C
RedisModuleType::aof_rewrite	server.h	/^    moduleTypeRewriteFunc aof_rewrite;$/;"	m	language:C	struct:RedisModuleType	access:public
RedisModuleType::digest	server.h	/^    moduleTypeDigestFunc digest;$/;"	m	language:C	struct:RedisModuleType	access:public
RedisModuleType::free	server.h	/^    moduleTypeFreeFunc free;$/;"	m	language:C	struct:RedisModuleType	access:public
RedisModuleType::id	server.h	/^    uint64_t id; \/* Higher 54 bits of type ID + 10 lower bits of encoding ver. *\/$/;"	m	language:C	struct:RedisModuleType	access:public
RedisModuleType::module	server.h	/^    struct RedisModule *module;$/;"	m	language:C	struct:RedisModuleType	typeref:struct:RedisModuleType::RedisModule	access:public
RedisModuleType::name	server.h	/^    char name[10]; \/* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- *\/$/;"	m	language:C	struct:RedisModuleType	access:public
RedisModuleType::rdb_load	server.h	/^    moduleTypeLoadFunc rdb_load;$/;"	m	language:C	struct:RedisModuleType	access:public
RedisModuleType::rdb_save	server.h	/^    moduleTypeSaveFunc rdb_save;$/;"	m	language:C	struct:RedisModuleType	access:public
RedisModuleTypeDigestFunc	modules/TYPES.md	/^    typedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);$/;"	t	language:C	file:
RedisModuleTypeDigestFunc	redismodule.h	/^typedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);$/;"	t	language:C
RedisModuleTypeFreeFunc	modules/TYPES.md	/^    typedef void (*RedisModuleTypeFreeFunc)(void *value);$/;"	t	language:C	file:
RedisModuleTypeFreeFunc	redismodule.h	/^typedef void (*RedisModuleTypeFreeFunc)(void *value);$/;"	t	language:C
RedisModuleTypeLoadFunc	modules/TYPES.md	/^    typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);$/;"	t	language:C	file:
RedisModuleTypeLoadFunc	redismodule.h	/^typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);$/;"	t	language:C
RedisModuleTypeRewriteFunc	modules/TYPES.md	/^    typedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);$/;"	t	language:C	file:
RedisModuleTypeRewriteFunc	redismodule.h	/^typedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);$/;"	t	language:C
RedisModuleTypeSaveFunc	modules/TYPES.md	/^    typedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);$/;"	t	language:C	file:
RedisModuleTypeSaveFunc	redismodule.h	/^typedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);$/;"	t	language:C
RedisModule_Alloc	redismodule.h	/^void *REDISMODULE_API_FUNC(RedisModule_Alloc)(size_t bytes);$/;"	p	language:C	signature:(size_t bytes)
RedisModule_AutoMemory	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_AutoMemory)(RedisModuleCtx *ctx);$/;"	p	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_Call	redismodule.h	/^RedisModuleCallReply *REDISMODULE_API_FUNC(RedisModule_Call)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
RedisModule_CallReplyArrayElement	redismodule.h	/^RedisModuleCallReply *REDISMODULE_API_FUNC(RedisModule_CallReplyArrayElement)(RedisModuleCallReply *reply, size_t idx);$/;"	p	language:C	signature:(RedisModuleCallReply *reply, size_t idx)
RedisModule_CallReplyInteger	redismodule.h	/^long long REDISMODULE_API_FUNC(RedisModule_CallReplyInteger)(RedisModuleCallReply *reply);$/;"	p	language:C	signature:(RedisModuleCallReply *reply)
RedisModule_CallReplyLength	redismodule.h	/^size_t REDISMODULE_API_FUNC(RedisModule_CallReplyLength)(RedisModuleCallReply *reply);$/;"	p	language:C	signature:(RedisModuleCallReply *reply)
RedisModule_CallReplyProto	redismodule.h	/^const char *REDISMODULE_API_FUNC(RedisModule_CallReplyProto)(RedisModuleCallReply *reply, size_t *len);$/;"	p	language:C	signature:(RedisModuleCallReply *reply, size_t *len)
RedisModule_CallReplyStringPtr	redismodule.h	/^const char *REDISMODULE_API_FUNC(RedisModule_CallReplyStringPtr)(RedisModuleCallReply *reply, size_t *len);$/;"	p	language:C	signature:(RedisModuleCallReply *reply, size_t *len)
RedisModule_CallReplyType	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_CallReplyType)(RedisModuleCallReply *reply);$/;"	p	language:C	signature:(RedisModuleCallReply *reply)
RedisModule_Calloc	redismodule.h	/^void *REDISMODULE_API_FUNC(RedisModule_Calloc)(size_t nmemb, size_t size);$/;"	p	language:C	signature:(size_t nmemb, size_t size)
RedisModule_CloseKey	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_CloseKey)(RedisModuleKey *kp);$/;"	p	language:C	signature:(RedisModuleKey *kp)
RedisModule_CreateCommand	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_CreateCommand)(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep)
RedisModule_CreateDataType	modules/TYPES.md	/^    moduleType *RedisModule_CreateDataType(RedisModuleCtx *ctx,$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *name, int encver, moduleTypeLoadFunc rdb_load, moduleTypeSaveFunc rdb_save, moduleTypeRewriteFunc aof_rewrite, moduleTypeDigestFunc digest, moduleTypeFreeFunc free)
RedisModule_CreateDataType	redismodule.h	/^RedisModuleType *REDISMODULE_API_FUNC(RedisModule_CreateDataType)(RedisModuleCtx *ctx, const char *name, int encver, RedisModuleTypeLoadFunc rdb_load, RedisModuleTypeSaveFunc rdb_save, RedisModuleTypeRewriteFunc aof_rewrite, RedisModuleTypeDigestFunc digest, RedisModuleTypeFreeFunc free);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *name, int encver, RedisModuleTypeLoadFunc rdb_load, RedisModuleTypeSaveFunc rdb_save, RedisModuleTypeRewriteFunc aof_rewrite, RedisModuleTypeDigestFunc digest, RedisModuleTypeFreeFunc free)
RedisModule_CreateString	modules/INTRO.md	/^    RedisModuleString *RedisModule_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *ptr, size_t len)
RedisModule_CreateString	redismodule.h	/^RedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateString)(RedisModuleCtx *ctx, const char *ptr, size_t len);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *ptr, size_t len)
RedisModule_CreateStringFromCallReply	redismodule.h	/^RedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateStringFromCallReply)(RedisModuleCallReply *reply);$/;"	p	language:C	signature:(RedisModuleCallReply *reply)
RedisModule_CreateStringFromLongLong	redismodule.h	/^RedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateStringFromLongLong)(RedisModuleCtx *ctx, long long ll);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, long long ll)
RedisModule_CreateStringFromString	redismodule.h	/^RedisModuleString *REDISMODULE_API_FUNC(RedisModule_CreateStringFromString)(RedisModuleCtx *ctx, const RedisModuleString *str);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const RedisModuleString *str)
RedisModule_DeleteKey	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_DeleteKey)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_EmitAOF	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_EmitAOF)(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);$/;"	p	language:C	signature:(RedisModuleIO *io, const char *cmdname, const char *fmt, ...)
RedisModule_Free	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_Free)(void *ptr);$/;"	p	language:C	signature:(void *ptr)
RedisModule_FreeCallReply	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_FreeCallReply)(RedisModuleCallReply *reply);$/;"	p	language:C	signature:(RedisModuleCallReply *reply)
RedisModule_FreeString	modules/INTRO.md	/^call to `RedisModule_FreeString()`:$/;"	p	language:C	file:
RedisModule_FreeString	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_FreeString)(RedisModuleCtx *ctx, RedisModuleString *str);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RedisModule_GetApi	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_GetApi)(const char *, void *);$/;"	p	language:C	signature:(const char *, void *)
RedisModule_GetClientId	redismodule.h	/^unsigned long long REDISMODULE_API_FUNC(RedisModule_GetClientId)(RedisModuleCtx *ctx);$/;"	p	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_GetExpire	redismodule.h	/^mstime_t REDISMODULE_API_FUNC(RedisModule_GetExpire)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_GetSelectedDb	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_GetSelectedDb)(RedisModuleCtx *ctx);$/;"	p	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_HashGet	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_HashGet)(RedisModuleKey *key, int flags, ...);$/;"	p	language:C	signature:(RedisModuleKey *key, int flags, ...)
RedisModule_HashSet	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_HashSet)(RedisModuleKey *key, int flags, ...);$/;"	p	language:C	signature:(RedisModuleKey *key, int flags, ...)
RedisModule_Init	modules/INTRO.md	/^    int RedisModule_Init(RedisModuleCtx *ctx, const char *modulename,$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, const char *modulename, int module_version, int api_version)
RedisModule_Init	redismodule.h	/^static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) __attribute__((unused));$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *name, int ver, int apiver)
RedisModule_Init	redismodule.h	/^static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *name, int ver, int apiver)
RedisModule_IsKeysPositionRequest	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_IsKeysPositionRequest)(RedisModuleCtx *ctx);$/;"	p	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_KeyAtPos	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_KeyAtPos)(RedisModuleCtx *ctx, int pos);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, int pos)
RedisModule_KeyType	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_KeyType)(RedisModuleKey *kp);$/;"	p	language:C	signature:(RedisModuleKey *kp)
RedisModule_ListPop	redismodule.h	/^RedisModuleString *REDISMODULE_API_FUNC(RedisModule_ListPop)(RedisModuleKey *key, int where);$/;"	p	language:C	signature:(RedisModuleKey *key, int where)
RedisModule_ListPush	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ListPush)(RedisModuleKey *kp, int where, RedisModuleString *ele);$/;"	p	language:C	signature:(RedisModuleKey *kp, int where, RedisModuleString *ele)
RedisModule_LoadDouble	modules/TYPES.md	/^    double RedisModule_LoadDouble(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RedisModule_LoadDouble	redismodule.h	/^double REDISMODULE_API_FUNC(RedisModule_LoadDouble)(RedisModuleIO *io);$/;"	p	language:C	signature:(RedisModuleIO *io)
RedisModule_LoadSigned	modules/TYPES.md	/^    int64_t RedisModule_LoadSigned(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RedisModule_LoadSigned	redismodule.h	/^int64_t REDISMODULE_API_FUNC(RedisModule_LoadSigned)(RedisModuleIO *io);$/;"	p	language:C	signature:(RedisModuleIO *io)
RedisModule_LoadString	modules/TYPES.md	/^    RedisModuleString *RedisModule_LoadString(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RedisModule_LoadString	redismodule.h	/^RedisModuleString *REDISMODULE_API_FUNC(RedisModule_LoadString)(RedisModuleIO *io);$/;"	p	language:C	signature:(RedisModuleIO *io)
RedisModule_LoadStringBuffer	modules/TYPES.md	/^    char *RedisModule_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, size_t *lenptr)
RedisModule_LoadStringBuffer	redismodule.h	/^char *REDISMODULE_API_FUNC(RedisModule_LoadStringBuffer)(RedisModuleIO *io, size_t *lenptr);$/;"	p	language:C	signature:(RedisModuleIO *io, size_t *lenptr)
RedisModule_LoadUnsigned	modules/TYPES.md	/^    uint64_t RedisModule_LoadUnsigned(RedisModuleIO *io);$/;"	p	language:C	file:	signature:(RedisModuleIO *io)
RedisModule_LoadUnsigned	redismodule.h	/^uint64_t REDISMODULE_API_FUNC(RedisModule_LoadUnsigned)(RedisModuleIO *io);$/;"	p	language:C	signature:(RedisModuleIO *io)
RedisModule_Log	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_Log)(RedisModuleCtx *ctx, const char *level, const char *fmt, ...);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *level, const char *fmt, ...)
RedisModule_ModuleTypeGetType	redismodule.h	/^RedisModuleType *REDISMODULE_API_FUNC(RedisModule_ModuleTypeGetType)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_ModuleTypeGetValue	redismodule.h	/^void *REDISMODULE_API_FUNC(RedisModule_ModuleTypeGetValue)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_ModuleTypeSetValue	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ModuleTypeSetValue)(RedisModuleKey *key, RedisModuleType *mt, void *value);$/;"	p	language:C	signature:(RedisModuleKey *key, RedisModuleType *mt, void *value)
RedisModule_OnLoad	modules/INTRO.md	/^    int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
RedisModule_OnLoad	modules/TYPES.md	/^    int RedisModule_OnLoad(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_OnLoad	modules/hellotype.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
RedisModule_OnLoad	modules/helloworld.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
RedisModule_OnLoad	modules/testmodule.c	/^int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
RedisModule_OpenKey	redismodule.h	/^void *REDISMODULE_API_FUNC(RedisModule_OpenKey)(RedisModuleCtx *ctx, RedisModuleString *keyname, int mode);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *keyname, int mode)
RedisModule_PoolAlloc	redismodule.h	/^void *REDISMODULE_API_FUNC(RedisModule_PoolAlloc)(RedisModuleCtx *ctx, size_t bytes);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, size_t bytes)
RedisModule_Realloc	redismodule.h	/^void *REDISMODULE_API_FUNC(RedisModule_Realloc)(void *ptr, size_t bytes);$/;"	p	language:C	signature:(void *ptr, size_t bytes)
RedisModule_Replicate	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_Replicate)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...)
RedisModule_ReplicateVerbatim	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplicateVerbatim)(RedisModuleCtx *ctx);$/;"	p	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_ReplySetArrayLength	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_ReplySetArrayLength)(RedisModuleCtx *ctx, long len);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, long len)
RedisModule_ReplyWithArray	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithArray)(RedisModuleCtx *ctx, long len);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, long len)
RedisModule_ReplyWithCallReply	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithCallReply)(RedisModuleCtx *ctx, RedisModuleCallReply *reply);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, RedisModuleCallReply *reply)
RedisModule_ReplyWithDouble	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithDouble)(RedisModuleCtx *ctx, double d);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, double d)
RedisModule_ReplyWithError	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithError)(RedisModuleCtx *ctx, const char *err);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *err)
RedisModule_ReplyWithLongLong	modules/INTRO.md	/^    int RedisModule_ReplyWithLongLong(RedisModuleCtx *ctx, long long integer);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, long long integer)
RedisModule_ReplyWithLongLong	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithLongLong)(RedisModuleCtx *ctx, long long ll);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, long long ll)
RedisModule_ReplyWithNull	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithNull)(RedisModuleCtx *ctx);$/;"	p	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_ReplyWithSimpleString	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithSimpleString)(RedisModuleCtx *ctx, const char *msg);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *msg)
RedisModule_ReplyWithString	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithString)(RedisModuleCtx *ctx, RedisModuleString *str);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RedisModule_ReplyWithStringBuffer	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ReplyWithStringBuffer)(RedisModuleCtx *ctx, const char *buf, size_t len);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *buf, size_t len)
RedisModule_RetainString	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_RetainString)(RedisModuleCtx *ctx, RedisModuleString *str);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str)
RedisModule_SaveDouble	modules/TYPES.md	/^    void RedisModule_SaveDouble(RedisModuleIO *io, double value);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, double value)
RedisModule_SaveDouble	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_SaveDouble)(RedisModuleIO *io, double value);$/;"	p	language:C	signature:(RedisModuleIO *io, double value)
RedisModule_SaveSigned	modules/TYPES.md	/^    void RedisModule_SaveSigned(RedisModuleIO *io, int64_t value);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, int64_t value)
RedisModule_SaveSigned	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_SaveSigned)(RedisModuleIO *io, int64_t value);$/;"	p	language:C	signature:(RedisModuleIO *io, int64_t value)
RedisModule_SaveString	modules/TYPES.md	/^    void RedisModule_SaveString(RedisModuleIO *io, RedisModuleString *s);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, RedisModuleString *s)
RedisModule_SaveString	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_SaveString)(RedisModuleIO *io, RedisModuleString *s);$/;"	p	language:C	signature:(RedisModuleIO *io, RedisModuleString *s)
RedisModule_SaveStringBuffer	modules/TYPES.md	/^    void RedisModule_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, const char *str, size_t len)
RedisModule_SaveStringBuffer	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_SaveStringBuffer)(RedisModuleIO *io, const char *str, size_t len);$/;"	p	language:C	signature:(RedisModuleIO *io, const char *str, size_t len)
RedisModule_SaveUnsigned	modules/TYPES.md	/^    void RedisModule_SaveUnsigned(RedisModuleIO *io, uint64_t value);$/;"	p	language:C	file:	signature:(RedisModuleIO *io, uint64_t value)
RedisModule_SaveUnsigned	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_SaveUnsigned)(RedisModuleIO *io, uint64_t value);$/;"	p	language:C	signature:(RedisModuleIO *io, uint64_t value)
RedisModule_SelectDb	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_SelectDb)(RedisModuleCtx *ctx, int newid);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, int newid)
RedisModule_SetExpire	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_SetExpire)(RedisModuleKey *key, mstime_t expire);$/;"	p	language:C	signature:(RedisModuleKey *key, mstime_t expire)
RedisModule_SetModuleAttribs	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_SetModuleAttribs)(RedisModuleCtx *ctx, const char *name, int ver, int apiver);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, const char *name, int ver, int apiver)
RedisModule_Strdup	redismodule.h	/^char *REDISMODULE_API_FUNC(RedisModule_Strdup)(const char *str);$/;"	p	language:C	signature:(const char *str)
RedisModule_StringAppendBuffer	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_StringAppendBuffer)(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len);$/;"	p	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len)
RedisModule_StringCompare	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_StringCompare)(RedisModuleString *a, RedisModuleString *b);$/;"	p	language:C	signature:(RedisModuleString *a, RedisModuleString *b)
RedisModule_StringDMA	redismodule.h	/^char *REDISMODULE_API_FUNC(RedisModule_StringDMA)(RedisModuleKey *key, size_t *len, int mode);$/;"	p	language:C	signature:(RedisModuleKey *key, size_t *len, int mode)
RedisModule_StringPtrLen	redismodule.h	/^const char *REDISMODULE_API_FUNC(RedisModule_StringPtrLen)(const RedisModuleString *str, size_t *len);$/;"	p	language:C	signature:(const RedisModuleString *str, size_t *len)
RedisModule_StringSet	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_StringSet)(RedisModuleKey *key, RedisModuleString *str);$/;"	p	language:C	signature:(RedisModuleKey *key, RedisModuleString *str)
RedisModule_StringToDouble	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_StringToDouble)(const RedisModuleString *str, double *d);$/;"	p	language:C	signature:(const RedisModuleString *str, double *d)
RedisModule_StringToLongLong	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_StringToLongLong)(const RedisModuleString *str, long long *ll);$/;"	p	language:C	signature:(const RedisModuleString *str, long long *ll)
RedisModule_StringTruncate	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_StringTruncate)(RedisModuleKey *key, size_t newlen);$/;"	p	language:C	signature:(RedisModuleKey *key, size_t newlen)
RedisModule_ValueLength	redismodule.h	/^size_t REDISMODULE_API_FUNC(RedisModule_ValueLength)(RedisModuleKey *kp);$/;"	p	language:C	signature:(RedisModuleKey *kp)
RedisModule_WrongArity	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_WrongArity)(RedisModuleCtx *ctx);$/;"	p	language:C	signature:(RedisModuleCtx *ctx)
RedisModule_ZsetAdd	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetAdd)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr);$/;"	p	language:C	signature:(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr)
RedisModule_ZsetFirstInLexRange	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetFirstInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);$/;"	p	language:C	signature:(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max)
RedisModule_ZsetFirstInScoreRange	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetFirstInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex);$/;"	p	language:C	signature:(RedisModuleKey *key, double min, double max, int minex, int maxex)
RedisModule_ZsetIncrby	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetIncrby)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore);$/;"	p	language:C	signature:(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore)
RedisModule_ZsetLastInLexRange	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetLastInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max);$/;"	p	language:C	signature:(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max)
RedisModule_ZsetLastInScoreRange	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetLastInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex);$/;"	p	language:C	signature:(RedisModuleKey *key, double min, double max, int minex, int maxex)
RedisModule_ZsetRangeCurrentElement	redismodule.h	/^RedisModuleString *REDISMODULE_API_FUNC(RedisModule_ZsetRangeCurrentElement)(RedisModuleKey *key, double *score);$/;"	p	language:C	signature:(RedisModuleKey *key, double *score)
RedisModule_ZsetRangeEndReached	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetRangeEndReached)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_ZsetRangeNext	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetRangeNext)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_ZsetRangePrev	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetRangePrev)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_ZsetRangeStop	redismodule.h	/^void REDISMODULE_API_FUNC(RedisModule_ZsetRangeStop)(RedisModuleKey *key);$/;"	p	language:C	signature:(RedisModuleKey *key)
RedisModule_ZsetRem	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetRem)(RedisModuleKey *key, RedisModuleString *ele, int *deleted);$/;"	p	language:C	signature:(RedisModuleKey *key, RedisModuleString *ele, int *deleted)
RedisModule_ZsetScore	redismodule.h	/^int REDISMODULE_API_FUNC(RedisModule_ZsetScore)(RedisModuleKey *key, RedisModuleString *ele, double *score);$/;"	p	language:C	signature:(RedisModuleKey *key, RedisModuleString *ele, double *score)
S	geohash.c	/^    static const unsigned int S[] = {0, 1, 2, 4, 8, 16};$/;"	l	language:C	file:
S	geohash.c	/^    static const unsigned int S[] = {1, 2, 4, 8, 16};$/;"	l	language:C	file:
SA_ONSTACK	debug.c	/^#define SA_ONSTACK /;"	d	language:C	file:
SDS_HDR	sds.h	/^#define SDS_HDR(/;"	d	language:C
SDS_HDR_VAR	sds.h	/^#define SDS_HDR_VAR(/;"	d	language:C
SDS_LLSTR_SIZE	sds.c	/^#define SDS_LLSTR_SIZE /;"	d	language:C	file:
SDS_MAX_PREALLOC	sds.h	/^#define SDS_MAX_PREALLOC /;"	d	language:C
SDS_TYPE_16	sds.h	/^#define SDS_TYPE_16 /;"	d	language:C
SDS_TYPE_32	sds.h	/^#define SDS_TYPE_32 /;"	d	language:C
SDS_TYPE_5	sds.h	/^#define SDS_TYPE_5 /;"	d	language:C
SDS_TYPE_5_LEN	sds.h	/^#define SDS_TYPE_5_LEN(/;"	d	language:C
SDS_TYPE_64	sds.h	/^#define SDS_TYPE_64 /;"	d	language:C
SDS_TYPE_8	sds.h	/^#define SDS_TYPE_8 /;"	d	language:C
SDS_TYPE_BITS	sds.h	/^#define SDS_TYPE_BITS /;"	d	language:C
SDS_TYPE_MASK	sds.h	/^#define SDS_TYPE_MASK /;"	d	language:C
SEED	rand.c	/^#define SEED(/;"	d	language:C	file:
SENTINEL_ASK_FORCED	sentinel.c	/^#define SENTINEL_ASK_FORCED /;"	d	language:C	file:
SENTINEL_ASK_PERIOD	sentinel.c	/^#define SENTINEL_ASK_PERIOD /;"	d	language:C	file:
SENTINEL_DEFAULT_DOWN_AFTER	sentinel.c	/^#define SENTINEL_DEFAULT_DOWN_AFTER /;"	d	language:C	file:
SENTINEL_DEFAULT_FAILOVER_TIMEOUT	sentinel.c	/^#define SENTINEL_DEFAULT_FAILOVER_TIMEOUT /;"	d	language:C	file:
SENTINEL_DEFAULT_PARALLEL_SYNCS	sentinel.c	/^#define SENTINEL_DEFAULT_PARALLEL_SYNCS /;"	d	language:C	file:
SENTINEL_DEFAULT_SLAVE_PRIORITY	sentinel.c	/^#define SENTINEL_DEFAULT_SLAVE_PRIORITY /;"	d	language:C	file:
SENTINEL_ELECTION_TIMEOUT	sentinel.c	/^#define SENTINEL_ELECTION_TIMEOUT /;"	d	language:C	file:
SENTINEL_FAILOVER_STATE_NONE	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_NONE /;"	d	language:C	file:
SENTINEL_FAILOVER_STATE_RECONF_SLAVES	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_RECONF_SLAVES /;"	d	language:C	file:
SENTINEL_FAILOVER_STATE_SELECT_SLAVE	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_SELECT_SLAVE /;"	d	language:C	file:
SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE /;"	d	language:C	file:
SENTINEL_FAILOVER_STATE_UPDATE_CONFIG	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG /;"	d	language:C	file:
SENTINEL_FAILOVER_STATE_WAIT_PROMOTION	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION /;"	d	language:C	file:
SENTINEL_FAILOVER_STATE_WAIT_START	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_WAIT_START /;"	d	language:C	file:
SENTINEL_GENERATE_EVENT	sentinel.c	/^#define SENTINEL_GENERATE_EVENT /;"	d	language:C	file:
SENTINEL_HELLO_CHANNEL	sentinel.c	/^#define SENTINEL_HELLO_CHANNEL /;"	d	language:C	file:
SENTINEL_INFO_PERIOD	sentinel.c	/^#define SENTINEL_INFO_PERIOD /;"	d	language:C	file:
SENTINEL_ISQR_NOAUTH	sentinel.c	/^#define SENTINEL_ISQR_NOAUTH /;"	d	language:C	file:
SENTINEL_ISQR_NOQUORUM	sentinel.c	/^#define SENTINEL_ISQR_NOQUORUM /;"	d	language:C	file:
SENTINEL_ISQR_OK	sentinel.c	/^#define SENTINEL_ISQR_OK /;"	d	language:C	file:
SENTINEL_LEADER	sentinel.c	/^#define SENTINEL_LEADER /;"	d	language:C	file:
SENTINEL_MASTER_LINK_STATUS_DOWN	sentinel.c	/^#define SENTINEL_MASTER_LINK_STATUS_DOWN /;"	d	language:C	file:
SENTINEL_MASTER_LINK_STATUS_UP	sentinel.c	/^#define SENTINEL_MASTER_LINK_STATUS_UP /;"	d	language:C	file:
SENTINEL_MAX_DESYNC	sentinel.c	/^#define SENTINEL_MAX_DESYNC /;"	d	language:C	file:
SENTINEL_MAX_PENDING_COMMANDS	sentinel.c	/^#define SENTINEL_MAX_PENDING_COMMANDS /;"	d	language:C	file:
SENTINEL_MIN_LINK_RECONNECT_PERIOD	sentinel.c	/^#define SENTINEL_MIN_LINK_RECONNECT_PERIOD /;"	d	language:C	file:
SENTINEL_NO_FLAGS	sentinel.c	/^#define SENTINEL_NO_FLAGS /;"	d	language:C	file:
SENTINEL_OBSERVER	sentinel.c	/^#define SENTINEL_OBSERVER /;"	d	language:C	file:
SENTINEL_PING_PERIOD	sentinel.c	/^#define SENTINEL_PING_PERIOD /;"	d	language:C	file:
SENTINEL_PUBLISH_PERIOD	sentinel.c	/^#define SENTINEL_PUBLISH_PERIOD /;"	d	language:C	file:
SENTINEL_RESET_NO_SENTINELS	sentinel.c	/^#define SENTINEL_RESET_NO_SENTINELS /;"	d	language:C	file:
SENTINEL_SCRIPT_MAX_ARGS	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_ARGS /;"	d	language:C	file:
SENTINEL_SCRIPT_MAX_QUEUE	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_QUEUE /;"	d	language:C	file:
SENTINEL_SCRIPT_MAX_RETRY	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_RETRY /;"	d	language:C	file:
SENTINEL_SCRIPT_MAX_RUNNING	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_RUNNING /;"	d	language:C	file:
SENTINEL_SCRIPT_MAX_RUNTIME	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_RUNTIME /;"	d	language:C	file:
SENTINEL_SCRIPT_NONE	sentinel.c	/^#define SENTINEL_SCRIPT_NONE /;"	d	language:C	file:
SENTINEL_SCRIPT_RETRY_DELAY	sentinel.c	/^#define SENTINEL_SCRIPT_RETRY_DELAY /;"	d	language:C	file:
SENTINEL_SCRIPT_RUNNING	sentinel.c	/^#define SENTINEL_SCRIPT_RUNNING /;"	d	language:C	file:
SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION	sentinel.c	/^#define SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION /;"	d	language:C	file:
SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION	sentinel.c	/^#define SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION /;"	d	language:C	file:
SENTINEL_SIMFAILURE_NONE	sentinel.c	/^#define SENTINEL_SIMFAILURE_NONE /;"	d	language:C	file:
SENTINEL_SLAVE_RECONF_TIMEOUT	sentinel.c	/^#define SENTINEL_SLAVE_RECONF_TIMEOUT /;"	d	language:C	file:
SENTINEL_TILT_PERIOD	sentinel.c	/^#define SENTINEL_TILT_PERIOD /;"	d	language:C	file:
SENTINEL_TILT_TRIGGER	sentinel.c	/^#define SENTINEL_TILT_TRIGGER /;"	d	language:C	file:
SET3	rand.c	/^#define SET3(/;"	d	language:C	file:
SETLOW	rand.c	/^#define SETLOW(/;"	d	language:C	file:
SET_ERRNO	lzf_d.c	/^# define SET_ERRNO(/;"	d	language:C	file:
SET_OP_DIFF	server.h	/^#define SET_OP_DIFF /;"	d	language:C
SET_OP_DIFF	t_set.c	/^#define SET_OP_DIFF /;"	d	language:C	file:
SET_OP_INTER	server.h	/^#define SET_OP_INTER /;"	d	language:C
SET_OP_INTER	t_set.c	/^#define SET_OP_INTER /;"	d	language:C	file:
SET_OP_UNION	server.h	/^#define SET_OP_UNION /;"	d	language:C
SET_OP_UNION	t_set.c	/^#define SET_OP_UNION /;"	d	language:C	file:
SHA1Final	sha1.c	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context)$/;"	f	language:C	signature:(unsigned char digest[20], SHA1_CTX* context)
SHA1Final	sha1.h	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context);$/;"	p	language:C	signature:(unsigned char digest[20], SHA1_CTX* context)
SHA1HANDSOFF	sha1.c	/^#define SHA1HANDSOFF$/;"	d	language:C	file:
SHA1Init	sha1.c	/^void SHA1Init(SHA1_CTX* context)$/;"	f	language:C	signature:(SHA1_CTX* context)
SHA1Init	sha1.h	/^void SHA1Init(SHA1_CTX* context);$/;"	p	language:C	signature:(SHA1_CTX* context)
SHA1Transform	sha1.c	/^void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])$/;"	f	language:C	signature:(uint32_t state[5], const unsigned char buffer[64])
SHA1Transform	sha1.h	/^void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]);$/;"	p	language:C	signature:(uint32_t state[5], const unsigned char buffer[64])
SHA1Update	sha1.c	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)$/;"	f	language:C	signature:(SHA1_CTX* context, const unsigned char* data, uint32_t len)
SHA1Update	sha1.h	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len);$/;"	p	language:C	signature:(SHA1_CTX* context, const unsigned char* data, uint32_t len)
SHA1_CTX	sha1.h	/^} SHA1_CTX;$/;"	t	language:C	typeref:struct:__anon39
SHA1_H	sha1.h	/^#define SHA1_H$/;"	d	language:C
SHUTDOWN_NOFLAGS	server.h	/^#define SHUTDOWN_NOFLAGS /;"	d	language:C
SHUTDOWN_NOSAVE	server.h	/^#define SHUTDOWN_NOSAVE /;"	d	language:C
SHUTDOWN_SAVE	server.h	/^#define SHUTDOWN_SAVE /;"	d	language:C
SIZE_SAFETY_LIMIT	quicklist.c	/^#define SIZE_SAFETY_LIMIT /;"	d	language:C	file:
SLAVE_CAPA_EOF	server.h	/^#define SLAVE_CAPA_EOF /;"	d	language:C
SLAVE_CAPA_NONE	server.h	/^#define SLAVE_CAPA_NONE /;"	d	language:C
SLAVE_STATE_ONLINE	server.h	/^#define SLAVE_STATE_ONLINE /;"	d	language:C
SLAVE_STATE_SEND_BULK	server.h	/^#define SLAVE_STATE_SEND_BULK /;"	d	language:C
SLAVE_STATE_WAIT_BGSAVE_END	server.h	/^#define SLAVE_STATE_WAIT_BGSAVE_END /;"	d	language:C
SLAVE_STATE_WAIT_BGSAVE_START	server.h	/^#define SLAVE_STATE_WAIT_BGSAVE_START /;"	d	language:C
SLOWLOG_ENTRY_MAX_ARGC	slowlog.h	/^#define SLOWLOG_ENTRY_MAX_ARGC /;"	d	language:C
SLOWLOG_ENTRY_MAX_STRING	slowlog.h	/^#define SLOWLOG_ENTRY_MAX_STRING /;"	d	language:C
SORT_ASC	geo.c	/^#define SORT_ASC /;"	d	language:C	file:
SORT_DESC	geo.c	/^#define SORT_DESC /;"	d	language:C	file:
SORT_NONE	geo.c	/^#define SORT_NONE /;"	d	language:C	file:
SORT_OP_GET	server.h	/^#define SORT_OP_GET /;"	d	language:C
SPARKLINE_FILL	sparkline.h	/^#define SPARKLINE_FILL /;"	d	language:C
SPARKLINE_LOG_SCALE	sparkline.h	/^#define SPARKLINE_LOG_SCALE /;"	d	language:C
SPARKLINE_NO_FLAGS	sparkline.h	/^#define SPARKLINE_NO_FLAGS /;"	d	language:C
SPOP_MOVE_STRATEGY_MUL	t_set.c	/^#define SPOP_MOVE_STRATEGY_MUL /;"	d	language:C	file:
SPT	setproctitle.c	/^} SPT;$/;"	v	language:C	typeref:struct:__anon37	file:
SPT_MAXTITLE	setproctitle.c	/^#define SPT_MAXTITLE /;"	d	language:C	file:
SPT_MIN	setproctitle.c	/^#define SPT_MIN(/;"	d	language:C	file:
SRANDMEMBER_SUB_STRATEGY_MUL	t_set.c	/^#define SRANDMEMBER_SUB_STRATEGY_MUL /;"	d	language:C	file:
SRI_FAILOVER_IN_PROGRESS	sentinel.c	/^#define SRI_FAILOVER_IN_PROGRESS /;"	d	language:C	file:
SRI_FORCE_FAILOVER	sentinel.c	/^#define SRI_FORCE_FAILOVER /;"	d	language:C	file:
SRI_MASTER	sentinel.c	/^#define SRI_MASTER /;"	d	language:C	file:
SRI_MASTER_DOWN	sentinel.c	/^#define SRI_MASTER_DOWN /;"	d	language:C	file:
SRI_O_DOWN	sentinel.c	/^#define SRI_O_DOWN /;"	d	language:C	file:
SRI_PROMOTED	sentinel.c	/^#define SRI_PROMOTED /;"	d	language:C	file:
SRI_RECONF_DONE	sentinel.c	/^#define SRI_RECONF_DONE /;"	d	language:C	file:
SRI_RECONF_INPROG	sentinel.c	/^#define SRI_RECONF_INPROG /;"	d	language:C	file:
SRI_RECONF_SENT	sentinel.c	/^#define SRI_RECONF_SENT /;"	d	language:C	file:
SRI_SCRIPT_KILL_SENT	sentinel.c	/^#define SRI_SCRIPT_KILL_SENT /;"	d	language:C	file:
SRI_SENTINEL	sentinel.c	/^#define SRI_SENTINEL /;"	d	language:C	file:
SRI_SLAVE	sentinel.c	/^#define SRI_SLAVE /;"	d	language:C	file:
SRI_S_DOWN	sentinel.c	/^#define SRI_S_DOWN /;"	d	language:C	file:
STANDALONE	lzfP.h	/^#define STANDALONE /;"	d	language:C
STATS_METRIC_COMMAND	server.h	/^#define STATS_METRIC_COMMAND /;"	d	language:C
STATS_METRIC_COUNT	server.h	/^#define STATS_METRIC_COUNT /;"	d	language:C
STATS_METRIC_NET_INPUT	server.h	/^#define STATS_METRIC_NET_INPUT /;"	d	language:C
STATS_METRIC_NET_OUTPUT	server.h	/^#define STATS_METRIC_NET_OUTPUT /;"	d	language:C
STATS_METRIC_SAMPLES	server.h	/^#define STATS_METRIC_SAMPLES /;"	d	language:C
STRICT_ALIGN	lzfP.h	/^#  define STRICT_ALIGN /;"	d	language:C
STRICT_ALIGN	lzfP.h	/^#  undef STRICT_ALIGN$/;"	d	language:C
STRICT_ALIGN	lzfP.h	/^# define STRICT_ALIGN /;"	d	language:C
SUPERVISED_AUTODETECT	server.h	/^#define SUPERVISED_AUTODETECT /;"	d	language:C
SUPERVISED_NONE	server.h	/^#define SUPERVISED_NONE /;"	d	language:C
SUPERVISED_SYSTEMD	server.h	/^#define SUPERVISED_SYSTEMD /;"	d	language:C
SUPERVISED_UPSTART	server.h	/^#define SUPERVISED_UPSTART /;"	d	language:C
SWAPINIT	pqsort.c	/^#define SWAPINIT(/;"	d	language:C	file:
SYNCIO__RESOLUTION	syncio.c	/^#define SYNCIO__RESOLUTION /;"	d	language:C	file:
SYNC_CMD_FULL	replication.c	/^#define SYNC_CMD_FULL /;"	d	language:C	file:
SYNC_CMD_READ	replication.c	/^#define SYNC_CMD_READ /;"	d	language:C	file:
SYNC_CMD_WRITE	replication.c	/^#define SYNC_CMD_WRITE /;"	d	language:C	file:
T	modules/testmodule.c	/^#define T(/;"	d	language:C	file:
TEST	quicklist.c	/^#define TEST(/;"	d	language:C	file:
TEST_DESC	quicklist.c	/^#define TEST_DESC(/;"	d	language:C	file:
THPGetAnonHugePagesSize	latency.c	/^int THPGetAnonHugePagesSize(void) {$/;"	f	language:C	signature:(void)
THPIsEnabled	latency.c	/^int THPIsEnabled(void) {$/;"	f	language:C	signature:(void)
THPIsEnabled	latency.h	/^int THPIsEnabled(void);$/;"	p	language:C	signature:(void)
TYPE_HASH	redis-cli.c	/^#define TYPE_HASH /;"	d	language:C	file:
TYPE_LIST	redis-cli.c	/^#define TYPE_LIST /;"	d	language:C	file:
TYPE_NONE	redis-cli.c	/^#define TYPE_NONE /;"	d	language:C	file:
TYPE_SET	redis-cli.c	/^#define TYPE_SET /;"	d	language:C	file:
TYPE_STRING	redis-cli.c	/^#define TYPE_STRING /;"	d	language:C	file:
TYPE_ZSET	redis-cli.c	/^#define TYPE_ZSET /;"	d	language:C	file:
TestAssertIntegerReply	modules/testmodule.c	/^int TestAssertIntegerReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, long long expected) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleCallReply *reply, long long expected)
TestAssertStringReply	modules/testmodule.c	/^int TestAssertStringReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char *str, size_t len) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleCallReply *reply, char *str, size_t len)
TestCall	modules/testmodule.c	/^int TestCall(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
TestIt	modules/testmodule.c	/^int TestIt(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
TestMatchReply	modules/testmodule.c	/^int TestMatchReply(RedisModuleCallReply *reply, char *str) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply, char *str)
TestStringAppend	modules/testmodule.c	/^int TestStringAppend(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
TestStringAppendAM	modules/testmodule.c	/^int TestStringAppendAM(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
ULONG_ONEZERO	memtest.c	/^#define ULONG_ONEZERO /;"	d	language:C	file:
ULONG_ZEROONE	memtest.c	/^#define ULONG_ZEROONE /;"	d	language:C	file:
ULTRA_FAST	lzfP.h	/^# define ULTRA_FAST /;"	d	language:C
UNIT_MILLISECONDS	server.h	/^#define UNIT_MILLISECONDS /;"	d	language:C
UNIT_SECONDS	server.h	/^#define UNIT_SECONDS /;"	d	language:C
UNUSED	crc64.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	endianconv.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	intset.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	quicklist.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	redis-benchmark.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	redis-cli.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	sds.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	server.h	/^#define UNUSED(/;"	d	language:C
UNUSED	sha1.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	util.c	/^#define UNUSED(/;"	d	language:C	file:
UNUSED	zipmap.c	/^#define UNUSED(/;"	d	language:C	file:
USE_SETPROCTITLE	config.h	/^#define USE_SETPROCTITLE$/;"	d	language:C
VERY_FAST	lzfP.h	/^# define VERY_FAST /;"	d	language:C
VERY_FAST	lzfP.h	/^# undef VERY_FAST$/;"	d	language:C
X0	rand.c	/^#define X0	/;"	d	language:C	file:
X1	rand.c	/^#define X1	/;"	d	language:C	file:
X2	rand.c	/^#define X2	/;"	d	language:C	file:
ZADD_ADDED	server.h	/^#define ZADD_ADDED /;"	d	language:C
ZADD_CH	server.h	/^#define ZADD_CH /;"	d	language:C
ZADD_INCR	server.h	/^#define ZADD_INCR /;"	d	language:C
ZADD_NAN	server.h	/^#define ZADD_NAN /;"	d	language:C
ZADD_NONE	server.h	/^#define ZADD_NONE /;"	d	language:C
ZADD_NOP	server.h	/^#define ZADD_NOP /;"	d	language:C
ZADD_NX	server.h	/^#define ZADD_NX /;"	d	language:C
ZADD_UPDATED	server.h	/^#define ZADD_UPDATED /;"	d	language:C
ZADD_XX	server.h	/^#define ZADD_XX /;"	d	language:C
ZIPLIST_BYTES	ziplist.c	/^#define ZIPLIST_BYTES(/;"	d	language:C	file:
ZIPLIST_END_SIZE	ziplist.c	/^#define ZIPLIST_END_SIZE /;"	d	language:C	file:
ZIPLIST_ENTRY_END	ziplist.c	/^#define ZIPLIST_ENTRY_END(/;"	d	language:C	file:
ZIPLIST_ENTRY_HEAD	ziplist.c	/^#define ZIPLIST_ENTRY_HEAD(/;"	d	language:C	file:
ZIPLIST_ENTRY_TAIL	ziplist.c	/^#define ZIPLIST_ENTRY_TAIL(/;"	d	language:C	file:
ZIPLIST_ENTRY_ZERO	ziplist.c	/^#define ZIPLIST_ENTRY_ZERO(/;"	d	language:C	file:
ZIPLIST_HEAD	ziplist.h	/^#define ZIPLIST_HEAD /;"	d	language:C
ZIPLIST_HEADER_SIZE	ziplist.c	/^#define ZIPLIST_HEADER_SIZE /;"	d	language:C	file:
ZIPLIST_INCR_LENGTH	ziplist.c	/^#define ZIPLIST_INCR_LENGTH(/;"	d	language:C	file:
ZIPLIST_LENGTH	ziplist.c	/^#define ZIPLIST_LENGTH(/;"	d	language:C	file:
ZIPLIST_TAIL	ziplist.h	/^#define ZIPLIST_TAIL /;"	d	language:C
ZIPLIST_TAIL_OFFSET	ziplist.c	/^#define ZIPLIST_TAIL_OFFSET(/;"	d	language:C	file:
ZIPMAP_BIGLEN	zipmap.c	/^#define ZIPMAP_BIGLEN /;"	d	language:C	file:
ZIPMAP_END	zipmap.c	/^#define ZIPMAP_END /;"	d	language:C	file:
ZIPMAP_LEN_BYTES	zipmap.c	/^#define ZIPMAP_LEN_BYTES(/;"	d	language:C	file:
ZIPMAP_VALUE_MAX_FREE	zipmap.c	/^#define ZIPMAP_VALUE_MAX_FREE /;"	d	language:C	file:
ZIP_BIGLEN	ziplist.c	/^#define ZIP_BIGLEN /;"	d	language:C	file:
ZIP_DECODE_LENGTH	ziplist.c	/^#define ZIP_DECODE_LENGTH(/;"	d	language:C	file:
ZIP_DECODE_PREVLEN	ziplist.c	/^#define ZIP_DECODE_PREVLEN(/;"	d	language:C	file:
ZIP_DECODE_PREVLENSIZE	ziplist.c	/^#define ZIP_DECODE_PREVLENSIZE(/;"	d	language:C	file:
ZIP_END	ziplist.c	/^#define ZIP_END /;"	d	language:C	file:
ZIP_ENTRY_ENCODING	ziplist.c	/^#define ZIP_ENTRY_ENCODING(/;"	d	language:C	file:
ZIP_INT_16B	ziplist.c	/^#define ZIP_INT_16B /;"	d	language:C	file:
ZIP_INT_24B	ziplist.c	/^#define ZIP_INT_24B /;"	d	language:C	file:
ZIP_INT_32B	ziplist.c	/^#define ZIP_INT_32B /;"	d	language:C	file:
ZIP_INT_64B	ziplist.c	/^#define ZIP_INT_64B /;"	d	language:C	file:
ZIP_INT_8B	ziplist.c	/^#define ZIP_INT_8B /;"	d	language:C	file:
ZIP_INT_IMM_MASK	ziplist.c	/^#define ZIP_INT_IMM_MASK /;"	d	language:C	file:
ZIP_INT_IMM_MAX	ziplist.c	/^#define ZIP_INT_IMM_MAX /;"	d	language:C	file:
ZIP_INT_IMM_MIN	ziplist.c	/^#define ZIP_INT_IMM_MIN /;"	d	language:C	file:
ZIP_INT_IMM_VAL	ziplist.c	/^#define ZIP_INT_IMM_VAL(/;"	d	language:C	file:
ZIP_INT_MASK	ziplist.c	/^#define ZIP_INT_MASK /;"	d	language:C	file:
ZIP_IS_STR	ziplist.c	/^#define ZIP_IS_STR(/;"	d	language:C	file:
ZIP_STR_06B	ziplist.c	/^#define ZIP_STR_06B /;"	d	language:C	file:
ZIP_STR_14B	ziplist.c	/^#define ZIP_STR_14B /;"	d	language:C	file:
ZIP_STR_32B	ziplist.c	/^#define ZIP_STR_32B /;"	d	language:C	file:
ZIP_STR_MASK	ziplist.c	/^#define ZIP_STR_MASK /;"	d	language:C	file:
ZMALLOC_LIB	zmalloc.h	/^#define ZMALLOC_LIB /;"	d	language:C
ZRANGE_LEX	t_zset.c	/^#define ZRANGE_LEX /;"	d	language:C	file:
ZRANGE_RANK	t_zset.c	/^#define ZRANGE_RANK /;"	d	language:C	file:
ZRANGE_SCORE	t_zset.c	/^#define ZRANGE_SCORE /;"	d	language:C	file:
ZSKIPLIST_MAXLEVEL	server.h	/^#define ZSKIPLIST_MAXLEVEL /;"	d	language:C
ZSKIPLIST_P	server.h	/^#define ZSKIPLIST_P /;"	d	language:C
_ALL_SOURCE	fmacros.h	/^#define _ALL_SOURCE$/;"	d	language:C
_BSD_SOURCE	fmacros.h	/^#define _BSD_SOURCE$/;"	d	language:C
_DEFAULT_SOURCE	fmacros.h	/^#define _DEFAULT_SOURCE$/;"	d	language:C
_FILE_OFFSET_BITS	fmacros.h	/^#define _FILE_OFFSET_BITS /;"	d	language:C
_GNU_SOURCE	fmacros.h	/^#define _GNU_SOURCE$/;"	d	language:C
_GNU_SOURCE	setproctitle.c	/^#define _GNU_SOURCE$/;"	d	language:C	file:
_LARGEFILE_SOURCE	fmacros.h	/^#define _LARGEFILE_SOURCE$/;"	d	language:C
_POSIX_C_SOURCE	fmacros.h	/^#define _POSIX_C_SOURCE /;"	d	language:C
_REDIS_FMACRO_H	fmacros.h	/^#define _REDIS_FMACRO_H$/;"	d	language:C
_XOPEN_SOURCE	fmacros.h	/^#define _XOPEN_SOURCE /;"	d	language:C
_XOPEN_SOURCE	fmacros.h	/^#define _XOPEN_SOURCE$/;"	d	language:C
_ZIPLIST_H	ziplist.h	/^#define _ZIPLIST_H$/;"	d	language:C
_ZIPMAP_H	zipmap.h	/^#define _ZIPMAP_H$/;"	d	language:C
__ADLIST_H__	adlist.h	/^#define __ADLIST_H__$/;"	d	language:C
__AE_H__	ae.h	/^#define __AE_H__$/;"	d	language:C
__ATOMIC_VAR_H	atomicvar.h	/^#define __ATOMIC_VAR_H$/;"	d	language:C
__CLUSTER_H	cluster.h	/^#define __CLUSTER_H$/;"	d	language:C
__CONFIG_H	config.h	/^#define __CONFIG_H$/;"	d	language:C
__DICT_H	dict.h	/^#define __DICT_H$/;"	d	language:C
__ENDIANCONV_H	endianconv.h	/^#define __ENDIANCONV_H$/;"	d	language:C
__GEO_H__	geo.h	/^#define __GEO_H__$/;"	d	language:C
__INTSET_H	intset.h	/^#define __INTSET_H$/;"	d	language:C
__LATENCY_H	latency.h	/^#define __LATENCY_H$/;"	d	language:C
__PQSORT_H	pqsort.h	/^#define __PQSORT_H$/;"	d	language:C
__QUICKLIST_H__	quicklist.h	/^#define __QUICKLIST_H__$/;"	d	language:C
__RDB_H	rdb.h	/^#define __RDB_H$/;"	d	language:C
__REDIS_ASSERT_H__	redisassert.h	/^#define __REDIS_ASSERT_H__$/;"	d	language:C
__REDIS_H	server.h	/^#define __REDIS_H$/;"	d	language:C
__REDIS_HELP_H	help.h	/^#define __REDIS_HELP_H$/;"	d	language:C
__REDIS_RIO_H	rio.h	/^#define __REDIS_RIO_H$/;"	d	language:C
__REDIS_UTIL_H	util.h	/^#define __REDIS_UTIL_H$/;"	d	language:C
__SDS_H	sds.h	/^#define __SDS_H$/;"	d	language:C
__SPARKLINE_H	sparkline.h	/^#define __SPARKLINE_H$/;"	d	language:C
__TESTHELP_H	testhelp.h	/^#define __TESTHELP_H$/;"	d	language:C
__ZMALLOC_H	zmalloc.h	/^#define __ZMALLOC_H$/;"	d	language:C
__anon10::configEpoch	cluster.h	/^    uint64_t configEpoch;   \/* The config epoch if it's a master, or the last$/;"	m	language:C	struct:__anon10	access:public
__anon10::count	cluster.h	/^    uint16_t count;     \/* Only used for some kind of messages. *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::cport	cluster.h	/^    uint16_t cport;      \/* Sender TCP cluster bus port *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::currentEpoch	cluster.h	/^    uint64_t currentEpoch;  \/* The epoch accordingly to the sending node. *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::data	cluster.h	/^    union clusterMsgData data;$/;"	m	language:C	struct:__anon10	typeref:union:__anon10::clusterMsgData	access:public
__anon10::flags	cluster.h	/^    uint16_t flags;      \/* Sender node flags *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::mflags	cluster.h	/^    unsigned char mflags[3]; \/* Message flags: CLUSTERMSG_FLAG[012]_... *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::myip	cluster.h	/^    char myip[NET_IP_STR_LEN];    \/* Sender IP, if not all zeroed. *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::myslots	cluster.h	/^    unsigned char myslots[CLUSTER_SLOTS\/8];$/;"	m	language:C	struct:__anon10	access:public
__anon10::notused1	cluster.h	/^    char notused1[34];  \/* 34 bytes reserved for future usage. *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::offset	cluster.h	/^    uint64_t offset;    \/* Master replication offset if node is a master or$/;"	m	language:C	struct:__anon10	access:public
__anon10::port	cluster.h	/^    uint16_t port;      \/* TCP base port number. *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::sender	cluster.h	/^    char sender[CLUSTER_NAMELEN]; \/* Name of the sender node *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::sig	cluster.h	/^    char sig[4];        \/* Siganture "RCmb" (Redis Cluster message bus). *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::slaveof	cluster.h	/^    char slaveof[CLUSTER_NAMELEN];$/;"	m	language:C	struct:__anon10	access:public
__anon10::state	cluster.h	/^    unsigned char state; \/* Cluster state from the POV of the sender *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::totlen	cluster.h	/^    uint32_t totlen;    \/* Total length of this message *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::type	cluster.h	/^    uint16_t type;      \/* Message type *\/$/;"	m	language:C	struct:__anon10	access:public
__anon10::ver	cluster.h	/^    uint16_t ver;       \/* Protocol version, currently set to 0. *\/$/;"	m	language:C	struct:__anon10	access:public
__anon11::name	db.c	/^        char *name;$/;"	m	language:C	struct:__anon11	file:	access:public
__anon11::skip	db.c	/^        int skip;$/;"	m	language:C	struct:__anon11	file:	access:public
__anon14::bits	geohash.h	/^    uint64_t bits;$/;"	m	language:C	struct:__anon14	access:public
__anon14::step	geohash.h	/^    uint8_t step;$/;"	m	language:C	struct:__anon14	access:public
__anon15::max	geohash.h	/^    double max;$/;"	m	language:C	struct:__anon15	access:public
__anon15::min	geohash.h	/^    double min;$/;"	m	language:C	struct:__anon15	access:public
__anon16::hash	geohash.h	/^    GeoHashBits hash;$/;"	m	language:C	struct:__anon16	access:public
__anon16::latitude	geohash.h	/^    GeoHashRange latitude;$/;"	m	language:C	struct:__anon16	access:public
__anon16::longitude	geohash.h	/^    GeoHashRange longitude;$/;"	m	language:C	struct:__anon16	access:public
__anon17::east	geohash.h	/^    GeoHashBits east;$/;"	m	language:C	struct:__anon17	access:public
__anon17::north	geohash.h	/^    GeoHashBits north;$/;"	m	language:C	struct:__anon17	access:public
__anon17::north_east	geohash.h	/^    GeoHashBits north_east;$/;"	m	language:C	struct:__anon17	access:public
__anon17::north_west	geohash.h	/^    GeoHashBits north_west;$/;"	m	language:C	struct:__anon17	access:public
__anon17::south	geohash.h	/^    GeoHashBits south;$/;"	m	language:C	struct:__anon17	access:public
__anon17::south_east	geohash.h	/^    GeoHashBits south_east;$/;"	m	language:C	struct:__anon17	access:public
__anon17::south_west	geohash.h	/^    GeoHashBits south_west;$/;"	m	language:C	struct:__anon17	access:public
__anon17::west	geohash.h	/^    GeoHashBits west;$/;"	m	language:C	struct:__anon17	access:public
__anon18::area	geohash_helper.h	/^    GeoHashArea area;$/;"	m	language:C	struct:__anon18	access:public
__anon18::hash	geohash_helper.h	/^    GeoHashBits hash;$/;"	m	language:C	struct:__anon18	access:public
__anon18::neighbors	geohash_helper.h	/^    GeoHashNeighbors neighbors;$/;"	m	language:C	struct:__anon18	access:public
__anon1::i	bitops.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon1	file:	access:public
__anon1::u	bitops.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon1	file:	access:public
__anon20::id	module.c	/^        uint64_t id;$/;"	m	language:C	struct:__anon20	file:	access:public
__anon20::mt	module.c	/^        moduleType *mt;$/;"	m	language:C	struct:__anon20	file:	access:public
__anon21::i	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon21	file:	access:public
__anon21::u	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon21	file:	access:public
__anon22::i	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon22	file:	access:public
__anon22::u	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon22	file:	access:public
__anon23::already_expired	redis-check-rdb.c	/^    unsigned long already_expired;  \/* Number of keys already expired. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::doing	redis-check-rdb.c	/^    int doing;                      \/* The state while reading the RDB. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::error	redis-check-rdb.c	/^    char error[1024];$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::error_set	redis-check-rdb.c	/^    int error_set;                  \/* True if error is populated. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::expires	redis-check-rdb.c	/^    unsigned long expires;          \/* Number of keys with an expire. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::key	redis-check-rdb.c	/^    robj *key;                      \/* Current key we are reading. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::key_type	redis-check-rdb.c	/^    int key_type;                   \/* Current key type if != -1. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::keys	redis-check-rdb.c	/^    unsigned long keys;             \/* Number of keys processed. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
__anon23::rio	redis-check-rdb.c	/^    rio *rio;$/;"	m	language:C	struct:__anon23	file:	access:public
__anon24::argc	redis-cli.c	/^    int argc;$/;"	m	language:C	struct:__anon24	file:	access:public
__anon24::argv	redis-cli.c	/^    sds *argv;$/;"	m	language:C	struct:__anon24	file:	access:public
__anon24::full	redis-cli.c	/^    sds full;$/;"	m	language:C	struct:__anon24	file:	access:public
__anon24::org	redis-cli.c	/^    struct commandHelp *org;$/;"	m	language:C	struct:__anon24	typeref:struct:__anon24::commandHelp	file:	access:public
__anon24::type	redis-cli.c	/^    int type;$/;"	m	language:C	struct:__anon24	file:	access:public
__anon2::cport	cluster.h	/^    uint16_t cport;             \/* cluster port last time it was seen *\/$/;"	m	language:C	struct:__anon2	access:public
__anon2::flags	cluster.h	/^    uint16_t flags;             \/* node->flags copy *\/$/;"	m	language:C	struct:__anon2	access:public
__anon2::ip	cluster.h	/^    char ip[NET_IP_STR_LEN];  \/* IP address last time it was seen *\/$/;"	m	language:C	struct:__anon2	access:public
__anon2::nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN];$/;"	m	language:C	struct:__anon2	access:public
__anon2::notused1	cluster.h	/^    uint32_t notused1;$/;"	m	language:C	struct:__anon2	access:public
__anon2::ping_sent	cluster.h	/^    uint32_t ping_sent;$/;"	m	language:C	struct:__anon2	access:public
__anon2::pong_received	cluster.h	/^    uint32_t pong_received;$/;"	m	language:C	struct:__anon2	access:public
__anon2::port	cluster.h	/^    uint16_t port;              \/* base port last time it was seen *\/$/;"	m	language:C	struct:__anon2	access:public
__anon31::direction	server.h	/^    unsigned char direction; \/* Iteration direction *\/$/;"	m	language:C	struct:__anon31	access:public
__anon31::encoding	server.h	/^    unsigned char encoding;$/;"	m	language:C	struct:__anon31	access:public
__anon31::iter	server.h	/^    quicklistIter *iter;$/;"	m	language:C	struct:__anon31	access:public
__anon31::subject	server.h	/^    robj *subject;$/;"	m	language:C	struct:__anon31	access:public
__anon32::entry	server.h	/^    quicklistEntry entry; \/* Entry in quicklist *\/$/;"	m	language:C	struct:__anon32	access:public
__anon32::li	server.h	/^    listTypeIterator *li;$/;"	m	language:C	struct:__anon32	access:public
__anon33::di	server.h	/^    dictIterator *di;$/;"	m	language:C	struct:__anon33	access:public
__anon33::encoding	server.h	/^    int encoding;$/;"	m	language:C	struct:__anon33	access:public
__anon33::ii	server.h	/^    int ii; \/* intset iterator *\/$/;"	m	language:C	struct:__anon33	access:public
__anon33::subject	server.h	/^    robj *subject;$/;"	m	language:C	struct:__anon33	access:public
__anon34::de	server.h	/^    dictEntry *de;$/;"	m	language:C	struct:__anon34	access:public
__anon34::di	server.h	/^    dictIterator *di;$/;"	m	language:C	struct:__anon34	access:public
__anon34::encoding	server.h	/^    int encoding;$/;"	m	language:C	struct:__anon34	access:public
__anon34::fptr	server.h	/^    unsigned char *fptr, *vptr;$/;"	m	language:C	struct:__anon34	access:public
__anon34::subject	server.h	/^    robj *subject;$/;"	m	language:C	struct:__anon34	access:public
__anon34::vptr	server.h	/^    unsigned char *fptr, *vptr;$/;"	m	language:C	struct:__anon34	access:public
__anon35::max	server.h	/^    double min, max;$/;"	m	language:C	struct:__anon35	access:public
__anon35::maxex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon35	access:public
__anon35::min	server.h	/^    double min, max;$/;"	m	language:C	struct:__anon35	access:public
__anon35::minex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon35	access:public
__anon36::max	server.h	/^    sds min, max;     \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	language:C	struct:__anon36	access:public
__anon36::maxex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon36	access:public
__anon36::min	server.h	/^    sds min, max;     \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	language:C	struct:__anon36	access:public
__anon36::minex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon36	access:public
__anon37::arg0	setproctitle.c	/^	const char *arg0;$/;"	m	language:C	struct:__anon37	file:	access:public
__anon37::base	setproctitle.c	/^	char *base, *end;$/;"	m	language:C	struct:__anon37	file:	access:public
__anon37::end	setproctitle.c	/^	char *base, *end;$/;"	m	language:C	struct:__anon37	file:	access:public
__anon37::error	setproctitle.c	/^	int error;$/;"	m	language:C	struct:__anon37	file:	access:public
__anon37::nul	setproctitle.c	/^	char *nul;$/;"	m	language:C	struct:__anon37	file:	access:public
__anon37::reset	setproctitle.c	/^	_Bool reset;$/;"	m	language:C	struct:__anon37	file:	access:public
__anon38::c	sha1.c	/^        unsigned char c[64];$/;"	m	language:C	union:__anon38	file:	access:public
__anon38::l	sha1.c	/^        uint32_t l[16];$/;"	m	language:C	union:__anon38	file:	access:public
__anon39::buffer	sha1.h	/^    unsigned char buffer[64];$/;"	m	language:C	struct:__anon39	access:public
__anon39::count	sha1.h	/^    uint32_t count[2];$/;"	m	language:C	struct:__anon39	access:public
__anon39::state	sha1.h	/^    uint32_t state[5];$/;"	m	language:C	struct:__anon39	access:public
__anon3::nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN];$/;"	m	language:C	struct:__anon3	access:public
__anon40::__anon41::_iterset	t_zset.c	/^        union _iterset {$/;"	u	language:C	union:__anon40::__anon41	file:	access:public
__anon40::__anon41::_iterset::__anon42::ii	t_zset.c	/^                int ii;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon42	file:	access:public
__anon40::__anon41::_iterset::__anon42::is	t_zset.c	/^                intset *is;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon42	file:	access:public
__anon40::__anon41::_iterset::__anon43::de	t_zset.c	/^                dictEntry *de;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
__anon40::__anon41::_iterset::__anon43::di	t_zset.c	/^                dictIterator *di;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
__anon40::__anon41::_iterset::__anon43::dict	t_zset.c	/^                dict *dict;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
__anon40::__anon41::_iterset::ht	t_zset.c	/^            } ht;$/;"	m	language:C	union:__anon40::__anon41::_iterset	typeref:struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
__anon40::__anon41::_iterset::is	t_zset.c	/^            } is;$/;"	m	language:C	union:__anon40::__anon41::_iterset	typeref:struct:__anon40::__anon41::_iterset::__anon42	file:	access:public
__anon40::__anon41::_iterzset	t_zset.c	/^        union _iterzset {$/;"	u	language:C	union:__anon40::__anon41	file:	access:public
__anon40::__anon41::_iterzset::__anon44::eptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
__anon40::__anon41::_iterzset::__anon44::sptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
__anon40::__anon41::_iterzset::__anon44::zl	t_zset.c	/^                unsigned char *zl;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
__anon40::__anon41::_iterzset::__anon45::node	t_zset.c	/^                zskiplistNode *node;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon45	file:	access:public
__anon40::__anon41::_iterzset::__anon45::zs	t_zset.c	/^                zset *zs;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon45	file:	access:public
__anon40::__anon41::_iterzset::sl	t_zset.c	/^            } sl;$/;"	m	language:C	union:__anon40::__anon41::_iterzset	typeref:struct:__anon40::__anon41::_iterzset::__anon45	file:	access:public
__anon40::__anon41::_iterzset::zl	t_zset.c	/^            } zl;$/;"	m	language:C	union:__anon40::__anon41::_iterzset	typeref:struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
__anon40::__anon41::set	t_zset.c	/^        } set;$/;"	m	language:C	union:__anon40::__anon41	typeref:union:__anon40::__anon41::_iterset	file:	access:public
__anon40::__anon41::zset	t_zset.c	/^        } zset;$/;"	m	language:C	union:__anon40::__anon41	typeref:union:__anon40::__anon41::_iterzset	file:	access:public
__anon40::encoding	t_zset.c	/^    int encoding;$/;"	m	language:C	struct:__anon40	file:	access:public
__anon40::iter	t_zset.c	/^    } iter;$/;"	m	language:C	struct:__anon40	typeref:union:__anon40::__anon41	file:	access:public
__anon40::subject	t_zset.c	/^    robj *subject;$/;"	m	language:C	struct:__anon40	file:	access:public
__anon40::type	t_zset.c	/^    int type; \/* Set, sorted set *\/$/;"	m	language:C	struct:__anon40	file:	access:public
__anon40::weight	t_zset.c	/^    double weight;$/;"	m	language:C	struct:__anon40	file:	access:public
__anon46::_buf	t_zset.c	/^    unsigned char _buf[32]; \/* Private buffer. *\/$/;"	m	language:C	struct:__anon46	file:	access:public
__anon46::ele	t_zset.c	/^    sds ele;$/;"	m	language:C	struct:__anon46	file:	access:public
__anon46::elen	t_zset.c	/^    unsigned int elen;$/;"	m	language:C	struct:__anon46	file:	access:public
__anon46::ell	t_zset.c	/^    long long ell;$/;"	m	language:C	struct:__anon46	file:	access:public
__anon46::estr	t_zset.c	/^    unsigned char *estr;$/;"	m	language:C	struct:__anon46	file:	access:public
__anon46::flags	t_zset.c	/^    int flags;$/;"	m	language:C	struct:__anon46	file:	access:public
__anon46::score	t_zset.c	/^    double score;$/;"	m	language:C	struct:__anon46	file:	access:public
__anon4::bulk_data	cluster.h	/^    unsigned char bulk_data[8];$/;"	m	language:C	struct:__anon4	access:public
__anon4::channel_len	cluster.h	/^    uint32_t channel_len;$/;"	m	language:C	struct:__anon4	access:public
__anon4::message_len	cluster.h	/^    uint32_t message_len;$/;"	m	language:C	struct:__anon4	access:public
__anon5::configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Config epoch of the specified instance. *\/$/;"	m	language:C	struct:__anon5	access:public
__anon5::nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN]; \/* Name of the slots owner. *\/$/;"	m	language:C	struct:__anon5	access:public
__anon5::slots	cluster.h	/^    unsigned char slots[CLUSTER_SLOTS\/8]; \/* Slots bitmap. *\/$/;"	m	language:C	struct:__anon5	access:public
__failed_tests	testhelp.h	/^int __failed_tests = 0;$/;"	v	language:C
__quicklistCompress	quicklist.c	/^REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,$/;"	f	language:C	signature:(const quicklist *quicklist, quicklistNode *node)
__quicklistCompressNode	quicklist.c	/^REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {$/;"	f	language:C	signature:(quicklistNode *node)
__quicklistDecompressNode	quicklist.c	/^REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {$/;"	f	language:C	signature:(quicklistNode *node)
__quicklistDelNode	quicklist.c	/^REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistNode *node)
__quicklistInsertNode	quicklist.c	/^REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistNode *old_node, quicklistNode *new_node, int after)
__str	zmalloc.h	/^#define __str(/;"	d	language:C
__test_num	testhelp.h	/^int __test_num = 0;$/;"	v	language:C
__xstr	zmalloc.h	/^#define __xstr(/;"	d	language:C
__ziplistCascadeUpdate	ziplist.c	/^static unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {$/;"	f	language:C	file:	signature:(unsigned char *zl, unsigned char *p)
__ziplistDelete	ziplist.c	/^static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {$/;"	f	language:C	file:	signature:(unsigned char *zl, unsigned char *p, unsigned int num)
__ziplistInsert	ziplist.c	/^static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f	language:C	file:	signature:(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)
_addReplyObjectToList	networking.c	/^void _addReplyObjectToList(client *c, robj *o) {$/;"	f	language:C	signature:(client *c, robj *o)
_addReplySdsToList	networking.c	/^void _addReplySdsToList(client *c, sds s) {$/;"	f	language:C	signature:(client *c, sds s)
_addReplyStringToList	networking.c	/^void _addReplyStringToList(client *c, const char *s, size_t len) {$/;"	f	language:C	signature:(client *c, const char *s, size_t len)
_addReplyToBuffer	networking.c	/^int _addReplyToBuffer(client *c, const char *s, size_t len) {$/;"	f	language:C	signature:(client *c, const char *s, size_t len)
_anetTcpServer	anet.c	/^static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)$/;"	f	language:C	file:	signature:(char *err, int port, char *bindaddr, int af, int backlog)
_assert	intset.c	/^static void _assert(char *estr, char *file, int line) {$/;"	f	language:C	file:	signature:(char *estr, char *file, int line)
_buf	t_zset.c	/^    unsigned char _buf[32]; \/* Private buffer. *\/$/;"	m	language:C	struct:__anon46	file:	access:public
_client	redis-benchmark.c	/^typedef struct _client {$/;"	s	language:C	file:
_client::context	redis-benchmark.c	/^    redisContext *context;$/;"	m	language:C	struct:_client	file:	access:public
_client::latency	redis-benchmark.c	/^    long long latency;      \/* Request latency *\/$/;"	m	language:C	struct:_client	file:	access:public
_client::obuf	redis-benchmark.c	/^    sds obuf;$/;"	m	language:C	struct:_client	file:	access:public
_client::pending	redis-benchmark.c	/^    int pending;            \/* Number of pending requests (replies to consume) *\/$/;"	m	language:C	struct:_client	file:	access:public
_client::prefix_pending	redis-benchmark.c	/^    int prefix_pending;     \/* If non-zero, number of pending prefix commands. Commands$/;"	m	language:C	struct:_client	file:	access:public
_client::prefixlen	redis-benchmark.c	/^    int prefixlen;          \/* Size in bytes of the pending prefix commands *\/$/;"	m	language:C	struct:_client	file:	access:public
_client::randfree	redis-benchmark.c	/^    size_t randfree;        \/* Number of unused pointers in client->randptr *\/$/;"	m	language:C	struct:_client	file:	access:public
_client::randlen	redis-benchmark.c	/^    size_t randlen;         \/* Number of pointers in client->randptr *\/$/;"	m	language:C	struct:_client	file:	access:public
_client::randptr	redis-benchmark.c	/^    char **randptr;         \/* Pointers to :rand: strings inside the command buf *\/$/;"	m	language:C	struct:_client	file:	access:public
_client::start	redis-benchmark.c	/^    long long start;        \/* Start time of a request *\/$/;"	m	language:C	struct:_client	file:	access:public
_client::written	redis-benchmark.c	/^    size_t written;         \/* Bytes of 'obuf' already written *\/$/;"	m	language:C	struct:_client	file:	access:public
_dictClear	dict.c	/^int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {$/;"	f	language:C	signature:(dict *d, dictht *ht, void(callback)(void *))
_dictExpandIfNeeded	dict.c	/^static int _dictExpandIfNeeded(dict *d)$/;"	f	language:C	file:	signature:(dict *d)
_dictExpandIfNeeded	dict.c	/^static int _dictExpandIfNeeded(dict *ht);$/;"	p	language:C	file:	signature:(dict *ht)
_dictGetStatsHt	dict.c	/^size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {$/;"	f	language:C	signature:(char *buf, size_t bufsize, dictht *ht, int tableid)
_dictInit	dict.c	/^int _dictInit(dict *d, dictType *type,$/;"	f	language:C	signature:(dict *d, dictType *type, void *privDataPtr)
_dictInit	dict.c	/^static int _dictInit(dict *ht, dictType *type, void *privDataPtr);$/;"	p	language:C	file:	signature:(dict *ht, dictType *type, void *privDataPtr)
_dictKeyIndex	dict.c	/^static int _dictKeyIndex(dict *d, const void *key)$/;"	f	language:C	file:	signature:(dict *d, const void *key)
_dictKeyIndex	dict.c	/^static int _dictKeyIndex(dict *ht, const void *key);$/;"	p	language:C	file:	signature:(dict *ht, const void *key)
_dictNextPower	dict.c	/^static unsigned long _dictNextPower(unsigned long size)$/;"	f	language:C	file:	signature:(unsigned long size)
_dictNextPower	dict.c	/^static unsigned long _dictNextPower(unsigned long size);$/;"	p	language:C	file:	signature:(unsigned long size)
_dictRehashStep	dict.c	/^static void _dictRehashStep(dict *d) {$/;"	f	language:C	file:	signature:(dict *d)
_dictReset	dict.c	/^static void _dictReset(dictht *ht)$/;"	f	language:C	file:	signature:(dictht *ht)
_e	ziplist.c	/^    zlentry _e;$/;"	l	language:C
_eptr	t_zset.c	/^    unsigned char *_eptr, *_sptr;$/;"	l	language:C
_intsetGet	intset.c	/^static int64_t _intsetGet(intset *is, int pos) {$/;"	f	language:C	file:	signature:(intset *is, int pos)
_intsetGetEncoded	intset.c	/^static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {$/;"	f	language:C	file:	signature:(intset *is, int pos, uint8_t enc)
_intsetSet	intset.c	/^static void _intsetSet(intset *is, int pos, int64_t value) {$/;"	f	language:C	file:	signature:(intset *is, int pos, int64_t value)
_intsetValueEncoding	intset.c	/^static uint8_t _intsetValueEncoding(int64_t v) {$/;"	f	language:C	file:	signature:(int64_t v)
_iterset	t_zset.c	/^        union _iterset {$/;"	u	language:C	union:__anon40::__anon41	file:	access:public
_iterzset	t_zset.c	/^        union _iterzset {$/;"	u	language:C	union:__anon40::__anon41	file:	access:public
_itrprintr	quicklist.c	/^static int _itrprintr(quicklist *ql, int print, int forward) {$/;"	f	language:C	file:	signature:(quicklist *ql, int print, int forward)
_l	pqsort.c	/^                void *_l = a, *_r = ((unsigned char*)a)+r-1;$/;"	l	language:C
_l	pqsort.c	/^                void *_l, *_r;$/;"	l	language:C
_ms	cluster.c	/^    multiState *ms, _ms;$/;"	l	language:C
_port	anet.c	/^    char _port[6];  \/* strlen("65535") *\/$/;"	l	language:C
_pqsort	pqsort.c	/^_pqsort(void *a, size_t n, size_t es,$/;"	f	language:C	file:	signature:(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *), void *lrange, void *rrange)
_prefix	redis-cli.c	/^            sds _prefix;$/;"	l	language:C
_prefixfmt	redis-cli.c	/^            char _prefixfmt[16];$/;"	l	language:C
_prefixlen	redis-cli.c	/^            char _prefixlen[16];$/;"	l	language:C
_ql_verify	quicklist.c	/^static int _ql_verify(quicklist *ql, uint32_t len, uint32_t count,$/;"	f	language:C	file:	signature:(quicklist *ql, uint32_t len, uint32_t count, uint32_t head_count, uint32_t tail_count)
_quicklistInsert	quicklist.c	/^REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistEntry *entry, void *value, const size_t sz, int after)
_quicklistInsertNodeAfter	quicklist.c	/^REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistNode *old_node, quicklistNode *new_node)
_quicklistInsertNodeBefore	quicklist.c	/^REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistNode *old_node, quicklistNode *new_node)
_quicklistMergeNodes	quicklist.c	/^REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistNode *center)
_quicklistNodeAllowInsert	quicklist.c	/^REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,$/;"	f	language:C	signature:(const quicklistNode *node, const int fill, const size_t sz)
_quicklistNodeAllowMerge	quicklist.c	/^REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,$/;"	f	language:C	signature:(const quicklistNode *a, const quicklistNode *b, const int fill)
_quicklistNodeSizeMeetsOptimizationRequirement	quicklist.c	/^_quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,$/;"	f	language:C	signature:(const size_t sz, const int fill)
_quicklistSaver	quicklist.c	/^REDIS_STATIC void *_quicklistSaver(unsigned char *data, unsigned int sz) {$/;"	f	language:C	signature:(unsigned char *data, unsigned int sz)
_quicklistSplitNode	quicklist.c	/^REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,$/;"	f	language:C	signature:(quicklistNode *node, int offset, int after)
_quicklistZiplistMerge	quicklist.c	/^REDIS_STATIC quicklistNode *_quicklistZiplistMerge(quicklist *quicklist,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistNode *a, quicklistNode *b)
_r	pqsort.c	/^                void *_l = a, *_r = ((unsigned char*)a)+r-1;$/;"	l	language:C
_r	pqsort.c	/^                void *_l, *_r;$/;"	l	language:C
_redisSortObject	server.h	/^typedef struct _redisSortObject {$/;"	s	language:C
_redisSortObject::__anon30::cmpobj	server.h	/^        robj *cmpobj;$/;"	m	language:C	union:_redisSortObject::__anon30	access:public
_redisSortObject::__anon30::score	server.h	/^        double score;$/;"	m	language:C	union:_redisSortObject::__anon30	access:public
_redisSortObject::obj	server.h	/^    robj *obj;$/;"	m	language:C	struct:_redisSortObject	access:public
_redisSortObject::u	server.h	/^    } u;$/;"	m	language:C	struct:_redisSortObject	typeref:union:_redisSortObject::__anon30	access:public
_redisSortOperation	server.h	/^typedef struct _redisSortOperation {$/;"	s	language:C
_redisSortOperation::pattern	server.h	/^    robj *pattern;$/;"	m	language:C	struct:_redisSortOperation	access:public
_redisSortOperation::type	server.h	/^    int type;$/;"	m	language:C	struct:_redisSortOperation	access:public
_reply	redis-cli.c	/^    void *_reply;$/;"	l	language:C
_rfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
_rio	rio.h	/^struct _rio {$/;"	s	language:C
_rio::__anon25::__anon26::pos	rio.h	/^            off_t pos;$/;"	m	language:C	struct:_rio::__anon25::__anon26	access:public
_rio::__anon25::__anon26::ptr	rio.h	/^            sds ptr;$/;"	m	language:C	struct:_rio::__anon25::__anon26	access:public
_rio::__anon25::__anon27::autosync	rio.h	/^            off_t autosync; \/* fsync after 'autosync' bytes written. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon27	access:public
_rio::__anon25::__anon27::buffered	rio.h	/^            off_t buffered; \/* Bytes written since last fsync. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon27	access:public
_rio::__anon25::__anon27::fp	rio.h	/^            FILE *fp;$/;"	m	language:C	struct:_rio::__anon25::__anon27	access:public
_rio::__anon25::__anon28::buf	rio.h	/^            sds buf;$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
_rio::__anon25::__anon28::fds	rio.h	/^            int *fds;       \/* File descriptors. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
_rio::__anon25::__anon28::numfds	rio.h	/^            int numfds;$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
_rio::__anon25::__anon28::pos	rio.h	/^            off_t pos;$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
_rio::__anon25::__anon28::state	rio.h	/^            int *state;     \/* Error state of each fd. 0 (if ok) or errno. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
_rio::__anon25::buffer	rio.h	/^        } buffer;$/;"	m	language:C	union:_rio::__anon25	typeref:struct:_rio::__anon25::__anon26	access:public
_rio::__anon25::fdset	rio.h	/^        } fdset;$/;"	m	language:C	union:_rio::__anon25	typeref:struct:_rio::__anon25::__anon28	access:public
_rio::__anon25::file	rio.h	/^        } file;$/;"	m	language:C	union:_rio::__anon25	typeref:struct:_rio::__anon25::__anon27	access:public
_rio::cksum	rio.h	/^    uint64_t cksum;$/;"	m	language:C	struct:_rio	access:public
_rio::flush	rio.h	/^    int (*flush)(struct _rio *);$/;"	m	language:C	struct:_rio	access:public
_rio::io	rio.h	/^    } io;$/;"	m	language:C	struct:_rio	typeref:union:_rio::__anon25	access:public
_rio::max_processing_chunk	rio.h	/^    size_t max_processing_chunk;$/;"	m	language:C	struct:_rio	access:public
_rio::processed_bytes	rio.h	/^    size_t processed_bytes;$/;"	m	language:C	struct:_rio	access:public
_rio::read	rio.h	/^    size_t (*read)(struct _rio *, void *buf, size_t len);$/;"	m	language:C	struct:_rio	access:public
_rio::tell	rio.h	/^    off_t (*tell)(struct _rio *);$/;"	m	language:C	struct:_rio	access:public
_rio::update_cksum	rio.h	/^    void (*update_cksum)(struct _rio *, const void *buf, size_t len);$/;"	m	language:C	struct:_rio	access:public
_rio::write	rio.h	/^    size_t (*write)(struct _rio *, const void *buf, size_t len);$/;"	m	language:C	struct:_rio	access:public
_serverAssert	debug.c	/^void _serverAssert(const char *estr, const char *file, int line) {$/;"	f	language:C	signature:(const char *estr, const char *file, int line)
_serverAssert	redisassert.h	/^void _serverAssert(char *estr, char *file, int line);$/;"	p	language:C	signature:(char *estr, char *file, int line)
_serverAssert	server.h	/^void _serverAssert(const char *estr, const char *file, int line);$/;"	p	language:C	signature:(const char *estr, const char *file, int line)
_serverAssertPrintClientInfo	debug.c	/^void _serverAssertPrintClientInfo(const client *c) {$/;"	f	language:C	signature:(const client *c)
_serverAssertPrintObject	debug.c	/^void _serverAssertPrintObject(const robj *o) {$/;"	f	language:C	signature:(const robj *o)
_serverAssertWithInfo	debug.c	/^void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {$/;"	f	language:C	signature:(const client *c, const robj *o, const char *estr, const char *file, int line)
_serverAssertWithInfo	server.h	/^void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line);$/;"	p	language:C	signature:(const client *c, const robj *o, const char *estr, const char *file, int line)
_serverPanic	debug.c	/^void _serverPanic(const char *msg, const char *file, int line) {$/;"	f	language:C	signature:(const char *msg, const char *file, int line)
_serverPanic	server.h	/^void _serverPanic(const char *msg, const char *file, int line);$/;"	p	language:C	signature:(const char *msg, const char *file, int line)
_sptr	t_zset.c	/^    unsigned char *_eptr, *_sptr;$/;"	l	language:C
_wfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
a	bitops.c	/^        uint64_t a = value, b = incr, c;$/;"	l	language:C
a	networking.c	/^        robj *a;$/;"	l	language:C
a	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	language:C	file:
a	sha1.c	/^    uint32_t a, b, c, d, e;$/;"	l	language:C
a	t_string.c	/^        char *a = c->argv[j]->ptr;$/;"	l	language:C
about	cluster.h	/^        clusterMsgDataFail about;$/;"	m	language:C	struct:clusterMsgData::__anon7	access:public
above	modules/TYPES.md	/^As you can see from the example above, a single API call is needed in order to$/;"	v	language:C
abserr	hyperloglog.c	/^            int64_t abserr = checkpoint - (int64_t)hllCount(hdr,NULL);$/;"	l	language:C
abspath	util.c	/^    sds abspath;$/;"	l	language:C
acceptCommonHandler	networking.c	/^static void acceptCommonHandler(int fd, int flags, char *ip) {$/;"	f	language:C	file:	signature:(int fd, int flags, char *ip)
acceptHandler	server.h	/^void acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptTcpHandler	networking.c	/^void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptTcpHandler	server.h	/^void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptUnixHandler	networking.c	/^void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptUnixHandler	server.h	/^void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
access	modules/API.md	/^Prepare the key associated string value for DMA access, and returns$/;"	v	language:C
access	modules/API.md	/^access, `RM_StringDMA()` should be called again to re-obtain$/;"	v	language:C
accum	quicklist.c	/^    unsigned long long accum = 0;$/;"	l	language:C
accumulator	t_zset.c	/^        dict *accumulator = dictCreate(&setAccumulatorDictType,NULL);$/;"	l	language:C
ackreplicas	replication.c	/^    long numreplicas, ackreplicas;$/;"	l	language:C
act	debug.c	/^        struct sigaction act;$/;"	l	language:C
act	debug.c	/^    struct sigaction act;$/;"	l	language:C
act	redis-check-rdb.c	/^    struct sigaction act;$/;"	l	language:C
act	scripting.c	/^            struct sigaction act;$/;"	l	language:C
act	server.c	/^    struct sigaction act;$/;"	l	language:C
act_ping_time	sentinel.c	/^    mstime_t act_ping_time;   \/* Time at which the last pending ping (no pong$/;"	m	language:C	struct:instanceLink	file:	access:public
active	scripting.c	/^    int active; \/* Are we debugging EVAL right now? *\/$/;"	m	language:C	struct:ldbState	file:	access:public
activeExpireCycle	expire.c	/^void activeExpireCycle(int type) {$/;"	f	language:C	signature:(int type)
activeExpireCycle	server.h	/^void activeExpireCycle(int type);$/;"	p	language:C	signature:(int type)
activeExpireCycleTryExpire	expire.c	/^int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {$/;"	f	language:C	signature:(redisDb *db, dictEntry *de, long long now)
active_expire_enabled	server.h	/^    int active_expire_enabled;      \/* Can be disabled for testing purposes. *\/$/;"	m	language:C	struct:redisServer	access:public
activerehashing	server.h	/^    int activerehashing;        \/* Incremental rehash in serverCron() *\/$/;"	m	language:C	struct:redisServer	access:public
addDeferredMultiBulkLength	networking.c	/^void *addDeferredMultiBulkLength(client *c) {$/;"	f	language:C	signature:(client *c)
addDeferredMultiBulkLength	server.h	/^void *addDeferredMultiBulkLength(client *c);$/;"	p	language:C	signature:(client *c)
addHashFieldToReply	t_hash.c	/^static void addHashFieldToReply(client *c, robj *o, sds field) {$/;"	f	language:C	file:	signature:(client *c, robj *o, sds field)
addHashIteratorCursorToReply	t_hash.c	/^static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {$/;"	f	language:C	file:	signature:(client *c, hashTypeIterator *hi, int what)
addReply	networking.c	/^void addReply(client *c, robj *obj) {$/;"	f	language:C	signature:(client *c, robj *obj)
addReply	server.h	/^void addReply(client *c, robj *obj);$/;"	p	language:C	signature:(client *c, robj *obj)
addReplyBulk	networking.c	/^void addReplyBulk(client *c, robj *obj) {$/;"	f	language:C	signature:(client *c, robj *obj)
addReplyBulk	server.h	/^void addReplyBulk(client *c, robj *obj);$/;"	p	language:C	signature:(client *c, robj *obj)
addReplyBulkCBuffer	networking.c	/^void addReplyBulkCBuffer(client *c, const void *p, size_t len) {$/;"	f	language:C	signature:(client *c, const void *p, size_t len)
addReplyBulkCBuffer	server.h	/^void addReplyBulkCBuffer(client *c, const void *p, size_t len);$/;"	p	language:C	signature:(client *c, const void *p, size_t len)
addReplyBulkCString	networking.c	/^void addReplyBulkCString(client *c, const char *s) {$/;"	f	language:C	signature:(client *c, const char *s)
addReplyBulkCString	server.h	/^void addReplyBulkCString(client *c, const char *s);$/;"	p	language:C	signature:(client *c, const char *s)
addReplyBulkLen	networking.c	/^void addReplyBulkLen(client *c, robj *obj) {$/;"	f	language:C	signature:(client *c, robj *obj)
addReplyBulkLongLong	networking.c	/^void addReplyBulkLongLong(client *c, long long ll) {$/;"	f	language:C	signature:(client *c, long long ll)
addReplyBulkLongLong	server.h	/^void addReplyBulkLongLong(client *c, long long ll);$/;"	p	language:C	signature:(client *c, long long ll)
addReplyBulkSds	networking.c	/^void addReplyBulkSds(client *c, sds s)  {$/;"	f	language:C	signature:(client *c, sds s)
addReplyBulkSds	server.h	/^void addReplyBulkSds(client *c, sds s);$/;"	p	language:C	signature:(client *c, sds s)
addReplyCommand	server.c	/^void addReplyCommand(client *c, struct redisCommand *cmd) {$/;"	f	language:C	signature:(client *c, struct redisCommand *cmd)
addReplyCommandFlag	server.c	/^int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {$/;"	f	language:C	signature:(client *c, struct redisCommand *cmd, int f, char *reply)
addReplyDictOfRedisInstances	sentinel.c	/^void addReplyDictOfRedisInstances(client *c, dict *instances) {$/;"	f	language:C	signature:(client *c, dict *instances)
addReplyDouble	networking.c	/^void addReplyDouble(client *c, double d) {$/;"	f	language:C	signature:(client *c, double d)
addReplyDouble	server.h	/^void addReplyDouble(client *c, double d);$/;"	p	language:C	signature:(client *c, double d)
addReplyDoubleDistance	geo.c	/^void addReplyDoubleDistance(client *c, double d) {$/;"	f	language:C	signature:(client *c, double d)
addReplyError	networking.c	/^void addReplyError(client *c, const char *err) {$/;"	f	language:C	signature:(client *c, const char *err)
addReplyError	server.h	/^void addReplyError(client *c, const char *err);$/;"	p	language:C	signature:(client *c, const char *err)
addReplyErrorFormat	networking.c	/^void addReplyErrorFormat(client *c, const char *fmt, ...) {$/;"	f	language:C	signature:(client *c, const char *fmt, ...)
addReplyErrorFormat	server.h	/^void addReplyErrorFormat(client *c, const char *fmt, ...)$/;"	p	language:C	signature:(client *c, const char *fmt, ...)
addReplyErrorFormat	server.h	/^void addReplyErrorFormat(client *c, const char *fmt, ...);$/;"	p	language:C	signature:(client *c, const char *fmt, ...)
addReplyErrorLength	networking.c	/^void addReplyErrorLength(client *c, const char *s, size_t len) {$/;"	f	language:C	signature:(client *c, const char *s, size_t len)
addReplyHumanLongDouble	networking.c	/^void addReplyHumanLongDouble(client *c, long double d) {$/;"	f	language:C	signature:(client *c, long double d)
addReplyHumanLongDouble	server.h	/^void addReplyHumanLongDouble(client *c, long double d);$/;"	p	language:C	signature:(client *c, long double d)
addReplyLongLong	networking.c	/^void addReplyLongLong(client *c, long long ll) {$/;"	f	language:C	signature:(client *c, long long ll)
addReplyLongLong	server.h	/^void addReplyLongLong(client *c, long long ll);$/;"	p	language:C	signature:(client *c, long long ll)
addReplyLongLongWithPrefix	networking.c	/^void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {$/;"	f	language:C	signature:(client *c, long long ll, char prefix)
addReplyMultiBulkLen	networking.c	/^void addReplyMultiBulkLen(client *c, long length) {$/;"	f	language:C	signature:(client *c, long length)
addReplyMultiBulkLen	server.h	/^void addReplyMultiBulkLen(client *c, long length);$/;"	p	language:C	signature:(client *c, long length)
addReplyReplicationBacklog	replication.c	/^long long addReplyReplicationBacklog(client *c, long long offset) {$/;"	f	language:C	signature:(client *c, long long offset)
addReplySds	networking.c	/^void addReplySds(client *c, sds s) {$/;"	f	language:C	signature:(client *c, sds s)
addReplySds	server.h	/^void addReplySds(client *c, sds s);$/;"	p	language:C	signature:(client *c, sds s)
addReplySentinelRedisInstance	sentinel.c	/^void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(client *c, sentinelRedisInstance *ri)
addReplyStatus	networking.c	/^void addReplyStatus(client *c, const char *status) {$/;"	f	language:C	signature:(client *c, const char *status)
addReplyStatus	server.h	/^void addReplyStatus(client *c, const char *status);$/;"	p	language:C	signature:(client *c, const char *status)
addReplyStatusFormat	networking.c	/^void addReplyStatusFormat(client *c, const char *fmt, ...) {$/;"	f	language:C	signature:(client *c, const char *fmt, ...)
addReplyStatusFormat	server.h	/^void addReplyStatusFormat(client *c, const char *fmt, ...)$/;"	p	language:C	signature:(client *c, const char *fmt, ...)
addReplyStatusFormat	server.h	/^void addReplyStatusFormat(client *c, const char *fmt, ...);$/;"	p	language:C	signature:(client *c, const char *fmt, ...)
addReplyStatusLength	networking.c	/^void addReplyStatusLength(client *c, const char *s, size_t len) {$/;"	f	language:C	signature:(client *c, const char *s, size_t len)
addReplyString	networking.c	/^void addReplyString(client *c, const char *s, size_t len) {$/;"	f	language:C	signature:(client *c, const char *s, size_t len)
added	t_set.c	/^        unsigned long added = 0;$/;"	l	language:C
added	t_set.c	/^    int j, added = 0;$/;"	l	language:C
added	t_zset.c	/^    int added = 0;      \/* Number of new elements added. *\/$/;"	l	language:C
added_delay	cluster.c	/^            long long added_delay =$/;"	l	language:C
addr	debug.c	/^        unsigned long addr = (unsigned long) sp+i;$/;"	l	language:C
addr	networking.c	/^        char *addr = NULL;$/;"	l	language:C
addr	sentinel.c	/^            sentinelAddr *addr = sentinelGetCurrentMasterAddress(ri);$/;"	l	language:C
addr	sentinel.c	/^    sentinelAddr *addr; \/* Master host. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
addr	sentinel.c	/^    sentinelAddr *addr;$/;"	l	language:C
addresses	config.c	/^            int j, addresses = argc-1;$/;"	l	language:C
addresses	config.c	/^    sds line, addresses;$/;"	l	language:C
adjustOpenFilesLimit	server.c	/^void adjustOpenFilesLimit(void) {$/;"	f	language:C	signature:(void)
adjustOpenFilesLimit	server.h	/^void adjustOpenFilesLimit(void);$/;"	p	language:C	signature:(void)
advices	latency.c	/^    int advices = 0;$/;"	l	language:C
advise_better_vm	latency.c	/^    int advise_better_vm = 0;       \/* Better virtual machines. *\/$/;"	l	language:C
advise_data_writeback	latency.c	/^    int advise_data_writeback = 0;  \/* data=writeback. *\/$/;"	l	language:C
advise_disable_thp	latency.c	/^    int advise_disable_thp = 0;     \/* AnonHugePages detected. *\/$/;"	l	language:C
advise_disk_contention	latency.c	/^    int advise_disk_contention = 0; \/* Try to lower disk contention. *\/$/;"	l	language:C
advise_hz	latency.c	/^    int advise_hz = 0;              \/* Use higher HZ. *\/$/;"	l	language:C
advise_large_objects	latency.c	/^    int advise_large_objects = 0;   \/* Deletion of large objects. *\/$/;"	l	language:C
advise_local_disk	latency.c	/^    int advise_local_disk = 0;      \/* Avoid remote disks. *\/$/;"	l	language:C
advise_mass_eviction	latency.c	/^    int advise_mass_eviction = 0;   \/* Avoid mass eviction of keys. *\/$/;"	l	language:C
advise_no_appendfsync	latency.c	/^    int advise_no_appendfsync = 0;  \/* don't fsync during rewrites. *\/$/;"	l	language:C
advise_relax_fsync_policy	latency.c	/^    int advise_relax_fsync_policy = 0; \/* appendfsync always is slow. *\/$/;"	l	language:C
advise_scheduler	latency.c	/^    int advise_scheduler = 0;       \/* Intrinsic latency. *\/$/;"	l	language:C
advise_slowlog_enabled	latency.c	/^    int advise_slowlog_enabled = 0; \/* Enable slowlog. *\/$/;"	l	language:C
advise_slowlog_inspect	latency.c	/^    int advise_slowlog_inspect = 0; \/* Check your slowlog. *\/$/;"	l	language:C
advise_slowlog_tuning	latency.c	/^    int advise_slowlog_tuning = 0;  \/* Reconfigure slowlog. *\/$/;"	l	language:C
advise_ssd	latency.c	/^    int advise_ssd = 0;             \/* Use an SSD drive. *\/$/;"	l	language:C
advise_write_load_info	latency.c	/^    int advise_write_load_info = 0; \/* Print info about AOF and write load. *\/$/;"	l	language:C
aeAddMillisecondsToNow	ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	language:C	file:	signature:(long long milliseconds, long *sec, long *ms)
aeApiAddEvent	ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAddEvent	ae_evport.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAddEvent	ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAddEvent	ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAssociate	ae_evport.c	/^static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {$/;"	f	language:C	file:	signature:(const char *where, int portfd, int fd, int mask)
aeApiCreate	ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiCreate	ae_evport.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiCreate	ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiCreate	ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiDelEvent	ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int delmask)
aeApiDelEvent	ae_evport.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiDelEvent	ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiDelEvent	ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiFree	ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiFree	ae_evport.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiFree	ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiFree	ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeApiLookupPending	ae_evport.c	/^static int aeApiLookupPending(aeApiState *state, int fd) {$/;"	f	language:C	file:	signature:(aeApiState *state, int fd)
aeApiName	ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	language:C	file:	signature:(void)
aeApiName	ae_evport.c	/^static char *aeApiName(void) {$/;"	f	language:C	file:	signature:(void)
aeApiName	ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	language:C	file:	signature:(void)
aeApiName	ae_select.c	/^static char *aeApiName(void) {$/;"	f	language:C	file:	signature:(void)
aeApiPoll	ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiPoll	ae_evport.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiPoll	ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiPoll	ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiResize	ae_epoll.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiResize	ae_evport.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiResize	ae_kqueue.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiResize	ae_select.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiState	ae_epoll.c	/^typedef struct aeApiState {$/;"	s	language:C	file:
aeApiState	ae_epoll.c	/^} aeApiState;$/;"	t	language:C	typeref:struct:aeApiState	file:
aeApiState	ae_evport.c	/^typedef struct aeApiState {$/;"	s	language:C	file:
aeApiState	ae_evport.c	/^} aeApiState;$/;"	t	language:C	typeref:struct:aeApiState	file:
aeApiState	ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	language:C	file:
aeApiState	ae_kqueue.c	/^} aeApiState;$/;"	t	language:C	typeref:struct:aeApiState	file:
aeApiState	ae_select.c	/^typedef struct aeApiState {$/;"	s	language:C	file:
aeApiState	ae_select.c	/^} aeApiState;$/;"	t	language:C	typeref:struct:aeApiState	file:
aeApiState::_rfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::_wfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::epfd	ae_epoll.c	/^    int epfd;$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::events	ae_epoll.c	/^    struct epoll_event *events;$/;"	m	language:C	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:	access:public
aeApiState::events	ae_kqueue.c	/^    struct kevent *events;$/;"	m	language:C	struct:aeApiState	typeref:struct:aeApiState::kevent	file:	access:public
aeApiState::kqfd	ae_kqueue.c	/^    int kqfd;$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::npending	ae_evport.c	/^    int     npending;                           \/* # of pending fds *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::pending_fds	ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::pending_masks	ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::portfd	ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::rfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
aeApiState::wfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
aeBeforeSleepProc	ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t	language:C
aeCreateEventLoop	ae.c	/^aeEventLoop *aeCreateEventLoop(int setsize) {$/;"	f	language:C	signature:(int setsize)
aeCreateEventLoop	ae.h	/^aeEventLoop *aeCreateEventLoop(int setsize);$/;"	p	language:C	signature:(int setsize)
aeCreateFileEvent	ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f	language:C	signature:(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)
aeCreateFileEvent	ae.h	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	p	language:C	signature:(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)
aeCreateTimeEvent	ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f	language:C	signature:(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc)
aeCreateTimeEvent	ae.h	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	p	language:C	signature:(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc)
aeDeleteEventLoop	ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f	language:C	signature:(aeEventLoop *eventLoop)
aeDeleteEventLoop	ae.h	/^void aeDeleteEventLoop(aeEventLoop *eventLoop);$/;"	p	language:C	signature:(aeEventLoop *eventLoop)
aeDeleteFileEvent	ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f	language:C	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeDeleteFileEvent	ae.h	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);$/;"	p	language:C	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeDeleteTimeEvent	ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f	language:C	signature:(aeEventLoop *eventLoop, long long id)
aeDeleteTimeEvent	ae.h	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);$/;"	p	language:C	signature:(aeEventLoop *eventLoop, long long id)
aeEventFinalizerProc	ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t	language:C
aeEventLoop	ae.h	/^struct aeEventLoop;$/;"	x	language:C
aeEventLoop	ae.h	/^typedef struct aeEventLoop {$/;"	s	language:C
aeEventLoop	ae.h	/^} aeEventLoop;$/;"	t	language:C	typeref:struct:aeEventLoop
aeEventLoop::apidata	ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::beforesleep	ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::events	ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::fired	ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::lastTime	ae.h	/^    time_t lastTime;     \/* Used to detect system clock skew *\/$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::maxfd	ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::setsize	ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::stop	ae.h	/^    int stop;$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::timeEventHead	ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	language:C	struct:aeEventLoop	access:public
aeEventLoop::timeEventNextId	ae.h	/^    long long timeEventNextId;$/;"	m	language:C	struct:aeEventLoop	access:public
aeFileEvent	ae.h	/^typedef struct aeFileEvent {$/;"	s	language:C
aeFileEvent	ae.h	/^} aeFileEvent;$/;"	t	language:C	typeref:struct:aeFileEvent
aeFileEvent::clientData	ae.h	/^    void *clientData;$/;"	m	language:C	struct:aeFileEvent	access:public
aeFileEvent::mask	ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	language:C	struct:aeFileEvent	access:public
aeFileEvent::rfileProc	ae.h	/^    aeFileProc *rfileProc;$/;"	m	language:C	struct:aeFileEvent	access:public
aeFileEvent::wfileProc	ae.h	/^    aeFileProc *wfileProc;$/;"	m	language:C	struct:aeFileEvent	access:public
aeFileProc	ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t	language:C
aeFiredEvent	ae.h	/^typedef struct aeFiredEvent {$/;"	s	language:C
aeFiredEvent	ae.h	/^} aeFiredEvent;$/;"	t	language:C	typeref:struct:aeFiredEvent
aeFiredEvent::fd	ae.h	/^    int fd;$/;"	m	language:C	struct:aeFiredEvent	access:public
aeFiredEvent::mask	ae.h	/^    int mask;$/;"	m	language:C	struct:aeFiredEvent	access:public
aeGetApiName	ae.c	/^char *aeGetApiName(void) {$/;"	f	language:C	signature:(void)
aeGetApiName	ae.h	/^char *aeGetApiName(void);$/;"	p	language:C	signature:(void)
aeGetFileEvents	ae.c	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {$/;"	f	language:C	signature:(aeEventLoop *eventLoop, int fd)
aeGetFileEvents	ae.h	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd);$/;"	p	language:C	signature:(aeEventLoop *eventLoop, int fd)
aeGetSetSize	ae.c	/^int aeGetSetSize(aeEventLoop *eventLoop) {$/;"	f	language:C	signature:(aeEventLoop *eventLoop)
aeGetSetSize	ae.h	/^int aeGetSetSize(aeEventLoop *eventLoop);$/;"	p	language:C	signature:(aeEventLoop *eventLoop)
aeGetTime	ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	language:C	file:	signature:(long *seconds, long *milliseconds)
aeMain	ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f	language:C	signature:(aeEventLoop *eventLoop)
aeMain	ae.h	/^void aeMain(aeEventLoop *eventLoop);$/;"	p	language:C	signature:(aeEventLoop *eventLoop)
aeProcessEvents	ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f	language:C	signature:(aeEventLoop *eventLoop, int flags)
aeProcessEvents	ae.h	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags);$/;"	p	language:C	signature:(aeEventLoop *eventLoop, int flags)
aeResizeSetSize	ae.c	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {$/;"	f	language:C	signature:(aeEventLoop *eventLoop, int setsize)
aeResizeSetSize	ae.h	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);$/;"	p	language:C	signature:(aeEventLoop *eventLoop, int setsize)
aeSearchNearestTimer	ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
aeSetBeforeSleepProc	ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f	language:C	signature:(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)
aeSetBeforeSleepProc	ae.h	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);$/;"	p	language:C	signature:(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)
aeStop	ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f	language:C	signature:(aeEventLoop *eventLoop)
aeStop	ae.h	/^void aeStop(aeEventLoop *eventLoop);$/;"	p	language:C	signature:(aeEventLoop *eventLoop)
aeTimeEvent	ae.h	/^typedef struct aeTimeEvent {$/;"	s	language:C
aeTimeEvent	ae.h	/^} aeTimeEvent;$/;"	t	language:C	typeref:struct:aeTimeEvent
aeTimeEvent::clientData	ae.h	/^    void *clientData;$/;"	m	language:C	struct:aeTimeEvent	access:public
aeTimeEvent::finalizerProc	ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	language:C	struct:aeTimeEvent	access:public
aeTimeEvent::id	ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	language:C	struct:aeTimeEvent	access:public
aeTimeEvent::next	ae.h	/^    struct aeTimeEvent *next;$/;"	m	language:C	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent	access:public
aeTimeEvent::timeProc	ae.h	/^    aeTimeProc *timeProc;$/;"	m	language:C	struct:aeTimeEvent	access:public
aeTimeEvent::when_ms	ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	language:C	struct:aeTimeEvent	access:public
aeTimeEvent::when_sec	ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	language:C	struct:aeTimeEvent	access:public
aeTimeProc	ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t	language:C
aeWait	ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f	language:C	signature:(int fd, int mask, long long milliseconds)
aeWait	ae.h	/^int aeWait(int fd, int mask, long long milliseconds);$/;"	p	language:C	signature:(int fd, int mask, long long milliseconds)
aggregate	t_zset.c	/^    int aggregate = REDIS_AGGR_SUM;$/;"	l	language:C
alen	object.c	/^    size_t alen, blen, minlen;$/;"	l	language:C
alen	server.c	/^    unsigned int alen = strlen(a);$/;"	l	language:C
algo_one_work	t_set.c	/^        long long algo_one_work = 0, algo_two_work = 0;$/;"	l	language:C
algo_two_work	t_set.c	/^        long long algo_one_work = 0, algo_two_work = 0;$/;"	l	language:C
alignment	module.c	/^        size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;$/;"	l	language:C
all_time_high	latency.h	/^    uint32_t all_time_high; \/* Absolute max observed since latest reset. *\/$/;"	m	language:C	struct:latencyStats	access:public
allcator	modules/TYPES.md	/^* Redis uses the `jemalloc` allcator, that often prevents fragmentation problems that could be caused by using the libc allocator.$/;"	v	language:C
allkeys	db.c	/^    int plen = sdslen(pattern), allkeys;$/;"	l	language:C
alloc	sds.c	/^    size_t alloc = sdsalloc(s);$/;"	l	language:C
alloc	sds.h	/^    uint16_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr16	access:public
alloc	sds.h	/^    uint32_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr32	access:public
alloc	sds.h	/^    uint64_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr64	access:public
alloc	sds.h	/^    uint8_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr8	access:public
allocate	modules/TYPES.md	/^in order to allocate, reallocate and release heap memory used to implement the native data structures (see the other Redis Modules documentation for detailed information).$/;"	v	language:C
allsections	sentinel.c	/^    int defsections = 0, allsections = 0;$/;"	l	language:C
allsections	server.c	/^    int allsections = 0, defsections = 0;$/;"	l	language:C
alpha	hyperloglog.c	/^    double E, alpha = 0.7213\/(1+1.079\/m);$/;"	l	language:C
alpha	sort.c	/^    int desc = 0, alpha = 0;$/;"	l	language:C
already_expired	redis-check-rdb.c	/^    unsigned long already_expired;  \/* Number of keys already expired. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
alsoPropagate	server.c	/^void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f	language:C	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target)
alsoPropagate	server.h	/^void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target);$/;"	p	language:C	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target)
also_propagate	server.h	/^    redisOpArray also_propagate;    \/* Additional command to propagate. *\/$/;"	m	language:C	struct:redisServer	access:public
alternative	modules/INTRO.md	/^management, covered later in this document, can be a good alternative, by$/;"	v	language:C
among_minority_time	cluster.c	/^    static mstime_t among_minority_time;$/;"	l	language:C	file:
amqueue	module.c	/^    struct AutoMemEntry *amqueue;   \/* Auto memory queue of objects to free. *\/$/;"	m	language:C	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::AutoMemEntry	file:	access:public
amqueue_len	module.c	/^    int amqueue_len;                \/* Number of slots in amqueue. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
amqueue_used	module.c	/^    int amqueue_used;               \/* Number of used slots in amqueue. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
analyzeLatencyForEvent	latency.c	/^void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {$/;"	f	language:C	signature:(char *event, struct latencyStats *ls)
anetBlock	anet.c	/^int anetBlock(char *err, int fd) {$/;"	f	language:C	signature:(char *err, int fd)
anetBlock	anet.h	/^int anetBlock(char *err, int fd);$/;"	p	language:C	signature:(char *err, int fd)
anetCreateSocket	anet.c	/^static int anetCreateSocket(char *err, int domain) {$/;"	f	language:C	file:	signature:(char *err, int domain)
anetDisableTcpNoDelay	anet.c	/^int anetDisableTcpNoDelay(char *err, int fd)$/;"	f	language:C	signature:(char *err, int fd)
anetDisableTcpNoDelay	anet.h	/^int anetDisableTcpNoDelay(char *err, int fd);$/;"	p	language:C	signature:(char *err, int fd)
anetEnableTcpNoDelay	anet.c	/^int anetEnableTcpNoDelay(char *err, int fd)$/;"	f	language:C	signature:(char *err, int fd)
anetEnableTcpNoDelay	anet.h	/^int anetEnableTcpNoDelay(char *err, int fd);$/;"	p	language:C	signature:(char *err, int fd)
anetFormatAddr	anet.c	/^int anetFormatAddr(char *buf, size_t buf_len, char *ip, int port) {$/;"	f	language:C	signature:(char *buf, size_t buf_len, char *ip, int port)
anetFormatAddr	anet.h	/^int anetFormatAddr(char *fmt, size_t fmt_len, char *ip, int port);$/;"	p	language:C	signature:(char *fmt, size_t fmt_len, char *ip, int port)
anetFormatPeer	anet.c	/^int anetFormatPeer(int fd, char *buf, size_t buf_len) {$/;"	f	language:C	signature:(int fd, char *buf, size_t buf_len)
anetFormatPeer	anet.h	/^int anetFormatPeer(int fd, char *fmt, size_t fmt_len);$/;"	p	language:C	signature:(int fd, char *fmt, size_t fmt_len)
anetFormatSock	anet.c	/^int anetFormatSock(int fd, char *fmt, size_t fmt_len) {$/;"	f	language:C	signature:(int fd, char *fmt, size_t fmt_len)
anetFormatSock	anet.h	/^int anetFormatSock(int fd, char *fmt, size_t fmt_len);$/;"	p	language:C	signature:(int fd, char *fmt, size_t fmt_len)
anetGenericAccept	anet.c	/^static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {$/;"	f	language:C	file:	signature:(char *err, int s, struct sockaddr *sa, socklen_t *len)
anetGenericResolve	anet.c	/^int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,$/;"	f	language:C	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len, int flags)
anetKeepAlive	anet.c	/^int anetKeepAlive(char *err, int fd, int interval)$/;"	f	language:C	signature:(char *err, int fd, int interval)
anetKeepAlive	anet.h	/^int anetKeepAlive(char *err, int fd, int interval);$/;"	p	language:C	signature:(char *err, int fd, int interval)
anetListen	anet.c	/^static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {$/;"	f	language:C	file:	signature:(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog)
anetNonBlock	anet.c	/^int anetNonBlock(char *err, int fd) {$/;"	f	language:C	signature:(char *err, int fd)
anetNonBlock	anet.h	/^int anetNonBlock(char *err, int fd);$/;"	p	language:C	signature:(char *err, int fd)
anetPeerToString	anet.c	/^int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {$/;"	f	language:C	signature:(int fd, char *ip, size_t ip_len, int *port)
anetPeerToString	anet.h	/^int anetPeerToString(int fd, char *ip, size_t ip_len, int *port);$/;"	p	language:C	signature:(int fd, char *ip, size_t ip_len, int *port)
anetRead	anet.c	/^int anetRead(int fd, char *buf, int count)$/;"	f	language:C	signature:(int fd, char *buf, int count)
anetRead	anet.h	/^int anetRead(int fd, char *buf, int count);$/;"	p	language:C	signature:(int fd, char *buf, int count)
anetResolve	anet.c	/^int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len) {$/;"	f	language:C	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetResolve	anet.h	/^int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len);$/;"	p	language:C	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetResolveIP	anet.c	/^int anetResolveIP(char *err, char *host, char *ipbuf, size_t ipbuf_len) {$/;"	f	language:C	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetResolveIP	anet.h	/^int anetResolveIP(char *err, char *host, char *ipbuf, size_t ipbuf_len);$/;"	p	language:C	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetSendTimeout	anet.c	/^int anetSendTimeout(char *err, int fd, long long ms) {$/;"	f	language:C	signature:(char *err, int fd, long long ms)
anetSendTimeout	anet.h	/^int anetSendTimeout(char *err, int fd, long long ms);$/;"	p	language:C	signature:(char *err, int fd, long long ms)
anetSetBlock	anet.c	/^int anetSetBlock(char *err, int fd, int non_block) {$/;"	f	language:C	signature:(char *err, int fd, int non_block)
anetSetError	anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	language:C	file:	signature:(char *err, const char *fmt, ...)
anetSetReuseAddr	anet.c	/^static int anetSetReuseAddr(char *err, int fd) {$/;"	f	language:C	file:	signature:(char *err, int fd)
anetSetSendBuffer	anet.c	/^int anetSetSendBuffer(char *err, int fd, int buffsize)$/;"	f	language:C	signature:(char *err, int fd, int buffsize)
anetSetTcpNoDelay	anet.c	/^static int anetSetTcpNoDelay(char *err, int fd, int val)$/;"	f	language:C	file:	signature:(char *err, int fd, int val)
anetSockName	anet.c	/^int anetSockName(int fd, char *ip, size_t ip_len, int *port) {$/;"	f	language:C	signature:(int fd, char *ip, size_t ip_len, int *port)
anetSockName	anet.h	/^int anetSockName(int fd, char *ip, size_t ip_len, int *port);$/;"	p	language:C	signature:(int fd, char *ip, size_t ip_len, int *port)
anetTcp6Server	anet.c	/^int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)$/;"	f	language:C	signature:(char *err, int port, char *bindaddr, int backlog)
anetTcp6Server	anet.h	/^int anetTcp6Server(char *err, int port, char *bindaddr, int backlog);$/;"	p	language:C	signature:(char *err, int port, char *bindaddr, int backlog)
anetTcpAccept	anet.c	/^int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {$/;"	f	language:C	signature:(char *err, int s, char *ip, size_t ip_len, int *port)
anetTcpAccept	anet.h	/^int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port);$/;"	p	language:C	signature:(char *err, int serversock, char *ip, size_t ip_len, int *port)
anetTcpConnect	anet.c	/^int anetTcpConnect(char *err, char *addr, int port)$/;"	f	language:C	signature:(char *err, char *addr, int port)
anetTcpConnect	anet.h	/^int anetTcpConnect(char *err, char *addr, int port);$/;"	p	language:C	signature:(char *err, char *addr, int port)
anetTcpGenericConnect	anet.c	/^static int anetTcpGenericConnect(char *err, char *addr, int port,$/;"	f	language:C	file:	signature:(char *err, char *addr, int port, char *source_addr, int flags)
anetTcpKeepAlive	anet.c	/^int anetTcpKeepAlive(char *err, int fd)$/;"	f	language:C	signature:(char *err, int fd)
anetTcpKeepAlive	anet.h	/^int anetTcpKeepAlive(char *err, int fd);$/;"	p	language:C	signature:(char *err, int fd)
anetTcpNonBlockBestEffortBindConnect	anet.c	/^int anetTcpNonBlockBestEffortBindConnect(char *err, char *addr, int port,$/;"	f	language:C	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockBestEffortBindConnect	anet.h	/^int anetTcpNonBlockBestEffortBindConnect(char *err, char *addr, int port, char *source_addr);$/;"	p	language:C	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockBindConnect	anet.c	/^int anetTcpNonBlockBindConnect(char *err, char *addr, int port,$/;"	f	language:C	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockBindConnect	anet.h	/^int anetTcpNonBlockBindConnect(char *err, char *addr, int port, char *source_addr);$/;"	p	language:C	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockConnect	anet.c	/^int anetTcpNonBlockConnect(char *err, char *addr, int port)$/;"	f	language:C	signature:(char *err, char *addr, int port)
anetTcpNonBlockConnect	anet.h	/^int anetTcpNonBlockConnect(char *err, char *addr, int port);$/;"	p	language:C	signature:(char *err, char *addr, int port)
anetTcpServer	anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr, int backlog)$/;"	f	language:C	signature:(char *err, int port, char *bindaddr, int backlog)
anetTcpServer	anet.h	/^int anetTcpServer(char *err, int port, char *bindaddr, int backlog);$/;"	p	language:C	signature:(char *err, int port, char *bindaddr, int backlog)
anetUnixAccept	anet.c	/^int anetUnixAccept(char *err, int s) {$/;"	f	language:C	signature:(char *err, int s)
anetUnixAccept	anet.h	/^int anetUnixAccept(char *err, int serversock);$/;"	p	language:C	signature:(char *err, int serversock)
anetUnixConnect	anet.c	/^int anetUnixConnect(char *err, char *path)$/;"	f	language:C	signature:(char *err, char *path)
anetUnixConnect	anet.h	/^int anetUnixConnect(char *err, char *path);$/;"	p	language:C	signature:(char *err, char *path)
anetUnixGenericConnect	anet.c	/^int anetUnixGenericConnect(char *err, char *path, int flags)$/;"	f	language:C	signature:(char *err, char *path, int flags)
anetUnixNonBlockConnect	anet.c	/^int anetUnixNonBlockConnect(char *err, char *path)$/;"	f	language:C	signature:(char *err, char *path)
anetUnixNonBlockConnect	anet.h	/^int anetUnixNonBlockConnect(char *err, char *path);$/;"	p	language:C	signature:(char *err, char *path)
anetUnixServer	anet.c	/^int anetUnixServer(char *err, char *path, mode_t perm, int backlog)$/;"	f	language:C	signature:(char *err, char *path, mode_t perm, int backlog)
anetUnixServer	anet.h	/^int anetUnixServer(char *err, char *path, mode_t perm, int backlog);$/;"	p	language:C	signature:(char *err, char *path, mode_t perm, int backlog)
anetV6Only	anet.c	/^static int anetV6Only(char *err, int s) {$/;"	f	language:C	file:	signature:(char *err, int s)
anetWrite	anet.c	/^int anetWrite(int fd, char *buf, int count)$/;"	f	language:C	signature:(int fd, char *buf, int count)
anetWrite	anet.h	/^int anetWrite(int fd, char *buf, int count);$/;"	p	language:C	signature:(int fd, char *buf, int count)
aneterr	redis-cli.c	/^    char aneterr[ANET_ERR_LEN];$/;"	l	language:C
announce_ip	sentinel.c	/^    char *announce_ip;  \/* IP addr that is gossiped to other sentinels if$/;"	m	language:C	struct:sentinelState	file:	access:public
announce_ip	sentinel.c	/^    char *announce_ip;$/;"	l	language:C
announce_port	sentinel.c	/^    int announce_port;  \/* Port that is gossiped to other sentinels if$/;"	m	language:C	struct:sentinelState	file:	access:public
announce_port	sentinel.c	/^    int announce_port;$/;"	l	language:C
announced_cport	cluster.c	/^    int announced_cport = server.cluster_announce_bus_port ?$/;"	l	language:C
announced_port	cluster.c	/^    int announced_port = server.cluster_announce_port ?$/;"	l	language:C
aof	aof.c	/^    rio aof;$/;"	l	language:C
aofChildPipeReadable	aof.c	/^void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
aofChildWriteDiffData	aof.c	/^void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
aofClosePipes	aof.c	/^void aofClosePipes(void) {$/;"	f	language:C	signature:(void)
aofClosePipes	aof.c	/^void aofClosePipes(void);$/;"	p	language:C	file:	signature:(void)
aofCreatePipes	aof.c	/^int aofCreatePipes(void) {$/;"	f	language:C	signature:(void)
aofReadDiffFromParent	aof.c	/^ssize_t aofReadDiffFromParent(void) {$/;"	f	language:C	signature:(void)
aofRemoveTempFile	aof.c	/^void aofRemoveTempFile(pid_t childpid) {$/;"	f	language:C	signature:(pid_t childpid)
aofRemoveTempFile	server.h	/^void aofRemoveTempFile(pid_t childpid);$/;"	p	language:C	signature:(pid_t childpid)
aofRewriteBufferAppend	aof.c	/^void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {$/;"	f	language:C	signature:(unsigned char *s, unsigned long len)
aofRewriteBufferReset	aof.c	/^void aofRewriteBufferReset(void) {$/;"	f	language:C	signature:(void)
aofRewriteBufferReset	server.h	/^void aofRewriteBufferReset(void);$/;"	p	language:C	signature:(void)
aofRewriteBufferSize	aof.c	/^unsigned long aofRewriteBufferSize(void) {$/;"	f	language:C	signature:(void)
aofRewriteBufferSize	server.h	/^unsigned long aofRewriteBufferSize(void);$/;"	p	language:C	signature:(void)
aofRewriteBufferWrite	aof.c	/^ssize_t aofRewriteBufferWrite(int fd) {$/;"	f	language:C	signature:(int fd)
aofUpdateCurrentSize	aof.c	/^void aofUpdateCurrentSize(void) {$/;"	f	language:C	signature:(void)
aofUpdateCurrentSize	aof.c	/^void aofUpdateCurrentSize(void);$/;"	p	language:C	file:	signature:(void)
aof_background_fsync	aof.c	/^void aof_background_fsync(int fd) {$/;"	f	language:C	signature:(int fd)
aof_buf	server.h	/^    sds aof_buf;      \/* AOF buffer, written before entering the event loop *\/$/;"	m	language:C	struct:redisServer	access:public
aof_child_diff	server.h	/^    sds aof_child_diff;             \/* AOF diff accumulator child side. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_child_pid	server.h	/^    pid_t aof_child_pid;            \/* PID if rewriting process *\/$/;"	m	language:C	struct:redisServer	access:public
aof_current_size	server.h	/^    off_t aof_current_size;         \/* AOF current size. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_delayed_fsync	server.h	/^    unsigned long aof_delayed_fsync;  \/* delayed AOF fsync() counter *\/$/;"	m	language:C	struct:redisServer	access:public
aof_fd	server.h	/^    int aof_fd;       \/* File descriptor of currently selected AOF file *\/$/;"	m	language:C	struct:redisServer	access:public
aof_filename	server.h	/^    char *aof_filename;             \/* Name of the AOF file *\/$/;"	m	language:C	struct:redisServer	access:public
aof_flush_postponed_start	server.h	/^    time_t aof_flush_postponed_start; \/* UNIX time of postponed AOF flush *\/$/;"	m	language:C	struct:redisServer	access:public
aof_fsync	config.h	/^#define aof_fsync /;"	d	language:C
aof_fsync	server.h	/^    int aof_fsync;                  \/* Kind of fsync() policy *\/$/;"	m	language:C	struct:redisServer	access:public
aof_fsync_enum	config.c	/^configEnum aof_fsync_enum[] = {$/;"	v	language:C
aof_last_fsync	server.h	/^    time_t aof_last_fsync;            \/* UNIX time of last fsync() *\/$/;"	m	language:C	struct:redisServer	access:public
aof_last_write_errno	server.h	/^    int aof_last_write_errno;       \/* Valid if aof_last_write_status is ERR *\/$/;"	m	language:C	struct:redisServer	access:public
aof_last_write_status	server.h	/^    int aof_last_write_status;      \/* C_OK or C_ERR *\/$/;"	m	language:C	struct:redisServer	access:public
aof_lastbgrewrite_status	server.h	/^    int aof_lastbgrewrite_status;   \/* C_OK or C_ERR *\/$/;"	m	language:C	struct:redisServer	access:public
aof_load_truncated	server.h	/^    int aof_load_truncated;         \/* Don't stop on unexpected AOF EOF. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_no_fsync_on_rewrite	server.h	/^    int aof_no_fsync_on_rewrite;    \/* Don't fsync if a rewrite is in prog. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_pipe_read_ack_from_child	server.h	/^    int aof_pipe_read_ack_from_child;$/;"	m	language:C	struct:redisServer	access:public
aof_pipe_read_ack_from_parent	server.h	/^    int aof_pipe_read_ack_from_parent;$/;"	m	language:C	struct:redisServer	access:public
aof_pipe_read_data_from_parent	server.h	/^    int aof_pipe_read_data_from_parent;$/;"	m	language:C	struct:redisServer	access:public
aof_pipe_write_ack_to_child	server.h	/^    int aof_pipe_write_ack_to_child;$/;"	m	language:C	struct:redisServer	access:public
aof_pipe_write_ack_to_parent	server.h	/^    int aof_pipe_write_ack_to_parent;$/;"	m	language:C	struct:redisServer	access:public
aof_pipe_write_data_to_child	server.h	/^    int aof_pipe_write_data_to_child;$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite	modules/TYPES.md	/^The remaining arguments `rdb_load`, `rdb_save`, `aof_rewrite`, `digest` and$/;"	v	language:C
aof_rewrite	server.h	/^    moduleTypeRewriteFunc aof_rewrite;$/;"	m	language:C	struct:RedisModuleType	access:public
aof_rewrite_base_size	server.h	/^    off_t aof_rewrite_base_size;    \/* AOF size on latest startup or rewrite. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite_buf_blocks	server.h	/^    list *aof_rewrite_buf_blocks;   \/* Hold changes during an AOF rewrite. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite_incremental_fsync	server.h	/^    int aof_rewrite_incremental_fsync;\/* fsync incrementally while rewriting? *\/$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite_min_size	server.h	/^    off_t aof_rewrite_min_size;     \/* the AOF file is at least N bytes. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite_perc	server.h	/^    int aof_rewrite_perc;           \/* Rewrite AOF if % growth is > M and... *\/$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite_scheduled	server.h	/^    int aof_rewrite_scheduled;      \/* Rewrite once BGSAVE terminates. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite_time_last	server.h	/^    time_t aof_rewrite_time_last;   \/* Time used by last AOF rewrite run. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_rewrite_time_start	server.h	/^    time_t aof_rewrite_time_start;  \/* Current AOF rewrite start time. *\/$/;"	m	language:C	struct:redisServer	access:public
aof_selected_db	server.h	/^    int aof_selected_db; \/* Currently selected DB in AOF *\/$/;"	m	language:C	struct:redisServer	access:public
aof_state	server.h	/^    int aof_state;                  \/* AOF_(ON|OFF|WAIT_REWRITE) *\/$/;"	m	language:C	struct:redisServer	access:public
aof_stop_sending_diff	server.h	/^    int aof_stop_sending_diff;     \/* If true stop sending accumulated diffs$/;"	m	language:C	struct:redisServer	access:public
aofrwblock	aof.c	/^typedef struct aofrwblock {$/;"	s	language:C	file:
aofrwblock	aof.c	/^} aofrwblock;$/;"	t	language:C	typeref:struct:aofrwblock	file:
aofrwblock::buf	aof.c	/^    char buf[AOF_RW_BUF_BLOCK_SIZE];$/;"	m	language:C	struct:aofrwblock	file:	access:public
aofrwblock::free	aof.c	/^    unsigned long used, free;$/;"	m	language:C	struct:aofrwblock	file:	access:public
aofrwblock::used	aof.c	/^    unsigned long used, free;$/;"	m	language:C	struct:aofrwblock	file:	access:public
ap	anet.c	/^    va_list ap;$/;"	l	language:C
ap	module.c	/^    va_list ap;$/;"	l	language:C
ap	networking.c	/^    va_list ap;$/;"	l	language:C
ap	rdb.c	/^    va_list ap;$/;"	l	language:C
ap	redis-check-rdb.c	/^    va_list ap;$/;"	l	language:C
ap	redis-cli.c	/^    va_list ap;$/;"	l	language:C
ap	replication.c	/^        va_list ap;$/;"	l	language:C
ap	sds.c	/^    va_list ap;$/;"	l	language:C
ap	sentinel.c	/^    va_list ap;$/;"	l	language:C
ap	server.c	/^    va_list ap;$/;"	l	language:C
ap	setproctitle.c	/^	va_list ap;$/;"	l	language:C
apidata	ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	language:C	struct:aeEventLoop	access:public
apiver	module.c	/^    int apiver;     \/* Module API version as requested during initialization.*\/$/;"	m	language:C	struct:RedisModule	file:	access:public
append	t_string.c	/^    robj *o, *append;$/;"	l	language:C
append	ziplist.c	/^    int append;$/;"	l	language:C
appendCommand	server.h	/^void appendCommand(client *c);$/;"	p	language:C	signature:(client *c)
appendCommand	t_string.c	/^void appendCommand(client *c) {$/;"	f	language:C	signature:(client *c)
appendServerSaveParams	config.c	/^void appendServerSaveParams(time_t seconds, int changes) {$/;"	f	language:C	signature:(time_t seconds, int changes)
appendServerSaveParams	server.h	/^void appendServerSaveParams(time_t seconds, int changes);$/;"	p	language:C	signature:(time_t seconds, int changes)
ar	scripting.c	/^    lua_Debug ar;$/;"	l	language:C
arch_bits	server.h	/^    int arch_bits;              \/* 32 or 64 depending on sizeof(long) *\/$/;"	m	language:C	struct:redisServer	access:public
area	geohash.c	/^    GeoHashArea area = {{0}};$/;"	l	language:C
area	geohash_helper.c	/^    GeoHashArea area;$/;"	l	language:C
area	geohash_helper.h	/^    GeoHashArea area;$/;"	m	language:C	struct:__anon18	access:public
arg	bio.c	/^        void *arg = (void*)(unsigned long) j;$/;"	l	language:C
arg	debug.c	/^        char *arg;$/;"	l	language:C
arg	geo.c	/^            char *arg = c->argv[base_args + i]->ptr;$/;"	l	language:C
arg	redis-cli.c	/^    sds arg = sdsempty();$/;"	l	language:C
arg	replication.c	/^        char *arg;$/;"	l	language:C
arg	scripting.c	/^            char *arg = argv[j];$/;"	l	language:C
arg0	setproctitle.c	/^	const char *arg0;$/;"	m	language:C	struct:__anon37	file:	access:public
arg1	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	language:C	struct:bio_job	file:	access:public
arg2	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	language:C	struct:bio_job	file:	access:public
arg3	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	language:C	struct:bio_job	file:	access:public
argc	aof.c	/^        int argc, j;$/;"	l	language:C
argc	cluster.c	/^        int argc;$/;"	l	language:C
argc	config.c	/^        int argc;$/;"	l	language:C
argc	geo.c	/^    int argc = 2+elements*2; \/* ZADD key score ele ... *\/$/;"	l	language:C
argc	module.c	/^        int argc = 0;$/;"	l	language:C
argc	module.c	/^    int argc = 0, argv_size, j;$/;"	l	language:C
argc	module.c	/^    int argc = 0, flags = 0, j;$/;"	l	language:C
argc	module.c	/^    int argc = 0, flags = 0;$/;"	l	language:C
argc	networking.c	/^    int argc, j;$/;"	l	language:C
argc	redis-check-aof.c	/^    long argc;$/;"	l	language:C
argc	redis-cli.c	/^            int argc;$/;"	l	language:C
argc	redis-cli.c	/^    int argc;$/;"	l	language:C
argc	redis-cli.c	/^    int argc;$/;"	m	language:C	struct:__anon24	file:	access:public
argc	redis-cli.c	/^    int i, argc, buflen = strlen(buf);$/;"	l	language:C
argc	scripting.c	/^    int argc = 0;$/;"	l	language:C
argc	scripting.c	/^    int argc = lua_gettop(lua);$/;"	l	language:C
argc	scripting.c	/^    int argc;$/;"	l	language:C
argc	scripting.c	/^    int j, argc = lua_gettop(lua);$/;"	l	language:C
argc	sentinel.c	/^    int argc = 1;$/;"	l	language:C
argc	server.h	/^    int argc, dbid, target;$/;"	m	language:C	struct:redisOp	access:public
argc	server.h	/^    int argc;               \/* Num of arguments of current command. *\/$/;"	m	language:C	struct:client	access:public
argc	server.h	/^    int argc;$/;"	m	language:C	struct:moduleLoadQueueEntry	access:public
argc	server.h	/^    int argc;$/;"	m	language:C	struct:multiCmd	access:public
argc	slowlog.h	/^    int argc;$/;"	m	language:C	struct:slowlogEntry	access:public
args	redis-cli.c	/^        int args = llabs(entry->element[1]->integer);$/;"	l	language:C
argsds	aof.c	/^        sds argsds;$/;"	l	language:C
argument	modules/INTRO.md	/^number "10" as second argument (the increment), I'll use the following$/;"	p	language:C	file:	signature:(the increment)
argument	modules/TYPES.md	/^with the 10 bits encoding version as argument, so that the module knows$/;"	v	language:C
arguments	modules/INTRO.md	/^of arguments, as passed by the user.$/;"	v	language:C
argv	aof.c	/^        robj **argv;$/;"	l	language:C
argv	aof.c	/^    robj *argv[3];$/;"	l	language:C
argv	cluster.c	/^        sds *argv;$/;"	l	language:C
argv	config.c	/^        sds *argv;$/;"	l	language:C
argv	db.c	/^    robj *argv[2];$/;"	l	language:C
argv	geo.c	/^    robj **argv = zcalloc(argc*sizeof(robj*));$/;"	l	language:C
argv	module.c	/^        robj **argv = NULL;$/;"	l	language:C
argv	module.c	/^    robj **argv = NULL;$/;"	l	language:C
argv	modules/INTRO.md	/^a string received in the argument vector `argv`, which is an array$/;"	v	language:C
argv	networking.c	/^    robj **argv; \/* The new argument vector *\/$/;"	l	language:C
argv	networking.c	/^    sds *argv, aux;$/;"	l	language:C
argv	rdb.c	/^        char *argv[2] = {"",server.rdb_filename};$/;"	l	language:C
argv	redis-benchmark.c	/^            const char *argv[21];$/;"	l	language:C
argv	redis-cli.c	/^            sds *argv;$/;"	l	language:C
argv	redis-cli.c	/^        sds *argv = sds_malloc(sizeof(sds)*2);$/;"	l	language:C
argv	redis-cli.c	/^    sds *argv = sdssplitargs(buf,&argc);$/;"	l	language:C
argv	redis-cli.c	/^    sds *argv;$/;"	l	language:C
argv	redis-cli.c	/^    sds *argv;$/;"	m	language:C	struct:__anon24	file:	access:public
argv	scripting.c	/^    sds *argv = NULL;$/;"	l	language:C
argv	scripting.c	/^    sds *argv;$/;"	l	language:C
argv	scripting.c	/^    static robj **argv = NULL;$/;"	l	language:C	file:
argv	sentinel.c	/^    char **argv;            \/* Arguments to call the script. *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
argv	sentinel.c	/^    char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];$/;"	l	language:C
argv	server.c	/^        robj *argv[3];$/;"	l	language:C
argv	server.h	/^    robj **argv;            \/* Arguments of current command. *\/$/;"	m	language:C	struct:client	access:public
argv	server.h	/^    robj **argv;$/;"	m	language:C	struct:moduleLoadQueueEntry	access:public
argv	server.h	/^    robj **argv;$/;"	m	language:C	struct:multiCmd	access:public
argv	server.h	/^    robj **argv;$/;"	m	language:C	struct:redisOp	access:public
argv	slowlog.h	/^    robj **argv;$/;"	m	language:C	struct:slowlogEntry	access:public
argv	t_list.c	/^    robj *argv[3];$/;"	l	language:C
argv2	redis-cli.c	/^    char **argv2;$/;"	l	language:C
argv_size	module.c	/^    int argc = 0, argv_size, j;$/;"	l	language:C
argv_size	scripting.c	/^    static int argv_size = 0;$/;"	l	language:C	file:
argvcopy	server.c	/^    robj **argvcopy;$/;"	l	language:C
argvlen	redis-cli.c	/^    size_t *argvlen;$/;"	l	language:C
arity	server.h	/^    int arity;$/;"	m	language:C	struct:redisCommand	access:public
around	scripting.c	/^            int around = ldb.currentline, ctx = 5;$/;"	l	language:C
array	geo.h	/^    struct geoPoint *array;$/;"	m	language:C	struct:geoArray	typeref:struct:geoArray::geoPoint	access:public
array	module.c	/^        struct RedisModuleCallReply *array; \/* Array of sub-reply elements. *\/$/;"	m	language:C	union:RedisModuleCallReply::__anon19	typeref:struct:RedisModuleCallReply::__anon19::RedisModuleCallReply	file:	access:public
array	modules/API.md	/^of items we are going to output as elements of the array, this function$/;"	v	language:C
arraylen	module.c	/^    long long arraylen, j;$/;"	l	language:C
arraylen	modules/hellotype.c	/^    long long arraylen = 0;$/;"	l	language:C
arraylen	modules/helloworld.c	/^    int arraylen = 0;$/;"	l	language:C
arrsize	redis-cli.c	/^    unsigned int arrsize=0, i;$/;"	l	language:C
ascii_logo	asciilogo.h	/^char *ascii_logo =$/;"	v	language:C
askingCommand	cluster.c	/^void askingCommand(client *c) {$/;"	f	language:C	signature:(client *c)
askingCommand	server.h	/^void askingCommand(client *c);$/;"	p	language:C	signature:(client *c)
assert	intset.c	/^#define assert(/;"	d	language:C	file:
assert	quicklist.c	/^#define assert(/;"	d	language:C	file:
assert	redisassert.h	/^#define assert(/;"	d	language:C
assert_failed	server.h	/^    const char *assert_failed;$/;"	m	language:C	struct:redisServer	access:public
assert_file	server.h	/^    const char *assert_file;$/;"	m	language:C	struct:redisServer	access:public
assert_line	server.h	/^    int assert_line;$/;"	m	language:C	struct:redisServer	access:public
astr	object.c	/^    char bufa[128], bufb[128], *astr, *bstr;$/;"	l	language:C
async	db.c	/^    int j, async = (flags & EMPTYDB_ASYNC);$/;"	l	language:C
asyncCloseClientOnOutputBufferLimitReached	networking.c	/^void asyncCloseClientOnOutputBufferLimitReached(client *c) {$/;"	f	language:C	signature:(client *c)
asyncCloseClientOnOutputBufferLimitReached	server.h	/^void asyncCloseClientOnOutputBufferLimitReached(client *c);$/;"	p	language:C	signature:(client *c)
at_head	quicklist.c	/^    int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;$/;"	l	language:C
at_tail	quicklist.c	/^    int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;$/;"	l	language:C
atoi	server.c	/^                memtest(atoi(argv[2]),50);$/;"	p	language:C	file:	signature:(argv[2])
atoi	ziplist.c	/^        srand(atoi(argv[1]));$/;"	p	language:C	file:	signature:(argv[1])
atomicDecr	atomicvar.h	/^#define atomicDecr(/;"	d	language:C
atomicGet	atomicvar.h	/^#define atomicGet(/;"	d	language:C
atomicIncr	atomicvar.h	/^#define atomicIncr(/;"	d	language:C
attempted_compress	quicklist.h	/^    unsigned int attempted_compress : 1; \/* node can't compress; too small *\/$/;"	m	language:C	struct:quicklistNode	access:public
attr	bio.c	/^    pthread_attr_t attr;$/;"	l	language:C
auth	redis-benchmark.c	/^    char *auth;$/;"	m	language:C	struct:config	file:	access:public
auth	redis-cli.c	/^    char *auth;$/;"	m	language:C	struct:config	file:	access:public
authCommand	server.c	/^void authCommand(client *c) {$/;"	f	language:C	signature:(client *c)
authCommand	server.h	/^void authCommand(client *c);$/;"	p	language:C	signature:(client *c)
auth_age	cluster.c	/^    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;$/;"	l	language:C
auth_pass	sentinel.c	/^    char *auth_pass = (ri->flags & SRI_MASTER) ? ri->auth_pass :$/;"	l	language:C
auth_pass	sentinel.c	/^    char *auth_pass;    \/* Password to use for AUTH against master & slaves. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
auth_retry_time	cluster.c	/^    mstime_t auth_timeout, auth_retry_time;$/;"	l	language:C
auth_timeout	cluster.c	/^    mstime_t auth_timeout, auth_retry_time;$/;"	l	language:C
authenticated	server.h	/^    int authenticated;      \/* When requirepass is non-NULL. *\/$/;"	m	language:C	struct:client	access:public
autoMemoryAdd	module.c	/^void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, int type, void *ptr)
autoMemoryCollect	module.c	/^void autoMemoryCollect(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
autoMemoryCollect	module.c	/^void autoMemoryCollect(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
autoMemoryFreed	module.c	/^int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, int type, void *ptr)
autosync	rio.h	/^            off_t autosync; \/* fsync after 'autosync' bytes written. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon27	access:public
aux	config.c	/^            sds aux = sdsnew("# ??? ");$/;"	l	language:C
aux	config.c	/^        sds aux = sdsjoin(server.bindaddr,server.bindaddr_count," ");$/;"	l	language:C
aux	debug.c	/^    uint32_t aux;$/;"	l	language:C
aux	expire.c	/^        robj *aux;$/;"	l	language:C
aux	hyperloglog.c	/^    int aux;$/;"	l	language:C
aux	networking.c	/^    sds *argv, aux;$/;"	l	language:C
aux	redis-cli.c	/^    long aux, requests = 0;$/;"	l	language:C
aux	replication.c	/^        char aux[LONG_STR_SIZE+3];$/;"	l	language:C
aux	sds.c	/^    char *p, aux;$/;"	l	language:C
aux	t_hash.c	/^        sds aux;$/;"	l	language:C
aux	t_hash.c	/^    robj *aux, *newobj;$/;"	l	language:C
aux	t_set.c	/^    robj *set, *ele, *aux;$/;"	l	language:C
aux	t_string.c	/^    robj *o, *new, *aux;$/;"	l	language:C
aux1	bitops.c	/^        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;$/;"	l	language:C
aux2	bitops.c	/^        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;$/;"	l	language:C
aux3	bitops.c	/^        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;$/;"	l	language:C
aux4	bitops.c	/^        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;$/;"	l	language:C
aux5	bitops.c	/^        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;$/;"	l	language:C
aux6	bitops.c	/^        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;$/;"	l	language:C
aux7	bitops.c	/^        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;$/;"	l	language:C
auxentry	dict.c	/^    dictEntry *entry, auxentry;$/;"	l	language:C
auxkey	rdb.c	/^            robj *auxkey, *auxval;$/;"	l	language:C
auxkey	redis-check-rdb.c	/^            robj *auxkey, *auxval;$/;"	l	language:C
auxval	rdb.c	/^            robj *auxkey, *auxval;$/;"	l	language:C
auxval	redis-check-rdb.c	/^            robj *auxkey, *auxval;$/;"	l	language:C
avail	sds.c	/^    size_t avail = sdsavail(s);$/;"	l	language:C
available	networking.c	/^    size_t available = sizeof(c->buf)-c->bufpos;$/;"	l	language:C
avg	debug.c	/^            double avg = (double)ql->count\/ql->len;$/;"	l	language:C
avg	latency.h	/^    uint32_t avg;           \/* Average of current samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
avg	redis-cli.c	/^    double avg;$/;"	l	language:C
avg_ns	redis-cli.c	/^        double avg_ns = avg_us * 1e3;$/;"	l	language:C
avg_ttl	expire.c	/^                long long avg_ttl = ttl_sum\/ttl_samples;$/;"	l	language:C
avg_ttl	server.h	/^    long long avg_ttl;          \/* Average TTL, just for stats *\/$/;"	m	language:C	struct:redisDb	access:public
avg_us	redis-cli.c	/^        double avg_us = (double)run_time\/runs;$/;"	l	language:C
b	anet.c	/^    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;$/;"	l	language:C
b	bitops.c	/^        uint64_t a = value, b = incr, c;$/;"	l	language:C
b	debug.c	/^    char buf[65], *b;$/;"	l	language:C
b	sha1.c	/^    uint32_t a, b, c, d, e;$/;"	l	language:C
background	server.c	/^    int background = server.daemonize && !server.supervised;$/;"	l	language:C
backgroundRewriteDoneHandler	aof.c	/^void backgroundRewriteDoneHandler(int exitcode, int bysignal) {$/;"	f	language:C	signature:(int exitcode, int bysignal)
backgroundRewriteDoneHandler	server.h	/^void backgroundRewriteDoneHandler(int exitcode, int bysignal);$/;"	p	language:C	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandler	rdb.c	/^void backgroundSaveDoneHandler(int exitcode, int bysignal) {$/;"	f	language:C	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandler	rdb.h	/^void backgroundSaveDoneHandler(int exitcode, int bysignal);$/;"	p	language:C	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandlerDisk	rdb.c	/^void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {$/;"	f	language:C	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandlerSocket	rdb.c	/^void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {$/;"	f	language:C	signature:(int exitcode, int bysignal)
backup	memtest.c	/^    unsigned long backup[MEMTEST_BACKUP_WORDS];$/;"	l	language:C
backward	server.h	/^    struct zskiplistNode *backward;$/;"	m	language:C	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode	access:public
base	quicklist.c	/^        quicklistIter *base = quicklistGetIterator(quicklist, direction);$/;"	l	language:C
base	server.c	/^            long long base = server.aof_rewrite_base_size ?$/;"	l	language:C
base	setproctitle.c	/^	char *base, *end, *nul, *tmp;$/;"	l	language:C
base	setproctitle.c	/^	char *base, *end;$/;"	m	language:C	struct:__anon37	file:	access:public
base_args	geo.c	/^    int base_args;$/;"	l	language:C
baseval	evict.c	/^    double baseval = counter - LFU_INIT_VAL;$/;"	l	language:C
beforeSleep	server.c	/^void beforeSleep(struct aeEventLoop *eventLoop) {$/;"	f	language:C	signature:(struct aeEventLoop *eventLoop)
beforesleep	ae.c	/^            eventLoop->beforesleep(eventLoop);$/;"	p	language:C	file:
beforesleep	ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	language:C	struct:aeEventLoop	access:public
benchmark	redis-benchmark.c	/^static void benchmark(char *title, char *cmd, int len) {$/;"	f	language:C	file:	signature:(char *title, char *cmd, int len)
bestdbid	evict.c	/^        int bestdbid;$/;"	l	language:C
bestkey	evict.c	/^        sds bestkey = NULL;$/;"	l	language:C
bestlimit	server.c	/^            rlim_t bestlimit;$/;"	l	language:C
bgrewriteaofCommand	aof.c	/^void bgrewriteaofCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bgrewriteaofCommand	server.h	/^void bgrewriteaofCommand(client *c);$/;"	p	language:C	signature:(client *c)
bgsaveCommand	rdb.c	/^void bgsaveCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bgsaveCommand	server.h	/^void bgsaveCommand(client *c);$/;"	p	language:C	signature:(client *c)
bgsaveerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
bias	hyperloglog.c	/^        double bias = 5.9119*1.0e-18*(E*E*E*E)$/;"	l	language:C
bib	networking.c	/^    unsigned long lol = 0, bib = 0;$/;"	l	language:C
bib	server.c	/^    unsigned long lol, bib;$/;"	l	language:C
biggest	redis-cli.c	/^    unsigned long long biggest[5] = {0}, counts[5] = {0}, totalsize[5] = {0};$/;"	l	language:C
bigkeys	redis-cli.c	/^    int bigkeys;$/;"	m	language:C	struct:config	file:	access:public
bindaddr	server.h	/^    char *bindaddr[CONFIG_BINDADDR_MAX]; \/* Addresses we should bind to *\/$/;"	m	language:C	struct:redisServer	access:public
bindaddr_count	server.h	/^    int bindaddr_count;         \/* Number of addresses in server.bindaddr[] *\/$/;"	m	language:C	struct:redisServer	access:public
bioCreateBackgroundJob	bio.c	/^void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {$/;"	f	language:C	signature:(int type, void *arg1, void *arg2, void *arg3)
bioCreateBackgroundJob	bio.h	/^void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3);$/;"	p	language:C	signature:(int type, void *arg1, void *arg2, void *arg3)
bioInit	bio.c	/^void bioInit(void) {$/;"	f	language:C	signature:(void)
bioInit	bio.h	/^void bioInit(void);$/;"	p	language:C	signature:(void)
bioKillThreads	bio.c	/^void bioKillThreads(void) {$/;"	f	language:C	signature:(void)
bioKillThreads	bio.h	/^void bioKillThreads(void);$/;"	p	language:C	signature:(void)
bioOlderJobOfType	bio.h	/^time_t bioOlderJobOfType(int type);$/;"	p	language:C	signature:(int type)
bioPendingJobsOfType	bio.c	/^unsigned long long bioPendingJobsOfType(int type) {$/;"	f	language:C	signature:(int type)
bioPendingJobsOfType	bio.h	/^unsigned long long bioPendingJobsOfType(int type);$/;"	p	language:C	signature:(int type)
bioProcessBackgroundJobs	bio.c	/^void *bioProcessBackgroundJobs(void *arg) {$/;"	f	language:C	signature:(void *arg)
bioProcessBackgroundJobs	bio.c	/^void *bioProcessBackgroundJobs(void *arg);$/;"	p	language:C	file:	signature:(void *arg)
bioWaitStepOfType	bio.c	/^unsigned long long bioWaitStepOfType(int type) {$/;"	f	language:C	signature:(int type)
bioWaitStepOfType	bio.h	/^unsigned long long bioWaitStepOfType(int type);$/;"	p	language:C	signature:(int type)
bio_job	bio.c	/^struct bio_job {$/;"	s	language:C	file:
bio_job::arg1	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	language:C	struct:bio_job	file:	access:public
bio_job::arg2	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	language:C	struct:bio_job	file:	access:public
bio_job::arg3	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	language:C	struct:bio_job	file:	access:public
bio_job::time	bio.c	/^    time_t time; \/* Time at which the job was created. *\/$/;"	m	language:C	struct:bio_job	file:	access:public
bio_jobs	bio.c	/^static list *bio_jobs[BIO_NUM_OPS];$/;"	v	language:C	file:
bio_mutex	bio.c	/^static pthread_mutex_t bio_mutex[BIO_NUM_OPS];$/;"	v	language:C	file:
bio_newjob_cond	bio.c	/^static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS];$/;"	v	language:C	file:
bio_pending	bio.c	/^static unsigned long long bio_pending[BIO_NUM_OPS];$/;"	v	language:C	file:
bio_step_cond	bio.c	/^static pthread_cond_t bio_step_cond[BIO_NUM_OPS];$/;"	v	language:C	file:
bio_threads	bio.c	/^static pthread_t bio_threads[BIO_NUM_OPS];$/;"	v	language:C	file:
bit	bitops.c	/^    long bit, start, end, strlen;$/;"	l	language:C
bit	bitops.c	/^    size_t byte, bit;$/;"	l	language:C
bit	bitops.c	/^    ssize_t byte, bit;$/;"	l	language:C
bit	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j, value = 0;$/;"	l	language:C
bit	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j;$/;"	l	language:C
bit	cluster.c	/^            int bit, i;$/;"	l	language:C
bit	cluster.c	/^        int bit;$/;"	l	language:C
bit	cluster.c	/^    int bit = pos&7;$/;"	l	language:C
bit	hyperloglog.c	/^    uint64_t hash, bit, index;$/;"	l	language:C
bitcountCommand	bitops.c	/^void bitcountCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bitcountCommand	server.h	/^void bitcountCommand(client *c);$/;"	p	language:C	signature:(client *c)
bitcounters	hyperloglog.c	/^    sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);$/;"	l	language:C
bitfieldCommand	bitops.c	/^void bitfieldCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bitfieldCommand	server.h	/^void bitfieldCommand(client *c);$/;"	p	language:C	signature:(client *c)
bitfieldOp	bitops.c	/^struct bitfieldOp {$/;"	s	language:C	file:
bitfieldOp::bits	bitops.c	/^    int bits;           \/* Integer bitfield bits width. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
bitfieldOp::i64	bitops.c	/^    int64_t i64;        \/* Increment amount (INCRBY) or SET value *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
bitfieldOp::offset	bitops.c	/^    uint64_t offset;    \/* Bitfield offset. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
bitfieldOp::opcode	bitops.c	/^    int opcode;         \/* Operation id. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
bitfieldOp::owtype	bitops.c	/^    int owtype;         \/* Overflow type to use. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
bitfieldOp::sign	bitops.c	/^    int sign;           \/* True if signed, otherwise unsigned op. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
bitmapClearBit	cluster.c	/^void bitmapClearBit(unsigned char *bitmap, int pos) {$/;"	f	language:C	signature:(unsigned char *bitmap, int pos)
bitmapSetBit	cluster.c	/^void bitmapSetBit(unsigned char *bitmap, int pos) {$/;"	f	language:C	signature:(unsigned char *bitmap, int pos)
bitmapTestBit	cluster.c	/^int bitmapTestBit(unsigned char *bitmap, int pos) {$/;"	f	language:C	signature:(unsigned char *bitmap, int pos)
bitmapTestBit	cluster.c	/^int bitmapTestBit(unsigned char *bitmap, int pos);$/;"	p	language:C	file:	signature:(unsigned char *bitmap, int pos)
bitoffset	bitops.c	/^    size_t bitoffset;$/;"	l	language:C
bitopCommand	bitops.c	/^void bitopCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bitopCommand	server.h	/^void bitopCommand(client *c);$/;"	p	language:C	signature:(client *c)
bitposCommand	bitops.c	/^void bitposCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bitposCommand	server.h	/^void bitposCommand(client *c);$/;"	p	language:C	signature:(client *c)
bits	bitops.c	/^        int bits = 0; \/* Bitfield width in bits. *\/$/;"	l	language:C
bits	bitops.c	/^    int bits;           \/* Integer bitfield bits width. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
bits	bitops.c	/^    size_t bits = 0;$/;"	l	language:C
bits	geo.c	/^        GeoHashFix52Bits bits = geohashAlign52Bits(hash);$/;"	l	language:C
bits	geohash.h	/^    uint64_t bits;$/;"	m	language:C	struct:__anon14	access:public
bits	geohash_helper.c	/^    uint64_t bits = hash.bits;$/;"	l	language:C
bits	intset.c	/^        int i, bits = 20;$/;"	l	language:C
bits	modules/TYPES.md	/^10 bits, and searches for a matching module in the modules types cache.$/;"	v	language:C
bits	modules/TYPES.md	/^easily store 9 characters of 6 bits, and you are left with 10 bits, that$/;"	v	language:C
bitsinbyte	bitops.c	/^    static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};$/;"	l	language:C	file:
bitval	bitops.c	/^    int byteval, bitval;$/;"	l	language:C
bitval	bitops.c	/^    size_t bitval = 0;$/;"	l	language:C
bitval	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j, value = 0;$/;"	l	language:C
bitval	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j;$/;"	l	language:C
blen	debug.c	/^        int blen = 0;$/;"	l	language:C
blen	object.c	/^    size_t alen, blen, minlen;$/;"	l	language:C
blen	server.c	/^    unsigned int blen = strlen(b);$/;"	l	language:C
blenp	debug.c	/^        void *blenp = addDeferredMultiBulkLength(c);$/;"	l	language:C
blk	sha1.c	/^#define blk(/;"	d	language:C	file:
blk0	sha1.c	/^#define blk0(/;"	d	language:C	file:
block	aof.c	/^        aofrwblock *block = listNodeValue(ln);$/;"	l	language:C
block	aof.c	/^    aofrwblock *block = ln ? ln->value : NULL;$/;"	l	language:C
block	aof.c	/^    aofrwblock *block;$/;"	l	language:C
block	sha1.c	/^    CHAR64LONG16 block[1];  \/* use array to appear as a pointer *\/$/;"	l	language:C
block	sha1.c	/^    CHAR64LONG16* block = (const CHAR64LONG16*)buffer;$/;"	l	language:C
blockClient	blocked.c	/^void blockClient(client *c, int btype) {$/;"	f	language:C	signature:(client *c, int btype)
blockClient	server.h	/^void blockClient(client *c, int btype);$/;"	p	language:C	signature:(client *c, int btype)
blockForKeys	t_list.c	/^void blockForKeys(client *c, robj **keys, int numkeys, mstime_t timeout, robj *target) {$/;"	f	language:C	signature:(client *c, robj **keys, int numkeys, mstime_t timeout, robj *target)
blockingPopGenericCommand	t_list.c	/^void blockingPopGenericCommand(client *c, int where) {$/;"	f	language:C	signature:(client *c, int where)
blockingState	server.h	/^typedef struct blockingState {$/;"	s	language:C
blockingState	server.h	/^} blockingState;$/;"	t	language:C	typeref:struct:blockingState
blockingState::keys	server.h	/^    dict *keys;             \/* The keys we are waiting to terminate a blocking$/;"	m	language:C	struct:blockingState	access:public
blockingState::numreplicas	server.h	/^    int numreplicas;        \/* Number of replicas we are waiting for ACK. *\/$/;"	m	language:C	struct:blockingState	access:public
blockingState::reploffset	server.h	/^    long long reploffset;   \/* Replication offset to reach. *\/$/;"	m	language:C	struct:blockingState	access:public
blockingState::target	server.h	/^    robj *target;           \/* The key that should receive the element,$/;"	m	language:C	struct:blockingState	access:public
blockingState::timeout	server.h	/^    mstime_t timeout;       \/* Blocking operation timeout. If UNIX current time$/;"	m	language:C	struct:blockingState	access:public
blocking_keys	server.h	/^    dict *blocking_keys;        \/* Keys with clients waiting for data (BLPOP)*\/$/;"	m	language:C	struct:redisDb	access:public
blocksize	module.c	/^        size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;$/;"	l	language:C
blpopCommand	server.h	/^void blpopCommand(client *c);$/;"	p	language:C	signature:(client *c)
blpopCommand	t_list.c	/^void blpopCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bold	redis-cli.c	/^    int bold = strstr(color,"bold") != NULL;$/;"	l	language:C
bound	anet.c	/^            int bound = 0;$/;"	l	language:C
bounds	geohash_helper.c	/^    double bounds[4];$/;"	l	language:C
bp	scripting.c	/^    int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;$/;"	l	language:C
bp	scripting.c	/^    int bp = ldbIsBreakpoint(lnum);$/;"	l	language:C
bp	scripting.c	/^    int bp[LDB_BREAKPOINTS_MAX]; \/* An array of breakpoints line numbers. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
bpcount	scripting.c	/^    int bpcount; \/* Number of valid entries inside bp. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
bpop	server.h	/^    blockingState bpop;     \/* blocking state *\/$/;"	m	language:C	struct:client	access:public
bpop_blocked_clients	server.h	/^    unsigned int bpop_blocked_clients; \/* Number of clients blocked by lists *\/$/;"	m	language:C	struct:redisServer	access:public
broken	rio.c	/^        int broken = 0;$/;"	l	language:C
brpopCommand	server.h	/^void brpopCommand(client *c);$/;"	p	language:C	signature:(client *c)
brpopCommand	t_list.c	/^void brpopCommand(client *c) {$/;"	f	language:C	signature:(client *c)
brpoplpushCommand	server.h	/^void brpoplpushCommand(client *c);$/;"	p	language:C	signature:(client *c)
brpoplpushCommand	t_list.c	/^void brpoplpushCommand(client *c) {$/;"	f	language:C	signature:(client *c)
bservinfo	anet.c	/^    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;$/;"	l	language:C
bstr	object.c	/^    char bufa[128], bufb[128], *astr, *bstr;$/;"	l	language:C
btype	server.h	/^    int btype;              \/* Type of blocking op if CLIENT_BLOCKED. *\/$/;"	m	language:C	struct:client	access:public
buckets	geo.h	/^    size_t buckets;$/;"	m	language:C	struct:geoArray	access:public
buf	aof.c	/^        char buf[128];$/;"	l	language:C
buf	aof.c	/^    char buf[32];$/;"	l	language:C
buf	aof.c	/^    char buf[65536]; \/* Default pipe buffer size on most Linux systems. *\/$/;"	l	language:C
buf	aof.c	/^    char buf[AOF_RW_BUF_BLOCK_SIZE];$/;"	m	language:C	struct:aofrwblock	file:	access:public
buf	aof.c	/^    sds buf = sdsempty();$/;"	l	language:C
buf	bitops.c	/^            unsigned char buf[9];$/;"	l	language:C
buf	cluster.c	/^        sds buf = cmd.io.buffer.ptr;$/;"	l	language:C
buf	cluster.c	/^    char buf[sizeof(clusterMsg)];$/;"	l	language:C
buf	cluster.c	/^    unsigned char *buf;$/;"	l	language:C
buf	cluster.c	/^    unsigned char buf[2];$/;"	l	language:C
buf	cluster.c	/^    unsigned char buf[sizeof(clusterMsg)], *payload;$/;"	l	language:C
buf	cluster.c	/^    unsigned char buf[sizeof(clusterMsg)];$/;"	l	language:C
buf	config.c	/^        char buf[1024];$/;"	l	language:C
buf	config.c	/^        char buf[256];$/;"	l	language:C
buf	config.c	/^        char buf[32];$/;"	l	language:C
buf	config.c	/^        sds buf = sdsempty();$/;"	l	language:C
buf	config.c	/^    char buf[128];$/;"	l	language:C
buf	config.c	/^    char buf[64];$/;"	l	language:C
buf	config.c	/^    char buf[CONFIG_MAX_LINE+1];$/;"	l	language:C
buf	db.c	/^                char buf[LONG_STR_SIZE];$/;"	l	language:C
buf	debug.c	/^        char buf[128];$/;"	l	language:C
buf	debug.c	/^        char buf[4096];$/;"	l	language:C
buf	debug.c	/^    char buf[128];$/;"	l	language:C
buf	debug.c	/^    char buf[65], *b;$/;"	l	language:C
buf	endianconv.c	/^    char buf[32];$/;"	l	language:C
buf	geo.c	/^            char buf[12];$/;"	l	language:C
buf	latency.c	/^        char buf[64];$/;"	l	language:C
buf	latency.c	/^    char buf[1024];$/;"	l	language:C
buf	module.c	/^            char *buf = va_arg(ap,char*);$/;"	l	language:C
buf	module.c	/^        char buf[64];$/;"	l	language:C
buf	module.c	/^    char buf[LONG_STR_SIZE];$/;"	l	language:C
buf	modules/helloworld.c	/^    char *buf = RedisModule_PoolAlloc(ctx,padlen+strlen);$/;"	l	language:C
buf	networking.c	/^            char buf[32];$/;"	l	language:C
buf	networking.c	/^    char buf[128];$/;"	l	language:C
buf	networking.c	/^    char buf[64];$/;"	l	language:C
buf	notify.c	/^    char buf[24];$/;"	l	language:C
buf	object.c	/^        char buf[32];$/;"	l	language:C
buf	object.c	/^    char buf[256];$/;"	l	language:C
buf	rdb.c	/^        char buf[LONG_STR_SIZE], *p;$/;"	l	language:C
buf	rdb.c	/^        unsigned char buf[5];$/;"	l	language:C
buf	rdb.c	/^        void *buf = plain ? zmalloc(len) : sdsnewlen(NULL,len);$/;"	l	language:C
buf	rdb.c	/^    char *endptr, buf[32];$/;"	l	language:C
buf	rdb.c	/^    char buf[1024];$/;"	l	language:C
buf	rdb.c	/^    char buf[256];$/;"	l	language:C
buf	rdb.c	/^    char buf[LONG_STR_SIZE];$/;"	l	language:C
buf	rdb.c	/^    unsigned char buf[128];$/;"	l	language:C
buf	rdb.c	/^    unsigned char buf[2];$/;"	l	language:C
buf	rdb.c	/^    unsigned char buf[32];$/;"	l	language:C
buf	redis-benchmark.c	/^        char *buf = NULL;$/;"	l	language:C
buf	redis-benchmark.c	/^    char buf[256];$/;"	l	language:C
buf	redis-check-aof.c	/^            char buf[2];$/;"	l	language:C
buf	redis-check-aof.c	/^    char buf[128], *eptr;$/;"	l	language:C
buf	redis-check-rdb.c	/^    char buf[1024];$/;"	l	language:C
buf	redis-cli.c	/^        char buf[64];$/;"	l	language:C
buf	redis-cli.c	/^    char buf[1024];$/;"	l	language:C
buf	redis-cli.c	/^    char buf[4096], *p;$/;"	l	language:C
buf	redis-cli.c	/^    char buf[4096];$/;"	l	language:C
buf	replication.c	/^            struct redis_stat buf;$/;"	l	language:C
buf	replication.c	/^        char buf[256];$/;"	l	language:C
buf	replication.c	/^    char buf[128];$/;"	l	language:C
buf	replication.c	/^    char buf[4096];$/;"	l	language:C
buf	replication.c	/^    char buf[PROTO_IOBUF_LEN];$/;"	l	language:C
buf	replication.c	/^    static char buf[NET_PEER_ID_LEN];$/;"	l	language:C	file:
buf	rio.h	/^            sds buf;$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
buf	scripting.c	/^            char buf[1024];$/;"	l	language:C
buf	sds.c	/^                    char buf[SDS_LLSTR_SIZE];$/;"	l	language:C
buf	sds.c	/^    char buf[SDS_LLSTR_SIZE];$/;"	l	language:C
buf	sds.c	/^    char staticbuf[1024], *buf = staticbuf, *t;$/;"	l	language:C
buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr16	access:public
buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr32	access:public
buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr5	access:public
buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr64	access:public
buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr8	access:public
buf	sentinel.c	/^    char buf[NET_PEER_ID_LEN];$/;"	l	language:C
buf	server.c	/^            char buf[32];$/;"	l	language:C
buf	server.c	/^    char *buf = zmalloc(1024*16);$/;"	l	language:C
buf	server.c	/^    char buf[1024];$/;"	l	language:C
buf	server.c	/^    char buf[64];$/;"	l	language:C
buf	server.h	/^    char buf[PROTO_REPLY_CHUNK_BYTES];$/;"	m	language:C	struct:client	access:public
buf	setproctitle.c	/^	char buf[SPT_MAXTITLE + 1]; \/* use buffer in case argv[0] is passed *\/$/;"	l	language:C
buf	sha1.c	/^    unsigned char hash[20], buf[BUFSIZE];$/;"	l	language:C
buf	t_hash.c	/^    char buf[256];$/;"	l	language:C
buf	t_zset.c	/^    char buf[128];$/;"	l	language:C
buf	util.c	/^    char buf[128];$/;"	l	language:C
buf	util.c	/^    char buf[256];$/;"	l	language:C
buf	util.c	/^    char buf[32];$/;"	l	language:C
buf	ziplist.c	/^        char buf[1024];$/;"	l	language:C
buf	ziplist.c	/^        char buf[32];$/;"	l	language:C
buf	ziplist.c	/^    char buf[32];$/;"	l	language:C
buf	ziplist.c	/^    unsigned char len = 1, buf[5];$/;"	l	language:C
buf	zipmap.c	/^        unsigned char buf[512];$/;"	l	language:C
buf	zmalloc.c	/^    char buf[4096];$/;"	l	language:C
buf1	cluster.c	/^    char buf1[1024]; \/* Select reply. *\/$/;"	l	language:C
buf2	cluster.c	/^    char buf2[1024]; \/* Restore reply. *\/$/;"	l	language:C
bufa	object.c	/^    char bufa[128], bufb[128], *astr, *bstr;$/;"	l	language:C
bufa	server.c	/^    char bufa[CONFIG_AUTHPASS_MAX_LEN], bufb[CONFIG_AUTHPASS_MAX_LEN];$/;"	l	language:C
bufb	object.c	/^    char bufa[128], bufb[128], *astr, *bstr;$/;"	l	language:C
bufb	server.c	/^    char bufa[CONFIG_AUTHPASS_MAX_LEN], bufb[CONFIG_AUTHPASS_MAX_LEN];$/;"	l	language:C
buffer	rio.h	/^        } buffer;$/;"	m	language:C	union:_rio::__anon25	typeref:struct:_rio::__anon25::__anon26	access:public
buffer	sha1.h	/^    unsigned char buffer[64];$/;"	m	language:C	struct:__anon39	access:public
buffered	rio.h	/^            off_t buffered; \/* Bytes written since last fsync. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon27	access:public
buflen	redis-cli.c	/^    int i, argc, buflen = strlen(buf);$/;"	l	language:C
buflen	replication.c	/^    int buflen;$/;"	l	language:C
buflen	replication.c	/^    ssize_t nwritten, buflen;$/;"	l	language:C
buflen	sds.c	/^    size_t buflen = strlen(fmt)*2;$/;"	l	language:C
buflen	ziplist.c	/^        int buflen;$/;"	l	language:C
bufpos	server.h	/^    int bufpos;$/;"	m	language:C	struct:client	access:public
bugReportStart	debug.c	/^void bugReportStart(void) {$/;"	f	language:C	signature:(void)
bugReportStart	server.h	/^void bugReportStart(void);$/;"	p	language:C	signature:(void)
bug_report_start	server.h	/^    int bug_report_start; \/* True if bug report header was already logged. *\/$/;"	m	language:C	struct:redisServer	access:public
buildid	release.c	/^    char *buildid = REDIS_VERSION REDIS_BUILD_ID REDIS_GIT_DIRTY REDIS_GIT_SHA1;$/;"	l	language:C
bulk_data	cluster.h	/^    unsigned char bulk_data[8];$/;"	m	language:C	struct:__anon4	access:public
bulkhdr	server.h	/^    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  \/* "$<value>\\r\\n" *\/$/;"	m	language:C	struct:sharedObjectsStruct	access:public
bulklen	module.c	/^    long long bulklen;$/;"	l	language:C
bulklen	scripting.c	/^    long long bulklen;$/;"	l	language:C
bulklen	server.h	/^    long bulklen;           \/* Length of bulk argument in multi bulk request. *\/$/;"	m	language:C	struct:client	access:public
busp	cluster.c	/^        char *busp = strchr(port,'@');$/;"	l	language:C
busykeyerr	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
busykeys	t_string.c	/^    int j, busykeys = 0;$/;"	l	language:C
bysignal	sentinel.c	/^        int bysignal = 0;$/;"	l	language:C
bysignal	server.c	/^            int bysignal = 0;$/;"	l	language:C
byte	aof.c	/^    char byte;$/;"	l	language:C
byte	bitops.c	/^            size_t byte = thisop->offset >> 3;$/;"	l	language:C
byte	bitops.c	/^        unsigned char output, byte;$/;"	l	language:C
byte	bitops.c	/^    size_t byte = maxbit >> 3;$/;"	l	language:C
byte	bitops.c	/^    size_t byte, bit;$/;"	l	language:C
byte	bitops.c	/^    ssize_t byte, bit;$/;"	l	language:C
byte	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j, value = 0;$/;"	l	language:C
byte	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j;$/;"	l	language:C
byte	bitops.c	/^    unsigned long j, i, byte;$/;"	l	language:C
byte	cluster.c	/^    off_t byte = pos\/8;$/;"	l	language:C
byte	crc64.c	/^        uint8_t byte = s[j];$/;"	l	language:C
byte	rdb.c	/^    unsigned char byte;$/;"	l	language:C
byte	sds.c	/^                        unsigned char byte;$/;"	l	language:C
bytecounters	hyperloglog.c	/^    uint8_t bytecounters[HLL_REGISTERS];$/;"	l	language:C
bytes	bitops.c	/^        long bytes = end-start+1;$/;"	l	language:C
bytes	hyperloglog.c	/^    uint8_t *bytes;$/;"	l	language:C
bytes	intset.c	/^    uint32_t bytes = intrev32ifbe(is->length)-from;$/;"	l	language:C
bytes	memtest.c	/^    size_t bytes = megabytes*1024*1024;$/;"	l	language:C
bytes	networking.c	/^        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();$/;"	l	language:C
bytes	server.h	/^    size_t bytes;       \/* Bytes read \/ written so far. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
bytes	ziplist.c	/^    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;$/;"	l	language:C
bytes	zmalloc.c	/^    size_t bytes = 0;$/;"	l	language:C
bytesToHuman	redis-cli.c	/^void bytesToHuman(char *s, long long n) {$/;"	f	language:C	signature:(char *s, long long n)
bytesToHuman	server.c	/^void bytesToHuman(char *s, unsigned long long n) {$/;"	f	language:C	signature:(char *s, unsigned long long n)
bytes_to_read	rio.h	/^        size_t bytes_to_read = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;$/;"	l	language:C
bytes_to_write	rio.h	/^        size_t bytes_to_write = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;$/;"	l	language:C
byteval	bitops.c	/^    int byteval, bitval;$/;"	l	language:C
byteval	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j, value = 0;$/;"	l	language:C
byteval	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j;$/;"	l	language:C
byval	sort.c	/^            robj *byval;$/;"	l	language:C
c	aof.c	/^    struct client *c = zmalloc(sizeof(*c));$/;"	l	language:C
c	bitops.c	/^        uint64_t a = value, b = incr, c;$/;"	l	language:C
c	bitops.c	/^    unsigned char *c;$/;"	l	language:C
c	blocked.c	/^        client *c = listNodeValue(ln);$/;"	l	language:C
c	blocked.c	/^    client *c;$/;"	l	language:C
c	module.c	/^    client *c = NULL;$/;"	l	language:C
c	multi.c	/^        client *c = listNodeValue(ln);$/;"	l	language:C
c	networking.c	/^        client *c = listNodeValue(ln);$/;"	l	language:C
c	networking.c	/^        client *c;$/;"	l	language:C
c	networking.c	/^    client *c = (client*) privdata;$/;"	l	language:C
c	networking.c	/^    client *c = zmalloc(sizeof(client));$/;"	l	language:C
c	networking.c	/^    client *c;$/;"	l	language:C
c	notify.c	/^    int c, flags = 0;$/;"	l	language:C
c	pubsub.c	/^            client *c = ln->value;$/;"	l	language:C
c	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	language:C	file:
c	rdb.c	/^    unsigned char *c = NULL;$/;"	l	language:C
c	redis-benchmark.c	/^    client c = privdata;$/;"	l	language:C
c	redis-benchmark.c	/^    client c = zmalloc(sizeof(struct _client));$/;"	l	language:C
c	redis-benchmark.c	/^    client c;$/;"	l	language:C
c	replication.c	/^        client *c = ln->value;$/;"	l	language:C
c	replication.c	/^    client *c = server.master;$/;"	l	language:C
c	scripting.c	/^    client *c = server.lua_client;$/;"	l	language:C
c	sds.c	/^                        char c;$/;"	l	language:C
c	sentinel.c	/^    redisContext *c = &(ac->c);$/;"	l	language:C
c	server.c	/^            struct redisCommand *c = redisCommandTable+j;$/;"	l	language:C
c	server.c	/^        client *c;$/;"	l	language:C
c	server.c	/^        struct redisCommand *c = redisCommandTable+j;$/;"	l	language:C
c	server.c	/^    const char *c = ".-*#";$/;"	l	language:C
c	sha1.c	/^        unsigned char c[64];$/;"	m	language:C	union:__anon38	file:	access:public
c	sha1.c	/^    uint32_t a, b, c, d, e;$/;"	l	language:C
c	sha1.c	/^    unsigned char c;$/;"	l	language:C
c	syncio.c	/^        char c;$/;"	l	language:C
c	t_zset.c	/^    char *c = item->ptr;$/;"	l	language:C
c	util.c	/^                    int c = string[0];$/;"	l	language:C
c_ru	server.c	/^    struct rusage self_ru, c_ru;$/;"	l	language:C
cache	module.c	/^    } cache[MODULE_LOOKUP_CACHE_SIZE];$/;"	l	language:C	file:
cached	evict.c	/^                sds cached = pool[0].cached; \/* Save SDS before overwriting. *\/$/;"	l	language:C
cached	evict.c	/^                sds cached = pool[EVPOOL_SIZE-1].cached;$/;"	l	language:C
cached	evict.c	/^    sds cached;                 \/* Cached SDS object for key name. *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
cached_master	server.h	/^    client *cached_master; \/* Cached master to be reused for PSYNC. *\/$/;"	m	language:C	struct:redisServer	access:public
cached_objects	scripting.c	/^    static robj *cached_objects[LUA_CMD_OBJCACHE_SIZE];$/;"	l	language:C	file:
cached_objects_len	scripting.c	/^    static size_t cached_objects_len[LUA_CMD_OBJCACHE_SIZE];$/;"	l	language:C	file:
call	server.c	/^void call(client *c, int flags) {$/;"	f	language:C	signature:(client *c, int flags)
call	server.h	/^void call(client *c, int flags);$/;"	p	language:C	signature:(client *c, int flags)
call_flags	module.c	/^    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;$/;"	l	language:C
call_flags	scripting.c	/^    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;$/;"	l	language:C
call_uname	server.c	/^        static int call_uname = 1;$/;"	l	language:C	file:
callbacks	sentinel.c	/^            redisCallbackList *callbacks = &link->cc->replies;$/;"	l	language:C
called	modules/API.md	/^2. Each time `RM_StringTruncate()` is called, to continue with the DMA$/;"	v	language:C
calloc	server.h	/^void *calloc(size_t count, size_t size) __attribute__ ((deprecated));$/;"	p	language:C	signature:(size_t count, size_t size)
calloc	zmalloc.c	/^#define calloc(/;"	d	language:C	file:
calls	modules/INTRO.md	/^to all the other API calls, the command argument vector, and total number$/;"	v	language:C
calls	server.h	/^    long long microseconds, calls;$/;"	m	language:C	struct:redisCommand	access:public
can_log	aof.c	/^        int can_log = 0;$/;"	l	language:C
cancelReplicationHandshake	replication.c	/^int cancelReplicationHandshake(void) {$/;"	f	language:C	signature:(void)
cancelReplicationHandshake	replication.c	/^int cancelReplicationHandshake(void);$/;"	p	language:C	file:	signature:(void)
candidate	cluster.c	/^    clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;$/;"	l	language:C
cant_failover_reason	cluster.h	/^    int cant_failover_reason;   \/* Why a slave is currently not able to$/;"	m	language:C	struct:clusterState	access:public
card	hyperloglog.c	/^    uint64_t card;$/;"	l	language:C
card	hyperloglog.c	/^    uint8_t card[8];    \/* Cached cardinality, little endian. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
cardinality	t_set.c	/^    int j, cardinality = 0;$/;"	l	language:C
cardinality	t_set.c	/^    unsigned long j, cardinality = 0;$/;"	l	language:C
carry0	rand.c	/^    uint32_t p[2], q[2], r[2], carry0, carry1;$/;"	l	language:C
carry1	rand.c	/^    uint32_t p[2], q[2], r[2], carry0, carry1;$/;"	l	language:C
catAppendOnlyExpireAtCommand	aof.c	/^sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {$/;"	f	language:C	signature:(sds buf, struct redisCommand *cmd, robj *key, robj *seconds)
catAppendOnlyGenericCommand	aof.c	/^sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {$/;"	f	language:C	signature:(sds dst, int argc, robj **argv)
catClientInfoString	networking.c	/^sds catClientInfoString(sds s, client *client) {$/;"	f	language:C	signature:(sds s, client *client)
catClientInfoString	server.h	/^sds catClientInfoString(sds s, client *client);$/;"	p	language:C	signature:(sds s, client *client)
cb	sentinel.c	/^            redisCallback *cb;$/;"	l	language:C
cbuf	rio.c	/^    char cbuf[128];$/;"	l	language:C
cbuf	scripting.c	/^    sds cbuf;   \/* Debugger client command buffer. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
cc	sentinel.c	/^    redisAsyncContext *cc; \/* Hiredis context for commands. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
cc_conn_time	sentinel.c	/^    mstime_t cc_conn_time; \/* cc connection time. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
ccode	redis-cli.c	/^    int ccode = 37; \/* Defaults to white. *\/$/;"	l	language:C
cfd	cluster.c	/^    int cport, cfd;$/;"	l	language:C
cfd	networking.c	/^    int cfd, max = MAX_ACCEPTS_PER_CALL;$/;"	l	language:C
cfd	networking.c	/^    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;$/;"	l	language:C
cfd	server.h	/^    int cfd[CONFIG_BINDADDR_MAX];\/* Cluster bus listening socket *\/$/;"	m	language:C	struct:redisServer	access:public
cfd_count	server.h	/^    int cfd_count;              \/* Used slots in cfd[] *\/$/;"	m	language:C	struct:redisServer	access:public
cfield	module.c	/^            char *cfield = va_arg(ap,char*);$/;"	l	language:C
ch	modules/helloworld.c	/^    const char *ch = RedisModule_StringPtrLen(argv[3], &chlen);$/;"	l	language:C
ch	redis-cli.c	/^        struct commandHelp *ch = zmalloc(sizeof(*ch));$/;"	l	language:C
ch	t_zset.c	/^    int ch = (flags & ZADD_CH) != 0;$/;"	l	language:C
chainlen	dict.c	/^    unsigned long i, slots = 0, chainlen, maxchainlen = 0;$/;"	l	language:C
chan	notify.c	/^    sds chan;$/;"	l	language:C
changed	cluster.c	/^        int changed = 0;$/;"	l	language:C
changes	bitops.c	/^    int j, numops = 0, changes = 0;$/;"	l	language:C
changes	config.c	/^                int changes = atoi(argv[2]);$/;"	l	language:C
changes	config.c	/^            int changes;$/;"	l	language:C
changes	sentinel.c	/^    int j, changes = 0;$/;"	l	language:C
changes	server.h	/^    int changes;$/;"	m	language:C	struct:saveparam	access:public
channel	cluster.c	/^        robj *channel, *message;$/;"	l	language:C
channel	pubsub.c	/^            sds channel = cobj->ptr;$/;"	l	language:C
channel	pubsub.c	/^        robj *channel = dictGetKey(de);$/;"	l	language:C
channel	sentinel.c	/^    robj *channel, *payload;$/;"	l	language:C
channel_len	cluster.c	/^        uint32_t channel_len, message_len;$/;"	l	language:C
channel_len	cluster.c	/^    uint32_t channel_len, message_len;$/;"	l	language:C
channel_len	cluster.h	/^    uint32_t channel_len;$/;"	m	language:C	struct:__anon4	access:public
chanobj	notify.c	/^    robj *chanobj, *eventobj;$/;"	l	language:C
character	redis-cli.c	/^    int character;   \/* Associated character in visualization. *\/$/;"	m	language:C	struct:distsamples	file:	access:public
charidx	sparkline.c	/^                int charidx = step-((rows-row-1)*charset_len);$/;"	l	language:C
chars	memtest.c	/^    size_t chars = ((unsigned long long)curr*progress_full)\/size, j;$/;"	l	language:C
chars	sparkline.c	/^    char *chars = zmalloc(len);$/;"	l	language:C
charset	debug.c	/^    char charset[] = "0123456789abcdef";$/;"	l	language:C
charset	sparkline.c	/^static char charset[] = "_-`";$/;"	v	language:C	file:
charset	util.c	/^    char *charset = "0123456789abcdef";$/;"	l	language:C
charset_fill	sparkline.c	/^static char charset_fill[] = "_o#";$/;"	v	language:C	file:
charset_len	sparkline.c	/^static int charset_len = sizeof(charset)-1;$/;"	v	language:C	file:
checkClientOutputBufferLimits	networking.c	/^int checkClientOutputBufferLimits(client *c) {$/;"	f	language:C	signature:(client *c)
checkConsistency	intset.c	/^static void checkConsistency(intset *is) {$/;"	f	language:C	file:	signature:(intset *is)
checkForSentinelMode	server.c	/^int checkForSentinelMode(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
checkSignedBitfieldOverflow	bitops.c	/^int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {$/;"	f	language:C	signature:(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit)
checkStringLength	t_string.c	/^static int checkStringLength(client *c, long long size) {$/;"	f	language:C	file:	signature:(client *c, long long size)
checkTcpBacklogSettings	server.c	/^void checkTcpBacklogSettings(void) {$/;"	f	language:C	signature:(void)
checkType	object.c	/^int checkType(client *c, robj *o, int type) {$/;"	f	language:C	signature:(client *c, robj *o, int type)
checkType	server.h	/^int checkType(client *c, robj *o, int type);$/;"	p	language:C	signature:(client *c, robj *o, int type)
checkUnsignedBitfieldOverflow	bitops.c	/^int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {$/;"	f	language:C	signature:(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit)
checkpoint	hyperloglog.c	/^    int64_t checkpoint = 1;$/;"	l	language:C
childpid	aof.c	/^    pid_t childpid;$/;"	l	language:C
childpid	rdb.c	/^    pid_t childpid;$/;"	l	language:C
children	scripting.c	/^    list *children; \/* All forked debugging sessions pids. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
chlen	modules/helloworld.c	/^    size_t strlen, chlen;$/;"	l	language:C
ci	cluster.c	/^        sds ci = clusterGenNodesDescription(0);$/;"	l	language:C
ci	cluster.c	/^        sds ci;$/;"	l	language:C
ci	cluster.c	/^    sds ci = sdsempty(), ni;$/;"	l	language:C
ci	cluster.c	/^    sds ci;$/;"	l	language:C
ci	networking.c	/^        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();$/;"	l	language:C
cip	cluster.c	/^    char cip[NET_IP_STR_LEN];$/;"	l	language:C
cip	networking.c	/^    char cip[NET_IP_STR_LEN];$/;"	l	language:C
cksum	rdb.c	/^        uint64_t cksum, expected = rdb.cksum;$/;"	l	language:C
cksum	rdb.c	/^    uint64_t cksum;$/;"	l	language:C
cksum	redis-check-rdb.c	/^        uint64_t cksum, expected = rdb.cksum;$/;"	l	language:C
cksum	rio.h	/^    uint64_t cksum;$/;"	m	language:C	struct:_rio	access:public
claimed_slots	cluster.c	/^    unsigned char *claimed_slots = request->myslots;$/;"	l	language:C
class	config.c	/^            int class = getClientTypeByName(argv[1]);$/;"	l	language:C
class	config.c	/^            int class;$/;"	l	language:C
class	networking.c	/^    int soft = 0, hard = 0, class;$/;"	l	language:C
clearNodeFailureIfNeeded	cluster.c	/^void clearNodeFailureIfNeeded(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clen	rdb.c	/^    uint64_t len, clen;$/;"	l	language:C
clen	rio.c	/^    int clen;$/;"	l	language:C
cliAuth	redis-cli.c	/^static int cliAuth(void) {$/;"	f	language:C	file:	signature:(void)
cliConnect	redis-cli.c	/^static int cliConnect(int force) {$/;"	f	language:C	file:	signature:(int force)
cliConnect	redis-cli.c	/^static int cliConnect(int force);$/;"	p	language:C	file:	signature:(int force)
cliFormatReplyCSV	redis-cli.c	/^static sds cliFormatReplyCSV(redisReply *r) {$/;"	f	language:C	file:	signature:(redisReply *r)
cliFormatReplyRaw	redis-cli.c	/^static sds cliFormatReplyRaw(redisReply *r) {$/;"	f	language:C	file:	signature:(redisReply *r)
cliFormatReplyTTY	redis-cli.c	/^static sds cliFormatReplyTTY(redisReply *r, char *prefix) {$/;"	f	language:C	file:	signature:(redisReply *r, char *prefix)
cliInitHelp	redis-cli.c	/^static void cliInitHelp(void) {$/;"	f	language:C	file:	signature:(void)
cliIntegrateHelp	redis-cli.c	/^static void cliIntegrateHelp(void) {$/;"	f	language:C	file:	signature:(void)
cliLoadPreferences	redis-cli.c	/^void cliLoadPreferences(void) {$/;"	f	language:C	signature:(void)
cliOutputCommandHelp	redis-cli.c	/^static void cliOutputCommandHelp(struct commandHelp *help, int group) {$/;"	f	language:C	file:	signature:(struct commandHelp *help, int group)
cliOutputGenericHelp	redis-cli.c	/^static void cliOutputGenericHelp(void) {$/;"	f	language:C	file:	signature:(void)
cliOutputHelp	redis-cli.c	/^static void cliOutputHelp(int argc, char **argv) {$/;"	f	language:C	file:	signature:(int argc, char **argv)
cliPrintContextError	redis-cli.c	/^static void cliPrintContextError(void) {$/;"	f	language:C	file:	signature:(void)
cliReadReply	redis-cli.c	/^static int cliReadReply(int output_raw_strings) {$/;"	f	language:C	file:	signature:(int output_raw_strings)
cliRefreshPrompt	redis-cli.c	/^static void cliRefreshPrompt(void) {$/;"	f	language:C	file:	signature:(void)
cliSelect	redis-cli.c	/^static int cliSelect(void) {$/;"	f	language:C	file:	signature:(void)
cliSendCommand	redis-cli.c	/^static int cliSendCommand(int argc, char **argv, int repeat) {$/;"	f	language:C	file:	signature:(int argc, char **argv, int repeat)
cliSetPreferences	redis-cli.c	/^void cliSetPreferences(char **argv, int argc, int interactive) {$/;"	f	language:C	signature:(char **argv, int argc, int interactive)
cliSplitArgs	redis-cli.c	/^static sds *cliSplitArgs(char *line, int *argc) {$/;"	f	language:C	file:	signature:(char *line, int *argc)
cliVersion	redis-cli.c	/^static sds cliVersion(void) {$/;"	f	language:C	file:	signature:(void)
client	debug.c	/^    sds client;$/;"	l	language:C
client	module.c	/^    client *client;                 \/* Client calling a command. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
client	modules/API.md	/^Send an integer reply to the client, with the specified long long value.$/;"	v	language:C
client	networking.c	/^        sds client = catClientInfoString(sdsempty(),c);$/;"	l	language:C
client	networking.c	/^    client *client;$/;"	l	language:C
client	redis-benchmark.c	/^} *client;$/;"	t	language:C	typeref:struct:_client	file:
client	replication.c	/^            sds client = catClientInfoString(sdsempty(),c);$/;"	l	language:C
client	replication.c	/^        sds client = catClientInfoString(sdsempty(),c);$/;"	l	language:C
client	server.h	/^    client *client;$/;"	m	language:C	struct:pubsubPattern	access:public
client	server.h	/^typedef struct client {$/;"	s	language:C
client	server.h	/^} client;$/;"	t	language:C	typeref:struct:client
client::argc	server.h	/^    int argc;               \/* Num of arguments of current command. *\/$/;"	m	language:C	struct:client	access:public
client::argv	server.h	/^    robj **argv;            \/* Arguments of current command. *\/$/;"	m	language:C	struct:client	access:public
client::authenticated	server.h	/^    int authenticated;      \/* When requirepass is non-NULL. *\/$/;"	m	language:C	struct:client	access:public
client::bpop	server.h	/^    blockingState bpop;     \/* blocking state *\/$/;"	m	language:C	struct:client	access:public
client::btype	server.h	/^    int btype;              \/* Type of blocking op if CLIENT_BLOCKED. *\/$/;"	m	language:C	struct:client	access:public
client::buf	server.h	/^    char buf[PROTO_REPLY_CHUNK_BYTES];$/;"	m	language:C	struct:client	access:public
client::bufpos	server.h	/^    int bufpos;$/;"	m	language:C	struct:client	access:public
client::bulklen	server.h	/^    long bulklen;           \/* Length of bulk argument in multi bulk request. *\/$/;"	m	language:C	struct:client	access:public
client::cmd	server.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	language:C	struct:client	typeref:struct:client::redisCommand	access:public
client::ctime	server.h	/^    time_t ctime;           \/* Client creation time. *\/$/;"	m	language:C	struct:client	access:public
client::db	server.h	/^    redisDb *db;            \/* Pointer to currently SELECTed DB. *\/$/;"	m	language:C	struct:client	access:public
client::fd	server.h	/^    int fd;                 \/* Client socket. *\/$/;"	m	language:C	struct:client	access:public
client::flags	server.h	/^    int flags;              \/* Client flags: CLIENT_* macros. *\/$/;"	m	language:C	struct:client	access:public
client::id	server.h	/^    uint64_t id;            \/* Client incremental unique ID. *\/$/;"	m	language:C	struct:client	access:public
client::lastcmd	server.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	language:C	struct:client	typeref:struct:client::	access:public
client::lastinteraction	server.h	/^    time_t lastinteraction; \/* Time of the last interaction, used for timeout *\/$/;"	m	language:C	struct:client	access:public
client::mstate	server.h	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	language:C	struct:client	access:public
client::multibulklen	server.h	/^    int multibulklen;       \/* Number of multi bulk arguments left to read. *\/$/;"	m	language:C	struct:client	access:public
client::name	server.h	/^    robj *name;             \/* As set by CLIENT SETNAME. *\/$/;"	m	language:C	struct:client	access:public
client::obuf_soft_limit_reached_time	server.h	/^    time_t obuf_soft_limit_reached_time;$/;"	m	language:C	struct:client	access:public
client::peerid	server.h	/^    sds peerid;             \/* Cached peer ID. *\/$/;"	m	language:C	struct:client	access:public
client::psync_initial_offset	server.h	/^    long long psync_initial_offset; \/* FULLRESYNC reply offset other slaves$/;"	m	language:C	struct:client	access:public
client::pubsub_channels	server.h	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	language:C	struct:client	access:public
client::pubsub_patterns	server.h	/^    list *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	language:C	struct:client	access:public
client::querybuf	server.h	/^    sds querybuf;           \/* Buffer we use to accumulate client queries. *\/$/;"	m	language:C	struct:client	access:public
client::querybuf_peak	server.h	/^    size_t querybuf_peak;   \/* Recent (100ms or more) peak of querybuf size. *\/$/;"	m	language:C	struct:client	access:public
client::repl_ack_off	server.h	/^    long long repl_ack_off; \/* Replication ack offset, if this is a slave. *\/$/;"	m	language:C	struct:client	access:public
client::repl_ack_time	server.h	/^    long long repl_ack_time;\/* Replication ack time, if this is a slave. *\/$/;"	m	language:C	struct:client	access:public
client::repl_put_online_on_ack	server.h	/^    int repl_put_online_on_ack; \/* Install slave write handler on ACK. *\/$/;"	m	language:C	struct:client	access:public
client::repldbfd	server.h	/^    int repldbfd;           \/* Replication DB file descriptor. *\/$/;"	m	language:C	struct:client	access:public
client::repldboff	server.h	/^    off_t repldboff;        \/* Replication DB file offset. *\/$/;"	m	language:C	struct:client	access:public
client::repldbsize	server.h	/^    off_t repldbsize;       \/* Replication DB file size. *\/$/;"	m	language:C	struct:client	access:public
client::reploff	server.h	/^    long long reploff;      \/* Replication offset if this is our master. *\/$/;"	m	language:C	struct:client	access:public
client::replpreamble	server.h	/^    sds replpreamble;       \/* Replication DB preamble. *\/$/;"	m	language:C	struct:client	access:public
client::replrunid	server.h	/^    char replrunid[CONFIG_RUN_ID_SIZE+1]; \/* Master run id if is a master. *\/$/;"	m	language:C	struct:client	access:public
client::replstate	server.h	/^    int replstate;          \/* Replication state if this is a slave. *\/$/;"	m	language:C	struct:client	access:public
client::reply	server.h	/^    list *reply;            \/* List of reply objects to send to the client. *\/$/;"	m	language:C	struct:client	access:public
client::reply_bytes	server.h	/^    unsigned long long reply_bytes; \/* Tot bytes of objects in reply list. *\/$/;"	m	language:C	struct:client	access:public
client::reqtype	server.h	/^    int reqtype;            \/* Request protocol type: PROTO_REQ_* *\/$/;"	m	language:C	struct:client	access:public
client::sentlen	server.h	/^    size_t sentlen;         \/* Amount of bytes already sent in the current$/;"	m	language:C	struct:client	access:public
client::slave_capa	server.h	/^    int slave_capa;         \/* Slave capabilities: SLAVE_CAPA_* bitwise OR. *\/$/;"	m	language:C	struct:client	access:public
client::slave_ip	server.h	/^    char slave_ip[NET_IP_STR_LEN]; \/* Optionally given by REPLCONF ip-address *\/$/;"	m	language:C	struct:client	access:public
client::slave_listening_port	server.h	/^    int slave_listening_port; \/* As configured with: REPLCONF listening-port *\/$/;"	m	language:C	struct:client	access:public
client::watched_keys	server.h	/^    list *watched_keys;     \/* Keys WATCHED for MULTI\/EXEC CAS *\/$/;"	m	language:C	struct:client	access:public
client::woff	server.h	/^    long long woff;         \/* Last write global replication offset. *\/$/;"	m	language:C	struct:client	access:public
clientBufferLimitsConfig	server.h	/^typedef struct clientBufferLimitsConfig {$/;"	s	language:C
clientBufferLimitsConfig	server.h	/^} clientBufferLimitsConfig;$/;"	t	language:C	typeref:struct:clientBufferLimitsConfig
clientBufferLimitsConfig::hard_limit_bytes	server.h	/^    unsigned long long hard_limit_bytes;$/;"	m	language:C	struct:clientBufferLimitsConfig	access:public
clientBufferLimitsConfig::soft_limit_bytes	server.h	/^    unsigned long long soft_limit_bytes;$/;"	m	language:C	struct:clientBufferLimitsConfig	access:public
clientBufferLimitsConfig::soft_limit_seconds	server.h	/^    time_t soft_limit_seconds;$/;"	m	language:C	struct:clientBufferLimitsConfig	access:public
clientBufferLimitsDefaults	config.c	/^clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT] = {$/;"	v	language:C
clientBufferLimitsDefaults	server.h	/^extern clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT];$/;"	x	language:C
clientCommand	networking.c	/^void clientCommand(client *c) {$/;"	f	language:C	signature:(client *c)
clientCommand	server.h	/^void clientCommand(client *c);$/;"	p	language:C	signature:(client *c)
clientData	ae.h	/^    void *clientData;$/;"	m	language:C	struct:aeFileEvent	access:public
clientData	ae.h	/^    void *clientData;$/;"	m	language:C	struct:aeTimeEvent	access:public
clientDone	redis-benchmark.c	/^static void clientDone(client c) {$/;"	f	language:C	file:	signature:(client c)
clientHasPendingReplies	networking.c	/^int clientHasPendingReplies(client *c) {$/;"	f	language:C	signature:(client *c)
clientHasPendingReplies	server.h	/^int clientHasPendingReplies(client *c);$/;"	p	language:C	signature:(client *c)
clientSubscriptionsCount	pubsub.c	/^int clientSubscriptionsCount(client *c) {$/;"	f	language:C	signature:(client *c)
client_max_querybuf_len	server.h	/^    size_t client_max_querybuf_len; \/* Limit for client query buffer length *\/$/;"	m	language:C	struct:redisServer	access:public
client_obuf_limits	server.h	/^    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];$/;"	m	language:C	struct:redisServer	access:public
client_old_flags	server.c	/^    int client_old_flags = c->flags;$/;"	l	language:C
client_reconfig_script	sentinel.c	/^    char *client_reconfig_script;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
clientids	rdb.c	/^    uint64_t *clientids;$/;"	l	language:C
clientnode	t_list.c	/^                        listNode *clientnode = listFirst(clients);$/;"	l	language:C
clients	debug.c	/^    sds infostring, clients;$/;"	l	language:C
clients	multi.c	/^        list *clients;$/;"	l	language:C
clients	multi.c	/^    list *clients = NULL;$/;"	l	language:C
clients	multi.c	/^    list *clients;$/;"	l	language:C
clients	pubsub.c	/^    list *clients = NULL;$/;"	l	language:C
clients	pubsub.c	/^    list *clients;$/;"	l	language:C
clients	redis-benchmark.c	/^    list *clients;$/;"	m	language:C	struct:config	file:	access:public
clients	server.h	/^    list *clients;              \/* List of active clients *\/$/;"	m	language:C	struct:redisServer	access:public
clients	t_list.c	/^                    list *clients = dictGetVal(de);$/;"	l	language:C
clientsArePaused	networking.c	/^int clientsArePaused(void) {$/;"	f	language:C	signature:(void)
clientsArePaused	server.h	/^int clientsArePaused(void);$/;"	p	language:C	signature:(void)
clientsCron	server.c	/^void clientsCron(void) {$/;"	f	language:C	signature:(void)
clientsCronHandleTimeout	server.c	/^int clientsCronHandleTimeout(client *c, mstime_t now_ms) {$/;"	f	language:C	signature:(client *c, mstime_t now_ms)
clientsCronResizeQueryBuffer	server.c	/^int clientsCronResizeQueryBuffer(client *c) {$/;"	f	language:C	signature:(client *c)
clients_pause_end_time	server.h	/^    mstime_t clients_pause_end_time; \/* Time when we undo clients_paused *\/$/;"	m	language:C	struct:redisServer	access:public
clients_paused	server.h	/^    int clients_paused;         \/* True if clients are currently paused *\/$/;"	m	language:C	struct:redisServer	access:public
clients_pending_write	server.h	/^    list *clients_pending_write; \/* There is to write or install handler. *\/$/;"	m	language:C	struct:redisServer	access:public
clients_to_close	server.h	/^    list *clients_to_close;     \/* Clients to close asynchronously *\/$/;"	m	language:C	struct:redisServer	access:public
clients_waiting_acks	server.h	/^    list *clients_waiting_acks;         \/* Clients waiting in WAIT command. *\/$/;"	m	language:C	struct:redisServer	access:public
clock	sentinel.c	/^            time_t clock = (master->failover_start_time +$/;"	l	language:C
closeDirectLogFiledes	debug.c	/^void closeDirectLogFiledes(int fd) {$/;"	f	language:C	signature:(int fd)
closeListeningSockets	server.c	/^void closeListeningSockets(int unlink_unix_socket) {$/;"	f	language:C	signature:(int unlink_unix_socket)
closeListeningSockets	server.h	/^void closeListeningSockets(int unlink_unix_socket);$/;"	p	language:C	signature:(int unlink_unix_socket)
closeTimedoutClients	server.h	/^void closeTimedoutClients(void);$/;"	p	language:C	signature:(void)
close_this_client	networking.c	/^        int killed = 0, close_this_client = 0;$/;"	l	language:C
cluster	server.h	/^    struct clusterState *cluster;  \/* State of the cluster *\/$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::clusterState	access:public
clusterAcceptHandler	cluster.c	/^void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterAcceptHandler	cluster.c	/^void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterAddNode	cluster.c	/^int clusterAddNode(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterAddNode	cluster.c	/^int clusterAddNode(clusterNode *node);$/;"	p	language:C	file:	signature:(clusterNode *node)
clusterAddSlot	cluster.c	/^int clusterAddSlot(clusterNode *n, int slot) {$/;"	f	language:C	signature:(clusterNode *n, int slot)
clusterAddSlot	cluster.c	/^int clusterAddSlot(clusterNode *n, int slot);$/;"	p	language:C	file:	signature:(clusterNode *n, int slot)
clusterBeforeSleep	cluster.c	/^void clusterBeforeSleep(void) {$/;"	f	language:C	signature:(void)
clusterBeforeSleep	server.h	/^void clusterBeforeSleep(void);$/;"	p	language:C	signature:(void)
clusterBlacklistAddNode	cluster.c	/^void clusterBlacklistAddNode(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterBlacklistCleanup	cluster.c	/^void clusterBlacklistCleanup(void) {$/;"	f	language:C	signature:(void)
clusterBlacklistExists	cluster.c	/^int clusterBlacklistExists(char *nodeid) {$/;"	f	language:C	signature:(char *nodeid)
clusterBroadcastMessage	cluster.c	/^void clusterBroadcastMessage(void *buf, size_t len) {$/;"	f	language:C	signature:(void *buf, size_t len)
clusterBroadcastPong	cluster.c	/^void clusterBroadcastPong(int target) {$/;"	f	language:C	signature:(int target)
clusterBuildMessageHdr	cluster.c	/^void clusterBuildMessageHdr(clusterMsg *hdr, int type) {$/;"	f	language:C	signature:(clusterMsg *hdr, int type)
clusterBumpConfigEpochWithoutConsensus	cluster.c	/^int clusterBumpConfigEpochWithoutConsensus(void) {$/;"	f	language:C	signature:(void)
clusterBumpConfigEpochWithoutConsensus	cluster.c	/^int clusterBumpConfigEpochWithoutConsensus(void);$/;"	p	language:C	file:	signature:(void)
clusterCloseAllSlots	cluster.c	/^void clusterCloseAllSlots(void) {$/;"	f	language:C	signature:(void)
clusterCloseAllSlots	cluster.c	/^void clusterCloseAllSlots(void);$/;"	p	language:C	file:	signature:(void)
clusterCommand	cluster.c	/^void clusterCommand(client *c) {$/;"	f	language:C	signature:(client *c)
clusterCommand	server.h	/^void clusterCommand(client *c);$/;"	p	language:C	signature:(client *c)
clusterCountNonFailingSlaves	cluster.c	/^int clusterCountNonFailingSlaves(clusterNode *n) {$/;"	f	language:C	signature:(clusterNode *n)
clusterCron	cluster.c	/^void clusterCron(void) {$/;"	f	language:C	signature:(void)
clusterCron	server.h	/^void clusterCron(void);$/;"	p	language:C	signature:(void)
clusterDelNode	cluster.c	/^void clusterDelNode(clusterNode *delnode) {$/;"	f	language:C	signature:(clusterNode *delnode)
clusterDelNode	cluster.c	/^void clusterDelNode(clusterNode *delnode);$/;"	p	language:C	file:	signature:(clusterNode *delnode)
clusterDelNodeSlots	cluster.c	/^int clusterDelNodeSlots(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterDelNodeSlots	cluster.c	/^int clusterDelNodeSlots(clusterNode *node);$/;"	p	language:C	file:	signature:(clusterNode *node)
clusterDelSlot	cluster.c	/^int clusterDelSlot(int slot) {$/;"	f	language:C	signature:(int slot)
clusterDelSlot	cluster.c	/^int clusterDelSlot(int slot);$/;"	p	language:C	file:	signature:(int slot)
clusterDoBeforeSleep	cluster.c	/^void clusterDoBeforeSleep(int flags) {$/;"	f	language:C	signature:(int flags)
clusterDoBeforeSleep	cluster.c	/^void clusterDoBeforeSleep(int flags);$/;"	p	language:C	file:	signature:(int flags)
clusterFailoverReplaceYourMaster	cluster.c	/^void clusterFailoverReplaceYourMaster(void) {$/;"	f	language:C	signature:(void)
clusterGenNodeDescription	cluster.c	/^sds clusterGenNodeDescription(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterGenNodesDescription	cluster.c	/^sds clusterGenNodesDescription(int filter) {$/;"	f	language:C	signature:(int filter)
clusterGenNodesDescription	cluster.c	/^sds clusterGenNodesDescription(int filter);$/;"	p	language:C	file:	signature:(int filter)
clusterGetMaxEpoch	cluster.c	/^uint64_t clusterGetMaxEpoch(void) {$/;"	f	language:C	signature:(void)
clusterGetMaxEpoch	cluster.c	/^uint64_t clusterGetMaxEpoch(void);$/;"	p	language:C	file:	signature:(void)
clusterGetSlaveRank	cluster.c	/^int clusterGetSlaveRank(void) {$/;"	f	language:C	signature:(void)
clusterHandleConfigEpochCollision	cluster.c	/^void clusterHandleConfigEpochCollision(clusterNode *sender) {$/;"	f	language:C	signature:(clusterNode *sender)
clusterHandleManualFailover	cluster.c	/^void clusterHandleManualFailover(void) {$/;"	f	language:C	signature:(void)
clusterHandleSlaveFailover	cluster.c	/^void clusterHandleSlaveFailover(void) {$/;"	f	language:C	signature:(void)
clusterHandleSlaveFailover	cluster.c	/^void clusterHandleSlaveFailover(void);$/;"	p	language:C	file:	signature:(void)
clusterHandleSlaveMigration	cluster.c	/^void clusterHandleSlaveMigration(int max_slaves) {$/;"	f	language:C	signature:(int max_slaves)
clusterHandleSlaveMigration	cluster.c	/^void clusterHandleSlaveMigration(int max_slaves);$/;"	p	language:C	file:	signature:(int max_slaves)
clusterHandshakeInProgress	cluster.c	/^int clusterHandshakeInProgress(char *ip, int port, int cport) {$/;"	f	language:C	signature:(char *ip, int port, int cport)
clusterInit	cluster.c	/^void clusterInit(void) {$/;"	f	language:C	signature:(void)
clusterInit	server.h	/^void clusterInit(void);$/;"	p	language:C	signature:(void)
clusterLink	cluster.h	/^typedef struct clusterLink {$/;"	s	language:C
clusterLink	cluster.h	/^} clusterLink;$/;"	t	language:C	typeref:struct:clusterLink
clusterLink::ctime	cluster.h	/^    mstime_t ctime;             \/* Link creation time *\/$/;"	m	language:C	struct:clusterLink	access:public
clusterLink::fd	cluster.h	/^    int fd;                     \/* TCP socket file descriptor *\/$/;"	m	language:C	struct:clusterLink	access:public
clusterLink::node	cluster.h	/^    struct clusterNode *node;   \/* Node related to this link if any, or NULL *\/$/;"	m	language:C	struct:clusterLink	typeref:struct:clusterLink::clusterNode	access:public
clusterLink::rcvbuf	cluster.h	/^    sds rcvbuf;                 \/* Packet reception buffer *\/$/;"	m	language:C	struct:clusterLink	access:public
clusterLink::sndbuf	cluster.h	/^    sds sndbuf;                 \/* Packet send buffer *\/$/;"	m	language:C	struct:clusterLink	access:public
clusterLoadConfig	cluster.c	/^int clusterLoadConfig(char *filename) {$/;"	f	language:C	signature:(char *filename)
clusterLockConfig	cluster.c	/^int clusterLockConfig(char *filename) {$/;"	f	language:C	signature:(char *filename)
clusterLogCantFailover	cluster.c	/^void clusterLogCantFailover(int reason) {$/;"	f	language:C	signature:(int reason)
clusterLookupNode	cluster.c	/^clusterNode *clusterLookupNode(char *name) {$/;"	f	language:C	signature:(char *name)
clusterLookupNode	cluster.c	/^clusterNode *clusterLookupNode(char *name);$/;"	p	language:C	file:	signature:(char *name)
clusterMastersHaveSlaves	cluster.c	/^int clusterMastersHaveSlaves(void) {$/;"	f	language:C	signature:(void)
clusterMsg	cluster.h	/^} clusterMsg;$/;"	t	language:C	typeref:struct:__anon10
clusterMsgData	cluster.h	/^union clusterMsgData {$/;"	u	language:C
clusterMsgData::__anon6::gossip	cluster.h	/^        clusterMsgDataGossip gossip[1];$/;"	m	language:C	struct:clusterMsgData::__anon6	access:public
clusterMsgData::__anon7::about	cluster.h	/^        clusterMsgDataFail about;$/;"	m	language:C	struct:clusterMsgData::__anon7	access:public
clusterMsgData::__anon8::msg	cluster.h	/^        clusterMsgDataPublish msg;$/;"	m	language:C	struct:clusterMsgData::__anon8	access:public
clusterMsgData::__anon9::nodecfg	cluster.h	/^        clusterMsgDataUpdate nodecfg;$/;"	m	language:C	struct:clusterMsgData::__anon9	access:public
clusterMsgData::fail	cluster.h	/^    } fail;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon7	access:public
clusterMsgData::ping	cluster.h	/^    } ping;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon6	access:public
clusterMsgData::publish	cluster.h	/^    } publish;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon8	access:public
clusterMsgData::update	cluster.h	/^    } update;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon9	access:public
clusterMsgDataFail	cluster.h	/^} clusterMsgDataFail;$/;"	t	language:C	typeref:struct:__anon3
clusterMsgDataGossip	cluster.h	/^} clusterMsgDataGossip;$/;"	t	language:C	typeref:struct:__anon2
clusterMsgDataPublish	cluster.h	/^} clusterMsgDataPublish;$/;"	t	language:C	typeref:struct:__anon4
clusterMsgDataUpdate	cluster.h	/^} clusterMsgDataUpdate;$/;"	t	language:C	typeref:struct:__anon5
clusterNode	cluster.h	/^struct clusterNode;$/;"	x	language:C
clusterNode	cluster.h	/^typedef struct clusterNode {$/;"	s	language:C
clusterNode	cluster.h	/^} clusterNode;$/;"	t	language:C	typeref:struct:clusterNode
clusterNode::configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Last configEpoch observed for this node *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::cport	cluster.h	/^    int cport;                  \/* Latest known cluster port of this node. *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::ctime	cluster.h	/^    mstime_t ctime; \/* Node object creation time. *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::fail_reports	cluster.h	/^    list *fail_reports;         \/* List of nodes signaling this as failing *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::fail_time	cluster.h	/^    mstime_t fail_time;      \/* Unix time when FAIL flag was set *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::flags	cluster.h	/^    int flags;      \/* CLUSTER_NODE_... *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::ip	cluster.h	/^    char ip[NET_IP_STR_LEN];  \/* Latest known IP address of this node *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::link	cluster.h	/^    clusterLink *link;          \/* TCP\/IP link with this node *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::name	cluster.h	/^    char name[CLUSTER_NAMELEN]; \/* Node name, hex string, sha1-size *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::numslaves	cluster.h	/^    int numslaves;  \/* Number of slave nodes, if this is a master *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::numslots	cluster.h	/^    int numslots;   \/* Number of slots handled by this node *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::orphaned_time	cluster.h	/^    mstime_t orphaned_time;     \/* Starting time of orphaned master condition *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::ping_sent	cluster.h	/^    mstime_t ping_sent;      \/* Unix time we sent latest ping *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::pong_received	cluster.h	/^    mstime_t pong_received;  \/* Unix time we received the pong *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::port	cluster.h	/^    int port;                   \/* Latest known clients port of this node *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::repl_offset	cluster.h	/^    long long repl_offset;      \/* Last known repl offset for this node. *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::repl_offset_time	cluster.h	/^    mstime_t repl_offset_time;  \/* Unix time we received offset for this node *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::slaveof	cluster.h	/^    struct clusterNode *slaveof; \/* pointer to the master node. Note that it$/;"	m	language:C	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
clusterNode::slaves	cluster.h	/^    struct clusterNode **slaves; \/* pointers to slave nodes *\/$/;"	m	language:C	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
clusterNode::slots	cluster.h	/^    unsigned char slots[CLUSTER_SLOTS\/8]; \/* slots handled by this node *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNode::voted_time	cluster.h	/^    mstime_t voted_time;     \/* Last time we voted for a slave of this master *\/$/;"	m	language:C	struct:clusterNode	access:public
clusterNodeAddFailureReport	cluster.c	/^int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {$/;"	f	language:C	signature:(clusterNode *failing, clusterNode *sender)
clusterNodeAddSlave	cluster.c	/^int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {$/;"	f	language:C	signature:(clusterNode *master, clusterNode *slave)
clusterNodeAddSlave	cluster.c	/^int clusterNodeAddSlave(clusterNode *master, clusterNode *slave);$/;"	p	language:C	file:	signature:(clusterNode *master, clusterNode *slave)
clusterNodeCleanupFailureReports	cluster.c	/^void clusterNodeCleanupFailureReports(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterNodeClearSlotBit	cluster.c	/^int clusterNodeClearSlotBit(clusterNode *n, int slot) {$/;"	f	language:C	signature:(clusterNode *n, int slot)
clusterNodeDelFailureReport	cluster.c	/^int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {$/;"	f	language:C	signature:(clusterNode *node, clusterNode *sender)
clusterNodeFailReport	cluster.h	/^typedef struct clusterNodeFailReport {$/;"	s	language:C
clusterNodeFailReport	cluster.h	/^} clusterNodeFailReport;$/;"	t	language:C	typeref:struct:clusterNodeFailReport
clusterNodeFailReport::node	cluster.h	/^    struct clusterNode *node;  \/* Node reporting the failure condition. *\/$/;"	m	language:C	struct:clusterNodeFailReport	typeref:struct:clusterNodeFailReport::clusterNode	access:public
clusterNodeFailReport::time	cluster.h	/^    mstime_t time;             \/* Time of the last report from this node. *\/$/;"	m	language:C	struct:clusterNodeFailReport	access:public
clusterNodeFailureReportsCount	cluster.c	/^int clusterNodeFailureReportsCount(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterNodeGetSlotBit	cluster.c	/^int clusterNodeGetSlotBit(clusterNode *n, int slot) {$/;"	f	language:C	signature:(clusterNode *n, int slot)
clusterNodeGetSlotBit	cluster.c	/^int clusterNodeGetSlotBit(clusterNode *n, int slot);$/;"	p	language:C	file:	signature:(clusterNode *n, int slot)
clusterNodeRemoveSlave	cluster.c	/^int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {$/;"	f	language:C	signature:(clusterNode *master, clusterNode *slave)
clusterNodeSetSlotBit	cluster.c	/^int clusterNodeSetSlotBit(clusterNode *n, int slot) {$/;"	f	language:C	signature:(clusterNode *n, int slot)
clusterNodeSetSlotBit	cluster.c	/^int clusterNodeSetSlotBit(clusterNode *n, int slot);$/;"	p	language:C	file:	signature:(clusterNode *n, int slot)
clusterNodesBlackListDictType	server.c	/^dictType clusterNodesBlackListDictType = {$/;"	v	language:C
clusterNodesBlackListDictType	server.h	/^extern dictType clusterNodesBlackListDictType;$/;"	x	language:C
clusterNodesDictType	server.c	/^dictType clusterNodesDictType = {$/;"	v	language:C
clusterNodesDictType	server.h	/^extern dictType clusterNodesDictType;$/;"	x	language:C
clusterProcessGossipSection	cluster.c	/^void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {$/;"	f	language:C	signature:(clusterMsg *hdr, clusterLink *link)
clusterProcessPacket	cluster.c	/^int clusterProcessPacket(clusterLink *link) {$/;"	f	language:C	signature:(clusterLink *link)
clusterPropagatePublish	cluster.c	/^void clusterPropagatePublish(robj *channel, robj *message) {$/;"	f	language:C	signature:(robj *channel, robj *message)
clusterPropagatePublish	server.h	/^void clusterPropagatePublish(robj *channel, robj *message);$/;"	p	language:C	signature:(robj *channel, robj *message)
clusterReadHandler	cluster.c	/^void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterReadHandler	cluster.c	/^void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterRedirectBlockedClientIfNeeded	cluster.c	/^int clusterRedirectBlockedClientIfNeeded(client *c) {$/;"	f	language:C	signature:(client *c)
clusterRedirectBlockedClientIfNeeded	cluster.h	/^int clusterRedirectBlockedClientIfNeeded(client *c);$/;"	p	language:C	signature:(client *c)
clusterRedirectClient	cluster.c	/^void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {$/;"	f	language:C	signature:(client *c, clusterNode *n, int hashslot, int error_code)
clusterRedirectClient	cluster.h	/^void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code);$/;"	p	language:C	signature:(client *c, clusterNode *n, int hashslot, int error_code)
clusterRenameNode	cluster.c	/^void clusterRenameNode(clusterNode *node, char *newname) {$/;"	f	language:C	signature:(clusterNode *node, char *newname)
clusterReplyMultiBulkSlots	cluster.c	/^void clusterReplyMultiBulkSlots(client *c) {$/;"	f	language:C	signature:(client *c)
clusterRequestFailoverAuth	cluster.c	/^void clusterRequestFailoverAuth(void) {$/;"	f	language:C	signature:(void)
clusterReset	cluster.c	/^void clusterReset(int hard) {$/;"	f	language:C	signature:(int hard)
clusterSaveConfig	cluster.c	/^int clusterSaveConfig(int do_fsync) {$/;"	f	language:C	signature:(int do_fsync)
clusterSaveConfigOrDie	cluster.c	/^void clusterSaveConfigOrDie(int do_fsync) {$/;"	f	language:C	signature:(int do_fsync)
clusterSendFail	cluster.c	/^void clusterSendFail(char *nodename) {$/;"	f	language:C	signature:(char *nodename)
clusterSendFail	cluster.c	/^void clusterSendFail(char *nodename);$/;"	p	language:C	file:	signature:(char *nodename)
clusterSendFailoverAuth	cluster.c	/^void clusterSendFailoverAuth(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterSendFailoverAuthIfNeeded	cluster.c	/^void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {$/;"	f	language:C	signature:(clusterNode *node, clusterMsg *request)
clusterSendFailoverAuthIfNeeded	cluster.c	/^void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request);$/;"	p	language:C	file:	signature:(clusterNode *node, clusterMsg *request)
clusterSendMFStart	cluster.c	/^void clusterSendMFStart(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
clusterSendMessage	cluster.c	/^void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {$/;"	f	language:C	signature:(clusterLink *link, unsigned char *msg, size_t msglen)
clusterSendPing	cluster.c	/^void clusterSendPing(clusterLink *link, int type) {$/;"	f	language:C	signature:(clusterLink *link, int type)
clusterSendPing	cluster.c	/^void clusterSendPing(clusterLink *link, int type);$/;"	p	language:C	file:	signature:(clusterLink *link, int type)
clusterSendPublish	cluster.c	/^void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {$/;"	f	language:C	signature:(clusterLink *link, robj *channel, robj *message)
clusterSendUpdate	cluster.c	/^void clusterSendUpdate(clusterLink *link, clusterNode *node) {$/;"	f	language:C	signature:(clusterLink *link, clusterNode *node)
clusterSendUpdate	cluster.c	/^void clusterSendUpdate(clusterLink *link, clusterNode *node);$/;"	p	language:C	file:	signature:(clusterLink *link, clusterNode *node)
clusterSetMaster	cluster.c	/^void clusterSetMaster(clusterNode *n) {$/;"	f	language:C	signature:(clusterNode *n)
clusterSetMaster	cluster.c	/^void clusterSetMaster(clusterNode *n);$/;"	p	language:C	file:	signature:(clusterNode *n)
clusterSetNodeAsMaster	cluster.c	/^void clusterSetNodeAsMaster(clusterNode *n) {$/;"	f	language:C	signature:(clusterNode *n)
clusterSetNodeAsMaster	cluster.c	/^void clusterSetNodeAsMaster(clusterNode *n);$/;"	p	language:C	file:	signature:(clusterNode *n)
clusterStartHandshake	cluster.c	/^int clusterStartHandshake(char *ip, int port, int cport) {$/;"	f	language:C	signature:(char *ip, int port, int cport)
clusterState	cluster.h	/^typedef struct clusterState {$/;"	s	language:C
clusterState	cluster.h	/^} clusterState;$/;"	t	language:C	typeref:struct:clusterState
clusterState	server.h	/^struct clusterState;$/;"	x	language:C
clusterState::cant_failover_reason	cluster.h	/^    int cant_failover_reason;   \/* Why a slave is currently not able to$/;"	m	language:C	struct:clusterState	access:public
clusterState::currentEpoch	cluster.h	/^    uint64_t currentEpoch;$/;"	m	language:C	struct:clusterState	access:public
clusterState::failover_auth_count	cluster.h	/^    int failover_auth_count;    \/* Number of votes received so far. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::failover_auth_epoch	cluster.h	/^    uint64_t failover_auth_epoch; \/* Epoch of the current election. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::failover_auth_rank	cluster.h	/^    int failover_auth_rank;     \/* This slave rank for current auth request. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::failover_auth_sent	cluster.h	/^    int failover_auth_sent;     \/* True if we already asked for votes. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::failover_auth_time	cluster.h	/^    mstime_t failover_auth_time; \/* Time of previous or next election. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::importing_slots_from	cluster.h	/^    clusterNode *importing_slots_from[CLUSTER_SLOTS];$/;"	m	language:C	struct:clusterState	access:public
clusterState::lastVoteEpoch	cluster.h	/^    uint64_t lastVoteEpoch;     \/* Epoch of the last vote granted. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::mf_can_start	cluster.h	/^    int mf_can_start;           \/* If non-zero signal that the manual failover$/;"	m	language:C	struct:clusterState	access:public
clusterState::mf_end	cluster.h	/^    mstime_t mf_end;            \/* Manual failover time limit (ms unixtime).$/;"	m	language:C	struct:clusterState	access:public
clusterState::mf_master_offset	cluster.h	/^    long long mf_master_offset; \/* Master offset the slave needs to start MF$/;"	m	language:C	struct:clusterState	access:public
clusterState::mf_slave	cluster.h	/^    clusterNode *mf_slave;      \/* Slave performing the manual failover. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::migrating_slots_to	cluster.h	/^    clusterNode *migrating_slots_to[CLUSTER_SLOTS];$/;"	m	language:C	struct:clusterState	access:public
clusterState::myself	cluster.h	/^    clusterNode *myself;  \/* This node *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::nodes	cluster.h	/^    dict *nodes;          \/* Hash table of name -> clusterNode structures *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::nodes_black_list	cluster.h	/^    dict *nodes_black_list; \/* Nodes we don't re-add for a few seconds. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::size	cluster.h	/^    int size;             \/* Num of master nodes with at least one slot *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::slots	cluster.h	/^    clusterNode *slots[CLUSTER_SLOTS];$/;"	m	language:C	struct:clusterState	access:public
clusterState::slots_to_keys	cluster.h	/^    zskiplist *slots_to_keys;$/;"	m	language:C	struct:clusterState	access:public
clusterState::state	cluster.h	/^    int state;            \/* CLUSTER_OK, CLUSTER_FAIL, ... *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::stats_bus_messages_received	cluster.h	/^    long long stats_bus_messages_received; \/* Num of msg rcvd via cluster bus.*\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::stats_bus_messages_sent	cluster.h	/^    long long stats_bus_messages_sent;  \/* Num of msg sent via cluster bus. *\/$/;"	m	language:C	struct:clusterState	access:public
clusterState::todo_before_sleep	cluster.h	/^    int todo_before_sleep; \/* Things to do in clusterBeforeSleep(). *\/$/;"	m	language:C	struct:clusterState	access:public
clusterUpdateSlotsConfigWith	cluster.c	/^void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {$/;"	f	language:C	signature:(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots)
clusterUpdateState	cluster.c	/^void clusterUpdateState(void) {$/;"	f	language:C	signature:(void)
clusterUpdateState	cluster.c	/^void clusterUpdateState(void);$/;"	p	language:C	file:	signature:(void)
clusterWriteHandler	cluster.c	/^void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
cluster_announce_bus_port	server.h	/^    int cluster_announce_bus_port; \/* bus port to announce on cluster bus. *\/$/;"	m	language:C	struct:redisServer	access:public
cluster_announce_ip	server.h	/^    char *cluster_announce_ip;  \/* IP address to announce on cluster bus. *\/$/;"	m	language:C	struct:redisServer	access:public
cluster_announce_port	server.h	/^    int cluster_announce_port;     \/* base port to announce on cluster bus. *\/$/;"	m	language:C	struct:redisServer	access:public
cluster_configfile	server.h	/^    char *cluster_configfile; \/* Cluster auto-generated config file name. *\/$/;"	m	language:C	struct:redisServer	access:public
cluster_enabled	server.h	/^    int cluster_enabled;      \/* Is cluster enabled? *\/$/;"	m	language:C	struct:redisServer	access:public
cluster_migration_barrier	server.h	/^    int cluster_migration_barrier; \/* Cluster replicas migration barrier. *\/$/;"	m	language:C	struct:redisServer	access:public
cluster_mode	redis-cli.c	/^    int cluster_mode;$/;"	m	language:C	struct:config	file:	access:public
cluster_node_timeout	server.h	/^    mstime_t cluster_node_timeout; \/* Cluster node timeout. *\/$/;"	m	language:C	struct:redisServer	access:public
cluster_reissue_command	redis-cli.c	/^    int cluster_reissue_command;$/;"	m	language:C	struct:config	file:	access:public
cluster_require_full_coverage	server.h	/^    int cluster_require_full_coverage; \/* If true, put the cluster down if$/;"	m	language:C	struct:redisServer	access:public
cluster_slave_validity_factor	server.h	/^    int cluster_slave_validity_factor; \/* Slave max data age for failover. *\/$/;"	m	language:C	struct:redisServer	access:public
clvector	dict.c	/^    unsigned long clvector[DICT_STATS_VECTLEN];$/;"	l	language:C
cmd	aof.c	/^                char cmd[]="*3\\r\\n$3\\r\\nSET\\r\\n";$/;"	l	language:C
cmd	aof.c	/^                char cmd[]="*3\\r\\n$9\\r\\nPEXPIREAT\\r\\n";$/;"	l	language:C
cmd	aof.c	/^        struct redisCommand *cmd;$/;"	l	language:C
cmd	cluster.c	/^    rio cmd, payload;$/;"	l	language:C
cmd	config.c	/^            struct redisCommand *cmd = lookupCommand(argv[1]);$/;"	l	language:C
cmd	hyperloglog.c	/^    char *cmd = c->argv[1]->ptr;$/;"	l	language:C
cmd	module.c	/^        struct redisCommand *cmd = dictGetVal(de);$/;"	l	language:C
cmd	module.c	/^    struct redisCommand *cmd;$/;"	l	language:C
cmd	redis-benchmark.c	/^    char *data, *cmd;$/;"	l	language:C
cmd	replication.c	/^        sds cmd = sdsempty();$/;"	l	language:C
cmd	scripting.c	/^    struct redisCommand *cmd;$/;"	l	language:C
cmd	sentinel.c	/^        struct redisCommand *cmd = sentinelcmds+j;$/;"	l	language:C
cmd	server.c	/^        struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);$/;"	l	language:C
cmd	server.c	/^    struct redisCommand *cmd = dictFetchValue(server.commands, name);$/;"	l	language:C
cmd	server.c	/^    struct redisCommand *cmd;$/;"	l	language:C
cmd	server.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	language:C	struct:client	typeref:struct:client::redisCommand	access:public
cmd	server.h	/^    struct redisCommand *cmd;$/;"	m	language:C	struct:multiCmd	typeref:struct:multiCmd::redisCommand	access:public
cmd	server.h	/^    struct redisCommand *cmd;$/;"	m	language:C	struct:redisOp	typeref:struct:redisOp::redisCommand	access:public
cmd_items	aof.c	/^                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?$/;"	l	language:C
cmd_items	aof.c	/^            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?$/;"	l	language:C
cmdlog	scripting.c	/^        sds cmdlog = sdsnew("<redis>");$/;"	l	language:C
cmdname	module.c	/^            sds cmdname = cp->rediscmd->name;$/;"	l	language:C
cmdname	module.c	/^    sds cmdname = sdsnew(name);$/;"	l	language:C
cmdname	redis-cli.c	/^        char *cmdname = entry->element[0]->str;$/;"	l	language:C
cmdobj	replication.c	/^    robj *cmdobj;$/;"	l	language:C
cmdrepr	replication.c	/^    sds cmdrepr = sdsnew("+");$/;"	l	language:C
cmp	object.c	/^        int cmp;$/;"	l	language:C
cmp	sds.c	/^    int cmp;$/;"	l	language:C
cmp	server.c	/^    int cmp;$/;"	l	language:C
cmp	sort.c	/^    int cmp;$/;"	l	language:C
cmp	t_zset.c	/^    int minlen, cmp;$/;"	l	language:C
cmp_result	pqsort.c	/^	int swaptype, cmp_result;$/;"	l	language:C
cmpobj	server.h	/^        robj *cmpobj;$/;"	m	language:C	union:_redisSortObject::__anon30	access:public
cn	cluster.c	/^                clusterNode *cn;$/;"	l	language:C
cnegone	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
cobj	pubsub.c	/^            robj *cobj = dictGetKey(de);$/;"	l	language:C
code	scripting.c	/^    sds code = sdsempty();$/;"	l	language:C
code	scripting.c	/^    sds code = sdsjoinsds(argv+1,argc-1," ",1);$/;"	l	language:C
collateStringObjects	object.c	/^int collateStringObjects(robj *a, robj *b) {$/;"	f	language:C	signature:(robj *a, robj *b)
collateStringObjects	server.h	/^int collateStringObjects(robj *a, robj *b);$/;"	p	language:C	signature:(robj *a, robj *b)
colon	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
color	redis-cli.c	/^        int color = spectrum_palette[coloridx];$/;"	l	language:C
color	redis-cli.c	/^    char *color = "white";$/;"	l	language:C
color	redis-trib.rb	/^        color="33"$/;"	v	language:C
coloridx	redis-cli.c	/^        int coloridx =$/;"	l	language:C
command	modules/API.md	/^Send an error about the number of arguments given to the command,$/;"	v	language:C
command	modules/API.md	/^execute some command, as we want to reply to the client exactly the$/;"	v	language:C
command	modules/INTRO.md	/^API could be a simpler way to implement your command, or you can use$/;"	v	language:C
command	modules/INTRO.md	/^This function returns an integer to the client that invoked the command,$/;"	v	language:C
command	modules/TYPES.md	/^in AOF, the type reporting via the `TYPE` command, and so forth.$/;"	v	language:C
command	redis-cli.c	/^    char *command = argv[0];$/;"	l	language:C
commandCommand	server.c	/^void commandCommand(client *c) {$/;"	f	language:C	signature:(client *c)
commandCommand	server.h	/^void commandCommand(client *c);$/;"	p	language:C	signature:(client *c)
commandFlagsFromString	module.c	/^int commandFlagsFromString(char *s) {$/;"	f	language:C	signature:(char *s)
commandGroups	help.h	/^static char *commandGroups[] = {$/;"	v	language:C
commandHelp	help.h	/^struct commandHelp {$/;"	s	language:C
commandHelp	help.h	/^} commandHelp[] = {$/;"	v	language:C	typeref:struct:commandHelp
commandHelp::group	help.h	/^  int group;$/;"	m	language:C	struct:commandHelp	access:public
commandHelp::name	help.h	/^  char *name;$/;"	m	language:C	struct:commandHelp	access:public
commandHelp::params	help.h	/^  char *params;$/;"	m	language:C	struct:commandHelp	access:public
commandHelp::since	help.h	/^  char *since;$/;"	m	language:C	struct:commandHelp	access:public
commandHelp::summary	help.h	/^  char *summary;$/;"	m	language:C	struct:commandHelp	access:public
commandTableDictType	server.c	/^dictType commandTableDictType = {$/;"	v	language:C
commands	modules/INTRO.md	/^register its commands, and potentially other private data structures$/;"	v	language:C
commands	modules/TYPES.md	/^by calling Redis commands, and at low level, by manipulating the data structures$/;"	v	language:C
commands	server.h	/^    dict *commands;             \/* Command table *\/$/;"	m	language:C	struct:redisServer	access:public
commands	server.h	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	language:C	struct:multiState	access:public
commandslen	redis-cli.c	/^    int commandslen = sizeof(commandHelp)\/sizeof(struct commandHelp);$/;"	l	language:C
compareLatency	redis-benchmark.c	/^static int compareLatency(const void *a, const void *b) {$/;"	f	language:C	file:	signature:(const void *a, const void *b)
compareSlavesForPromotion	sentinel.c	/^int compareSlavesForPromotion(const void *a, const void *b) {$/;"	f	language:C	signature:(const void *a, const void *b)
compareStringObjects	object.c	/^int compareStringObjects(robj *a, robj *b) {$/;"	f	language:C	signature:(robj *a, robj *b)
compareStringObjects	server.h	/^int compareStringObjects(robj *a, robj *b);$/;"	p	language:C	signature:(robj *a, robj *b)
compareStringObjectsWithFlags	object.c	/^int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {$/;"	f	language:C	signature:(robj *a, robj *b, int flags)
compare_func	scripting.c	/^        char *compare_func =    "function __redis__compare_helper(a,b)\\n"$/;"	l	language:C
completionCallback	redis-cli.c	/^static void completionCallback(const char *buf, linenoiseCompletions *lc) {$/;"	f	language:C	file:	signature:(const char *buf, linenoiseCompletions *lc)
compress	quicklist.h	/^    unsigned int compress : 16; \/* depth of end nodes not to compress;0=off *\/$/;"	m	language:C	struct:quicklist	access:public
compress_len	rdb.c	/^                    size_t compress_len = quicklistGetLzf(node, &data);$/;"	l	language:C
compressed	debug.c	/^            int compressed = ql->compress != 0;$/;"	l	language:C
compressed	quicklist.h	/^    char compressed[];$/;"	m	language:C	struct:quicklistLZF	access:public
comprlen	rdb.c	/^    size_t comprlen, outlen;$/;"	l	language:C
computeDatasetDigest	debug.c	/^void computeDatasetDigest(unsigned char *final) {$/;"	f	language:C	signature:(unsigned char *final)
compute_something_fast	redis-cli.c	/^unsigned long compute_something_fast(void) {$/;"	f	language:C	signature:(void)
cone	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
config	config.c	/^    sds config = sdsempty();$/;"	l	language:C
config	redis-benchmark.c	/^static struct config {$/;"	s	language:C	file:
config	redis-benchmark.c	/^} config;$/;"	v	language:C	typeref:struct:config	file:
config	redis-cli.c	/^static struct config {$/;"	s	language:C	file:
config	redis-cli.c	/^} config;$/;"	v	language:C	typeref:struct:config	file:
config::auth	redis-benchmark.c	/^    char *auth;$/;"	m	language:C	struct:config	file:	access:public
config::auth	redis-cli.c	/^    char *auth;$/;"	m	language:C	struct:config	file:	access:public
config::bigkeys	redis-cli.c	/^    int bigkeys;$/;"	m	language:C	struct:config	file:	access:public
config::clients	redis-benchmark.c	/^    list *clients;$/;"	m	language:C	struct:config	file:	access:public
config::cluster_mode	redis-cli.c	/^    int cluster_mode;$/;"	m	language:C	struct:config	file:	access:public
config::cluster_reissue_command	redis-cli.c	/^    int cluster_reissue_command;$/;"	m	language:C	struct:config	file:	access:public
config::csv	redis-benchmark.c	/^    int csv;$/;"	m	language:C	struct:config	file:	access:public
config::datasize	redis-benchmark.c	/^    int datasize;$/;"	m	language:C	struct:config	file:	access:public
config::dbnum	redis-benchmark.c	/^    int dbnum;$/;"	m	language:C	struct:config	file:	access:public
config::dbnum	redis-cli.c	/^    int dbnum;$/;"	m	language:C	struct:config	file:	access:public
config::dbnumstr	redis-benchmark.c	/^    sds dbnumstr;$/;"	m	language:C	struct:config	file:	access:public
config::el	redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	language:C	struct:config	file:	access:public
config::enable_ldb_on_eval	redis-cli.c	/^    int enable_ldb_on_eval; \/* Handle manual SCRIPT DEBUG + EVAL commands. *\/$/;"	m	language:C	struct:config	file:	access:public
config::eval	redis-cli.c	/^    char *eval;$/;"	m	language:C	struct:config	file:	access:public
config::eval_ldb	redis-cli.c	/^    int eval_ldb;$/;"	m	language:C	struct:config	file:	access:public
config::eval_ldb_end	redis-cli.c	/^    int eval_ldb_end;   \/* Lua debugging session ended. *\/$/;"	m	language:C	struct:config	file:	access:public
config::eval_ldb_sync	redis-cli.c	/^    int eval_ldb_sync;  \/* Ask for synchronous mode of the Lua debugger. *\/$/;"	m	language:C	struct:config	file:	access:public
config::getrdb_mode	redis-cli.c	/^    int getrdb_mode;$/;"	m	language:C	struct:config	file:	access:public
config::hostip	redis-benchmark.c	/^    const char *hostip;$/;"	m	language:C	struct:config	file:	access:public
config::hostip	redis-cli.c	/^    char *hostip;$/;"	m	language:C	struct:config	file:	access:public
config::hostport	redis-benchmark.c	/^    int hostport;$/;"	m	language:C	struct:config	file:	access:public
config::hostport	redis-cli.c	/^    int hostport;$/;"	m	language:C	struct:config	file:	access:public
config::hostsocket	redis-benchmark.c	/^    const char *hostsocket;$/;"	m	language:C	struct:config	file:	access:public
config::hostsocket	redis-cli.c	/^    char *hostsocket;$/;"	m	language:C	struct:config	file:	access:public
config::idlemode	redis-benchmark.c	/^    int idlemode;$/;"	m	language:C	struct:config	file:	access:public
config::interactive	redis-cli.c	/^    int interactive;$/;"	m	language:C	struct:config	file:	access:public
config::interval	redis-cli.c	/^    long interval;$/;"	m	language:C	struct:config	file:	access:public
config::intrinsic_latency_duration	redis-cli.c	/^    int intrinsic_latency_duration;$/;"	m	language:C	struct:config	file:	access:public
config::intrinsic_latency_mode	redis-cli.c	/^    int intrinsic_latency_mode;$/;"	m	language:C	struct:config	file:	access:public
config::keepalive	redis-benchmark.c	/^    int keepalive;$/;"	m	language:C	struct:config	file:	access:public
config::keysize	redis-benchmark.c	/^    int keysize;$/;"	m	language:C	struct:config	file:	access:public
config::last_cmd_type	redis-cli.c	/^    int last_cmd_type;$/;"	m	language:C	struct:config	file:	access:public
config::latency	redis-benchmark.c	/^    long long *latency;$/;"	m	language:C	struct:config	file:	access:public
config::latency_dist_mode	redis-cli.c	/^    int latency_dist_mode;$/;"	m	language:C	struct:config	file:	access:public
config::latency_history	redis-cli.c	/^    int latency_history;$/;"	m	language:C	struct:config	file:	access:public
config::latency_mode	redis-cli.c	/^    int latency_mode;$/;"	m	language:C	struct:config	file:	access:public
config::liveclients	redis-benchmark.c	/^    int liveclients;$/;"	m	language:C	struct:config	file:	access:public
config::loop	redis-benchmark.c	/^    int loop;$/;"	m	language:C	struct:config	file:	access:public
config::lru_test_mode	redis-cli.c	/^    int lru_test_mode;$/;"	m	language:C	struct:config	file:	access:public
config::lru_test_sample_size	redis-cli.c	/^    long long lru_test_sample_size;$/;"	m	language:C	struct:config	file:	access:public
config::mb_delim	redis-cli.c	/^    sds mb_delim;$/;"	m	language:C	struct:config	file:	access:public
config::monitor_mode	redis-cli.c	/^    int monitor_mode;$/;"	m	language:C	struct:config	file:	access:public
config::numclients	redis-benchmark.c	/^    int numclients;$/;"	m	language:C	struct:config	file:	access:public
config::output	redis-cli.c	/^    int output; \/* output mode, see OUTPUT_* defines *\/$/;"	m	language:C	struct:config	file:	access:public
config::pattern	redis-cli.c	/^    char *pattern;$/;"	m	language:C	struct:config	file:	access:public
config::pipe_mode	redis-cli.c	/^    int pipe_mode;$/;"	m	language:C	struct:config	file:	access:public
config::pipe_timeout	redis-cli.c	/^    int pipe_timeout;$/;"	m	language:C	struct:config	file:	access:public
config::pipeline	redis-benchmark.c	/^    int pipeline;$/;"	m	language:C	struct:config	file:	access:public
config::prompt	redis-cli.c	/^    char prompt[128];$/;"	m	language:C	struct:config	file:	access:public
config::pubsub_mode	redis-cli.c	/^    int pubsub_mode;$/;"	m	language:C	struct:config	file:	access:public
config::quiet	redis-benchmark.c	/^    int quiet;$/;"	m	language:C	struct:config	file:	access:public
config::randomkeys	redis-benchmark.c	/^    int randomkeys;$/;"	m	language:C	struct:config	file:	access:public
config::randomkeys_keyspacelen	redis-benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	language:C	struct:config	file:	access:public
config::rdb_filename	redis-cli.c	/^    char *rdb_filename;$/;"	m	language:C	struct:config	file:	access:public
config::repeat	redis-cli.c	/^    long repeat;$/;"	m	language:C	struct:config	file:	access:public
config::requests	redis-benchmark.c	/^    int requests;$/;"	m	language:C	struct:config	file:	access:public
config::requests_finished	redis-benchmark.c	/^    int requests_finished;$/;"	m	language:C	struct:config	file:	access:public
config::requests_issued	redis-benchmark.c	/^    int requests_issued;$/;"	m	language:C	struct:config	file:	access:public
config::scan_mode	redis-cli.c	/^    int scan_mode;$/;"	m	language:C	struct:config	file:	access:public
config::showerrors	redis-benchmark.c	/^    int showerrors;$/;"	m	language:C	struct:config	file:	access:public
config::shutdown	redis-cli.c	/^    int shutdown;$/;"	m	language:C	struct:config	file:	access:public
config::slave_mode	redis-cli.c	/^    int slave_mode;$/;"	m	language:C	struct:config	file:	access:public
config::start	redis-benchmark.c	/^    long long start;$/;"	m	language:C	struct:config	file:	access:public
config::stat_mode	redis-cli.c	/^    int stat_mode;$/;"	m	language:C	struct:config	file:	access:public
config::stdinarg	redis-cli.c	/^    int stdinarg; \/* get last arg from stdin. (-x option) *\/$/;"	m	language:C	struct:config	file:	access:public
config::tests	redis-benchmark.c	/^    char *tests;$/;"	m	language:C	struct:config	file:	access:public
config::title	redis-benchmark.c	/^    const char *title;$/;"	m	language:C	struct:config	file:	access:public
config::totlatency	redis-benchmark.c	/^    long long totlatency;$/;"	m	language:C	struct:config	file:	access:public
configCommand	config.c	/^void configCommand(client *c) {$/;"	f	language:C	signature:(client *c)
configCommand	server.h	/^void configCommand(client *c);$/;"	p	language:C	signature:(client *c)
configEnum	config.c	/^typedef struct configEnum {$/;"	s	language:C	file:
configEnum	config.c	/^} configEnum;$/;"	t	language:C	typeref:struct:configEnum	file:
configEnum::name	config.c	/^    const char *name;$/;"	m	language:C	struct:configEnum	file:	access:public
configEnum::val	config.c	/^    const int val;$/;"	m	language:C	struct:configEnum	file:	access:public
configEnumGetName	config.c	/^const char *configEnumGetName(configEnum *ce, int val) {$/;"	f	language:C	signature:(configEnum *ce, int val)
configEnumGetNameOrUnknown	config.c	/^const char *configEnumGetNameOrUnknown(configEnum *ce, int val) {$/;"	f	language:C	signature:(configEnum *ce, int val)
configEnumGetValue	config.c	/^int configEnumGetValue(configEnum *ce, char *name) {$/;"	f	language:C	signature:(configEnum *ce, char *name)
configEpoch	cluster.h	/^    uint64_t configEpoch;   \/* The config epoch if it's a master, or the last$/;"	m	language:C	struct:__anon10	access:public
configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Config epoch of the specified instance. *\/$/;"	m	language:C	struct:__anon5	access:public
configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Last configEpoch observed for this node *\/$/;"	m	language:C	struct:clusterNode	access:public
configGetCommand	config.c	/^void configGetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
configSetCommand	config.c	/^void configSetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
config_epoch	sentinel.c	/^    uint64_t config_epoch;  \/* Configuration epoch. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
config_get_bool_field	config.c	/^#define config_get_bool_field(/;"	d	language:C	file:
config_get_enum_field	config.c	/^#define config_get_enum_field(/;"	d	language:C	file:
config_get_numerical_field	config.c	/^#define config_get_numerical_field(/;"	d	language:C	file:
config_get_string_field	config.c	/^#define config_get_string_field(/;"	d	language:C	file:
config_set_bool_field	config.c	/^#define config_set_bool_field(/;"	d	language:C	file:
config_set_else	config.c	/^#define config_set_else /;"	d	language:C	file:
config_set_enum_field	config.c	/^#define config_set_enum_field(/;"	d	language:C	file:
config_set_memory_field	config.c	/^#define config_set_memory_field(/;"	d	language:C	file:
config_set_numerical_field	config.c	/^#define config_set_numerical_field(/;"	d	language:C	file:
config_set_special_field	config.c	/^#define config_set_special_field(/;"	d	language:C	file:
configfile	server.c	/^        char *configfile = NULL;$/;"	l	language:C
configfile	server.h	/^    char *configfile;           \/* Absolute config file path, or NULL *\/$/;"	m	language:C	struct:redisServer	access:public
connectWithMaster	replication.c	/^int connectWithMaster(void) {$/;"	f	language:C	signature:(void)
consumeNewline	redis-check-aof.c	/^int consumeNewline(char *buf) {$/;"	f	language:C	signature:(char *buf)
container	quicklist.h	/^    unsigned int container : 2;  \/* NONE==1 or ZIPLIST==2 *\/$/;"	m	language:C	struct:quicklistNode	access:public
content	config.c	/^    sds content = sdsempty();$/;"	l	language:C
content_padded	config.c	/^    sds content_padded;$/;"	l	language:C
content_size	cluster.c	/^    size_t content_size;$/;"	l	language:C
content_size	config.c	/^    int content_size = sdslen(content), padding = 0;$/;"	l	language:C
contents	intset.h	/^    int8_t contents[];$/;"	m	language:C	struct:intset	access:public
context	modules/INTRO.md	/^The command function arguments are just the context, that will be passed$/;"	v	language:C
context	modules/INTRO.md	/^The first argument is the context, and the second is always a null terminated$/;"	v	language:C
context	redis-benchmark.c	/^    redisContext *context;$/;"	m	language:C	struct:_client	file:	access:public
context	redis-cli.c	/^static redisContext *context;$/;"	v	language:C	file:
context	sentinel.c	/^    redisAsyncContext *context;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
conv	bitops.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	l	language:C
conv	hyperloglog.c	/^        int conv = 0;$/;"	l	language:C
conv	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	l	language:C
convention	modules/INTRO.md	/^`RedisModule_Call` uses a special calling convention, with a format specifier$/;"	v	language:C
conversion	geo.c	/^    double radius_meters = 0, conversion = 1;$/;"	l	language:C
convertToSds	redis-cli.c	/^static char **convertToSds(int count, char** args) {$/;"	f	language:C	file:	signature:(int count, char** args)
copy	adlist.c	/^    list *copy;$/;"	l	language:C
copy	cluster.c	/^    int copy, replace, j;$/;"	l	language:C
copy	config.c	/^                sds copy = sdsdup(argv[2]);$/;"	l	language:C
copy	db.c	/^    sds copy = sdsdup(key->ptr);$/;"	l	language:C
copy	quicklist.c	/^            quicklist *copy = quicklistDup(ql);$/;"	l	language:C
copy	quicklist.c	/^    quicklist *copy;$/;"	l	language:C
copyClientOutputBuffer	networking.c	/^void copyClientOutputBuffer(client *dst, client *src) {$/;"	f	language:C	signature:(client *dst, client *src)
copyClientOutputBuffer	server.h	/^void copyClientOutputBuffer(client *dst, client *src);$/;"	p	language:C	signature:(client *dst, client *src)
copy_keeper	sentinel.c	/^        dictType copy_keeper = instancesDictType;$/;"	l	language:C
copylen	util.c	/^            unsigned int copylen = len > 20 ? 20 : len;$/;"	l	language:C
count	aof.c	/^    long long count = 0, items = hashTypeLength(o);$/;"	l	language:C
count	aof.c	/^    long long count = 0, items = listTypeLength(o);$/;"	l	language:C
count	aof.c	/^    long long count = 0, items = setTypeSize(o);$/;"	l	language:C
count	aof.c	/^    long long count = 0, items = zsetLength(o);$/;"	l	language:C
count	aof.c	/^    ssize_t count = 0;$/;"	l	language:C
count	cluster.c	/^        uint16_t count = ntohs(hdr->count);$/;"	l	language:C
count	cluster.c	/^    uint16_t count = ntohs(hdr->count);$/;"	l	language:C
count	cluster.h	/^    uint16_t count;     \/* Only used for some kind of messages. *\/$/;"	m	language:C	struct:__anon10	access:public
count	db.c	/^    int rank, count = 0;$/;"	l	language:C
count	db.c	/^    long count = 10;$/;"	l	language:C
count	db.c	/^    long long count = 0;$/;"	l	language:C
count	evict.c	/^    int j, k, count;$/;"	l	language:C
count	geo.c	/^    long long count = 0;$/;"	l	language:C
count	geo.c	/^    unsigned int i, count = 0, last_processed = 0;$/;"	l	language:C
count	hyperloglog.c	/^    int count;$/;"	l	language:C
count	hyperloglog.c	/^    uint8_t oldcount, count, *sparse, *end, *p, *prev, *next;$/;"	l	language:C
count	hyperloglog.c	/^    uint8_t oldcount, count;$/;"	l	language:C
count	module.c	/^    int count = (ctx->amqueue_used+1)\/2;$/;"	l	language:C
count	module.c	/^    int count, j;$/;"	l	language:C
count	modules/TYPES.md	/^        size_t count;$/;"	m	language:C	struct:double_array	file:	access:public
count	modules/hellotype.c	/^    long long first, count;$/;"	l	language:C
count	modules/helloworld.c	/^    long long count;$/;"	l	language:C
count	networking.c	/^    int count = 0;$/;"	l	language:C
count	pubsub.c	/^    int count = 0;$/;"	l	language:C
count	quicklist.c	/^            int i = 499, count = 0;$/;"	l	language:C
count	quicklist.h	/^    unsigned int count : 16;     \/* count of items in ziplist *\/$/;"	m	language:C	struct:quicklistNode	access:public
count	quicklist.h	/^    unsigned long count;        \/* total count of all entries in all ziplists *\/$/;"	m	language:C	struct:quicklist	access:public
count	redis-cli.c	/^    int count = 1000, k;$/;"	l	language:C
count	redis-cli.c	/^    long long count; \/* Number of samples in this interval. *\/$/;"	m	language:C	struct:distsamples	file:	access:public
count	redis-cli.c	/^    long long start, latency, count = 0;$/;"	l	language:C
count	redis-cli.c	/^    long long start, latency, min = 0, max = 0, tot = 0, count = 0;$/;"	l	language:C
count	replication.c	/^    int count = 0;$/;"	l	language:C
count	rio.c	/^        size_t count = len < 1024 ? len : 1024;$/;"	l	language:C
count	server.h	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	language:C	struct:multiState	access:public
count	sha1.h	/^    uint32_t count[2];$/;"	m	language:C	struct:__anon39	access:public
count	slowlog.c	/^        long count = 10, sent = 0;$/;"	l	language:C
count	t_hash.c	/^    int length, count = 0;$/;"	l	language:C
count	t_set.c	/^    unsigned long count, size;$/;"	l	language:C
count	t_zset.c	/^    int count = 0;$/;"	l	language:C
count	zmalloc.c	/^    int fd, count;$/;"	l	language:C
countKeysInSlot	db.c	/^unsigned int countKeysInSlot(unsigned int hashslot) {$/;"	f	language:C	signature:(unsigned int hashslot)
countKeysInSlot	server.h	/^unsigned int countKeysInSlot(unsigned int hashslot);$/;"	p	language:C	signature:(unsigned int hashslot)
counter	crc16.c	/^    int counter;$/;"	l	language:C
counter	db.c	/^                unsigned long counter = LFULogIncr(val->lru & 255);$/;"	l	language:C
counter	evict.c	/^    unsigned long counter = o->lru & 255;$/;"	l	language:C
counter	util.c	/^    static uint64_t counter = 0; \/* The counter we hash with the seed. *\/$/;"	l	language:C	file:
counters	sentinel.c	/^    dict *counters;$/;"	l	language:C
counts	redis-cli.c	/^    unsigned long long biggest[5] = {0}, counts[5] = {0}, totalsize[5] = {0};$/;"	l	language:C
cp	module.c	/^            RedisModuleCommandProxy *cp =$/;"	l	language:C
cp	module.c	/^    RedisModuleCommandProxy *cp = (void*)(unsigned long)c->cmd->getkeys_proc;$/;"	l	language:C
cp	module.c	/^    RedisModuleCommandProxy *cp = (void*)(unsigned long)cmd->getkeys_proc;$/;"	l	language:C
cp	module.c	/^    RedisModuleCommandProxy *cp;$/;"	l	language:C
cp	scripting.c	/^        pid_t cp = fork();$/;"	l	language:C
cport	cluster.c	/^        long long port, cport;$/;"	l	language:C
cport	cluster.c	/^    int cport = ntohs(hdr->cport);$/;"	l	language:C
cport	cluster.c	/^    int cport, cfd;$/;"	l	language:C
cport	cluster.h	/^    int cport;                  \/* Latest known cluster port of this node. *\/$/;"	m	language:C	struct:clusterNode	access:public
cport	cluster.h	/^    uint16_t cport;             \/* cluster port last time it was seen *\/$/;"	m	language:C	struct:__anon2	access:public
cport	cluster.h	/^    uint16_t cport;      \/* Sender TCP cluster bus port *\/$/;"	m	language:C	struct:__anon10	access:public
cport	networking.c	/^    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;$/;"	l	language:C
cpy	sds.c	/^    va_list cpy;$/;"	l	language:C
crc	cluster.c	/^    uint64_t crc;$/;"	l	language:C
crc	crc16.c	/^    uint16_t crc = 0;$/;"	l	language:C
crc16	crc16.c	/^uint16_t crc16(const char *buf, int len) {$/;"	f	language:C	signature:(const char *buf, int len)
crc16	server.h	/^unsigned short crc16(const char *buf, int len);$/;"	p	language:C	signature:(const char *buf, int len)
crc16tab	crc16.c	/^static const uint16_t crc16tab[256]= {$/;"	v	language:C	file:
crc64	crc64.c	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {$/;"	f	language:C	signature:(uint64_t crc, const unsigned char *s, uint64_t l)
crc64	crc64.h	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);$/;"	p	language:C	signature:(uint64_t crc, const unsigned char *s, uint64_t l)
crc64	server.h	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);$/;"	p	language:C	signature:(uint64_t crc, const unsigned char *s, uint64_t l)
crc64Test	crc64.c	/^int crc64Test(int argc, char *argv[]) {$/;"	f	language:C	signature:(int argc, char *argv[])
crc64Test	crc64.h	/^int crc64Test(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
crc64_tab	crc64.c	/^static const uint64_t crc64_tab[256] = {$/;"	v	language:C	file:
createClient	networking.c	/^client *createClient(int fd) {$/;"	f	language:C	signature:(int fd)
createClient	redis-benchmark.c	/^static client createClient(char *cmd, size_t len, client from) {$/;"	f	language:C	file:	signature:(char *cmd, size_t len, client from)
createClient	server.h	/^client *createClient(int fd);$/;"	p	language:C	signature:(int fd)
createClusterLink	cluster.c	/^clusterLink *createClusterLink(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
createClusterNode	cluster.c	/^clusterNode *createClusterNode(char *nodename, int flags) {$/;"	f	language:C	signature:(char *nodename, int flags)
createClusterNode	cluster.c	/^clusterNode *createClusterNode(char *nodename, int flags);$/;"	p	language:C	file:	signature:(char *nodename, int flags)
createDumpPayload	cluster.c	/^void createDumpPayload(rio *payload, robj *o) {$/;"	f	language:C	signature:(rio *payload, robj *o)
createEmbeddedStringObject	object.c	/^robj *createEmbeddedStringObject(const char *ptr, size_t len) {$/;"	f	language:C	signature:(const char *ptr, size_t len)
createEmbeddedStringObject	server.h	/^robj *createEmbeddedStringObject(const char *ptr, size_t len);$/;"	p	language:C	signature:(const char *ptr, size_t len)
createFakeClient	aof.c	/^struct client *createFakeClient(void) {$/;"	f	language:C	signature:(void)
createHLLObject	hyperloglog.c	/^robj *createHLLObject(void) {$/;"	f	language:C	signature:(void)
createHashObject	object.c	/^robj *createHashObject(void) {$/;"	f	language:C	signature:(void)
createHashObject	server.h	/^robj *createHashObject(void);$/;"	p	language:C	signature:(void)
createHelloTypeObject	modules/hellotype.c	/^struct HelloTypeObject *createHelloTypeObject(void) {$/;"	f	language:C	signature:(void)
createInstanceLink	sentinel.c	/^instanceLink *createInstanceLink(void) {$/;"	f	language:C	signature:(void)
createIntList	ziplist.c	/^static unsigned char *createIntList() {$/;"	f	language:C	file:
createIntsetObject	object.c	/^robj *createIntsetObject(void) {$/;"	f	language:C	signature:(void)
createIntsetObject	server.h	/^robj *createIntsetObject(void);$/;"	p	language:C	signature:(void)
createLatencyReport	latency.c	/^sds createLatencyReport(void) {$/;"	f	language:C	signature:(void)
createList	ziplist.c	/^static unsigned char *createList() {$/;"	f	language:C	file:
createMissingClients	redis-benchmark.c	/^static void createMissingClients(client c) {$/;"	f	language:C	file:	signature:(client c)
createMissingClients	redis-benchmark.c	/^static void createMissingClients(client c);$/;"	p	language:C	file:	signature:(client c)
createModuleObject	object.c	/^robj *createModuleObject(moduleType *mt, void *value) {$/;"	f	language:C	signature:(moduleType *mt, void *value)
createModuleObject	server.h	/^robj *createModuleObject(moduleType *mt, void *value);$/;"	p	language:C	signature:(moduleType *mt, void *value)
createObject	object.c	/^robj *createObject(int type, void *ptr) {$/;"	f	language:C	signature:(int type, void *ptr)
createObject	server.h	/^robj *createObject(int type, void *ptr);$/;"	p	language:C	signature:(int type, void *ptr)
createPidFile	server.c	/^void createPidFile(void) {$/;"	f	language:C	signature:(void)
createQuicklistObject	object.c	/^robj *createQuicklistObject(void) {$/;"	f	language:C	signature:(void)
createQuicklistObject	server.h	/^robj *createQuicklistObject(void);$/;"	p	language:C	signature:(void)
createRawStringObject	object.c	/^robj *createRawStringObject(const char *ptr, size_t len) {$/;"	f	language:C	signature:(const char *ptr, size_t len)
createRawStringObject	server.h	/^robj *createRawStringObject(const char *ptr, size_t len);$/;"	p	language:C	signature:(const char *ptr, size_t len)
createReplicationBacklog	replication.c	/^void createReplicationBacklog(void) {$/;"	f	language:C	signature:(void)
createSentinelAddr	sentinel.c	/^sentinelAddr *createSentinelAddr(char *hostname, int port) {$/;"	f	language:C	signature:(char *hostname, int port)
createSentinelRedisInstance	sentinel.c	/^sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {$/;"	f	language:C	signature:(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master)
createSet	intset.c	/^static intset *createSet(int bits, int size) {$/;"	f	language:C	file:	signature:(int bits, int size)
createSetObject	object.c	/^robj *createSetObject(void) {$/;"	f	language:C	signature:(void)
createSetObject	server.h	/^robj *createSetObject(void);$/;"	p	language:C	signature:(void)
createSharedObjects	redis-check-rdb.c	/^void createSharedObjects(void);$/;"	p	language:C	file:	signature:(void)
createSharedObjects	server.c	/^void createSharedObjects(void) {$/;"	f	language:C	signature:(void)
createSortOperation	sort.c	/^redisSortOperation *createSortOperation(int type, robj *pattern) {$/;"	f	language:C	signature:(int type, robj *pattern)
createSparklineSequence	sparkline.c	/^struct sequence *createSparklineSequence(void) {$/;"	f	language:C	signature:(void)
createSparklineSequence	sparkline.h	/^struct sequence *createSparklineSequence(void);$/;"	p	language:C	signature:(void)
createStringObject	object.c	/^robj *createStringObject(const char *ptr, size_t len) {$/;"	f	language:C	signature:(const char *ptr, size_t len)
createStringObject	server.h	/^robj *createStringObject(const char *ptr, size_t len);$/;"	p	language:C	signature:(const char *ptr, size_t len)
createStringObjectFromLongDouble	object.c	/^robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {$/;"	f	language:C	signature:(long double value, int humanfriendly)
createStringObjectFromLongDouble	server.h	/^robj *createStringObjectFromLongDouble(long double value, int humanfriendly);$/;"	p	language:C	signature:(long double value, int humanfriendly)
createStringObjectFromLongLong	object.c	/^robj *createStringObjectFromLongLong(long long value) {$/;"	f	language:C	signature:(long long value)
createStringObjectFromLongLong	server.h	/^robj *createStringObjectFromLongLong(long long value);$/;"	p	language:C	signature:(long long value)
createZiplistObject	object.c	/^robj *createZiplistObject(void) {$/;"	f	language:C	signature:(void)
createZiplistObject	server.h	/^robj *createZiplistObject(void);$/;"	p	language:C	signature:(void)
createZsetObject	object.c	/^robj *createZsetObject(void) {$/;"	f	language:C	signature:(void)
createZsetObject	server.h	/^robj *createZsetObject(void);$/;"	p	language:C	signature:(void)
createZsetZiplistObject	object.c	/^robj *createZsetZiplistObject(void) {$/;"	f	language:C	signature:(void)
createZsetZiplistObject	server.h	/^robj *createZsetZiplistObject(void);$/;"	p	language:C	signature:(void)
creative	modules/TYPES.md	/^ecosystem, so be creative, use both lower-case and upper case if it makes$/;"	v	language:C
crlf	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
cronloops	server.h	/^    int cronloops;              \/* Number of times the cron function run *\/$/;"	m	language:C	struct:redisServer	access:public
cs	cluster.c	/^        migrateCachedSocket *cs = dictGetVal(de);$/;"	l	language:C
cs	cluster.c	/^    migrateCachedSocket *cs;$/;"	l	language:C
cset	module.c	/^    const char *cset = ModuleTypeNameCharSet;$/;"	l	language:C
cset	scripting.c	/^    char *cset = "0123456789abcdef";$/;"	l	language:C
cstr	module.c	/^            char *cstr = va_arg(ap,char*);$/;"	l	language:C
csv	redis-benchmark.c	/^    int csv;$/;"	m	language:C	struct:config	file:	access:public
ctime	cluster.h	/^    mstime_t ctime;             \/* Link creation time *\/$/;"	m	language:C	struct:clusterLink	access:public
ctime	cluster.h	/^    mstime_t ctime; \/* Node object creation time. *\/$/;"	m	language:C	struct:clusterNode	access:public
ctime	server.h	/^    time_t ctime;           \/* Client creation time. *\/$/;"	m	language:C	struct:client	access:public
ctimebuf	sentinel.c	/^            char ctimebuf[26];$/;"	l	language:C
ctrl	lzf_d.c	/^      unsigned int ctrl = *ip++;$/;"	l	language:C
ctx	debug.c	/^    SHA1_CTX ctx;$/;"	l	language:C
ctx	module.c	/^    RedisModuleCtx *ctx;$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
ctx	module.c	/^    RedisModuleCtx *ctx;$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
ctx	module.c	/^    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;$/;"	l	language:C
ctx	scripting.c	/^            int around = ldb.currentline, ctx = 5;$/;"	l	language:C
ctx	scripting.c	/^    SHA1_CTX ctx;$/;"	l	language:C
ctx	sha1.c	/^    SHA1_CTX ctx;$/;"	l	language:C
ctx	util.c	/^            SHA1_CTX ctx;$/;"	l	language:C
cur	intset.c	/^    int64_t cur = -1;$/;"	l	language:C
cur	modules/hellotype.c	/^    struct HelloTypeNode *cur, *next;$/;"	l	language:C
cur	redis-cli.c	/^    unsigned long long cur = 0;$/;"	l	language:C
cur	ziplist.c	/^    zlentry cur, next;$/;"	l	language:C
cur_ms	ae.c	/^    long cur_sec, cur_ms, when_sec, when_ms;$/;"	l	language:C
cur_sec	ae.c	/^    long cur_sec, cur_ms, when_sec, when_ms;$/;"	l	language:C
curenc	intset.c	/^    uint8_t curenc = intrev32ifbe(is->encoding);$/;"	l	language:C
curlat	redis-benchmark.c	/^    int i, curlat = 0;$/;"	l	language:C
curlen	module.c	/^        size_t curlen = sdslen(key->value->ptr);$/;"	l	language:C
curlen	sds.c	/^    size_t curlen = sdslen(s);$/;"	l	language:C
curlen	ziplist.c	/^    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;$/;"	l	language:C
curlen	ziplist.c	/^    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;$/;"	l	language:C
curmaster	cluster.c	/^    clusterNode *curmaster, *newmaster = NULL;$/;"	l	language:C
curr_ip	cluster.c	/^        char *curr_ip = server.cluster_announce_ip;$/;"	l	language:C
current	adlist.c	/^    listNode *current = iter->next;$/;"	l	language:C
current	adlist.c	/^    listNode *current, *next;$/;"	l	language:C
current	quicklist.c	/^    quicklistNode *current, *next;$/;"	l	language:C
current	quicklist.h	/^    quicklistNode *current;$/;"	m	language:C	struct:quicklistIter	access:public
current	scripting.c	/^    int current = ldb.currentline == lnum;$/;"	l	language:C
current	sds.c	/^    char *current = NULL;$/;"	l	language:C
currentEpoch	cluster.h	/^    uint64_t currentEpoch;  \/* The epoch accordingly to the sending node. *\/$/;"	m	language:C	struct:__anon10	access:public
currentEpoch	cluster.h	/^    uint64_t currentEpoch;$/;"	m	language:C	struct:clusterState	access:public
current_client	server.h	/^    client *current_client; \/* Current client, only used on crash report *\/$/;"	m	language:C	struct:redisServer	access:public
current_db	expire.c	/^    static unsigned int current_db = 0; \/* Last DB tested. *\/$/;"	l	language:C	file:
current_epoch	sentinel.c	/^        unsigned long long current_epoch = strtoull(argv[1],NULL,10);$/;"	l	language:C
current_epoch	sentinel.c	/^    uint64_t current_epoch, master_config_epoch;$/;"	l	language:C
current_epoch	sentinel.c	/^    uint64_t current_epoch;         \/* Current epoch. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
currentline	scripting.c	/^    int currentline;    \/* Current line number. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
curscore	t_zset.c	/^    double curscore;$/;"	l	language:C
cursor	db.c	/^    unsigned long cursor;$/;"	l	language:C
cursor	t_hash.c	/^    unsigned long cursor;$/;"	l	language:C
cursor	t_set.c	/^    unsigned long cursor;$/;"	l	language:C
cursor	t_zset.c	/^    unsigned long cursor;$/;"	l	language:C
curval	hyperloglog.c	/^        int curval = HLL_SPARSE_VAL_VALUE(p);$/;"	l	language:C
cwd	aof.c	/^    char cwd[MAXPATHLEN]; \/* Current working dir path for error messages. *\/$/;"	l	language:C
cwd	config.c	/^    char cwd[1024];$/;"	l	language:C
cwd	rdb.c	/^    char cwd[MAXPATHLEN]; \/* Current working dir path for error messages. *\/$/;"	l	language:C
cwd	util.c	/^    char cwd[1024];$/;"	l	language:C
cwdp	aof.c	/^        char *cwdp = getcwd(cwd,MAXPATHLEN);$/;"	l	language:C
cwdp	rdb.c	/^        char *cwdp = getcwd(cwd,MAXPATHLEN);$/;"	l	language:C
czero	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
d	aof.c	/^        dict *d = db->dict;$/;"	l	language:C
d	debug.c	/^        sds d = sdsempty();$/;"	l	language:C
d	dict.c	/^    dict *d = zmalloc(sizeof(*d));$/;"	l	language:C
d	dict.h	/^        double d;$/;"	m	language:C	union:dictEntry::__anon12	access:public
d	dict.h	/^    dict *d;$/;"	m	language:C	struct:dictIterator	access:public
d	object.c	/^    dict *d = dictCreate(&setDictType,NULL);$/;"	l	language:C
d	object.c	/^    robj *d;$/;"	l	language:C
d	pqsort.c	/^	size_t d, r;$/;"	l	language:C
d	rdb.c	/^        dict *d = db->dict;$/;"	l	language:C
d	redis-cli.c	/^    double d;$/;"	l	language:C
d	sentinel.c	/^    dict *d[] = {master->slaves, master->sentinels, NULL};$/;"	l	language:C
d	server.c	/^    double d;$/;"	l	language:C
d	sha1.c	/^    uint32_t a, b, c, d, e;$/;"	l	language:C
d	t_set.c	/^        dict *d = dictCreate(&setDictType,NULL);$/;"	l	language:C
d	t_set.c	/^    dict *d;$/;"	l	language:C
d2string	util.c	/^int d2string(char *buf, size_t len, double value) {$/;"	f	language:C	signature:(char *buf, size_t len, double value)
d2string	util.h	/^int d2string(char *buf, size_t len, double value);$/;"	p	language:C	signature:(char *buf, size_t len, double value)
da	modules/TYPES.md	/^        struct dobule_array *da = ptr;$/;"	l	language:C
da	modules/TYPES.md	/^        struct double_array *da;$/;"	l	language:C
daemonize	server.c	/^void daemonize(void) {$/;"	f	language:C	signature:(void)
daemonize	server.h	/^    int daemonize;                  \/* True if running as a daemon *\/$/;"	m	language:C	struct:redisServer	access:public
data	cluster.h	/^    union clusterMsgData data;$/;"	m	language:C	struct:__anon10	typeref:union:__anon10::clusterMsgData	access:public
data	dict.c	/^    const unsigned char *data = (const unsigned char *)key;$/;"	l	language:C
data	hyperloglog.c	/^    const uint8_t *data = (const uint8_t *)key;$/;"	l	language:C
data	modules/TYPES.md	/^    struct some_private_struct *data = createMyDataStructure();$/;"	v	language:C	typeref:struct:some_private_struct
data	modules/TYPES.md	/^    struct some_private_struct *data;$/;"	v	language:C	typeref:struct:some_private_struct
data	modules/TYPES.md	/^of modules data, it is set to a special value of `module data`, but of$/;"	v	language:C
data	quicklist.c	/^                unsigned char *data;$/;"	l	language:C
data	quicklist.c	/^            unsigned char *data;$/;"	l	language:C
data	rdb.c	/^                    void *data;$/;"	l	language:C
data	redis-benchmark.c	/^    char *data, *cmd;$/;"	l	language:C
data_age	cluster.c	/^    mstime_t data_age;$/;"	l	language:C
databasesCron	server.c	/^void databasesCron(void) {$/;"	f	language:C	signature:(void)
datasize	redis-benchmark.c	/^    int datasize;$/;"	m	language:C	struct:config	file:	access:public
db	aof.c	/^        redisDb *db = server.db+j;$/;"	l	language:C
db	debug.c	/^        redisDb *db = server.db+j;$/;"	l	language:C
db	evict.c	/^        redisDb *db;$/;"	l	language:C
db	expire.c	/^        redisDb *db = server.db+(current_db % server.dbnum);$/;"	l	language:C
db	module.c	/^    redisDb *db;$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
db	multi.c	/^    redisDb *db;$/;"	m	language:C	struct:watchedKey	file:	access:public
db	rdb.c	/^        redisDb *db = server.db+j;$/;"	l	language:C
db	rdb.c	/^    redisDb *db = server.db+0;$/;"	l	language:C
db	server.h	/^    redisDb *db;            \/* Pointer to currently SELECTed DB. *\/$/;"	m	language:C	struct:client	access:public
db	server.h	/^    redisDb *db;$/;"	m	language:C	struct:readyList	access:public
db	server.h	/^    redisDb *db;$/;"	m	language:C	struct:redisServer	access:public
dbAdd	db.c	/^void dbAdd(redisDb *db, robj *key, robj *val) {$/;"	f	language:C	signature:(redisDb *db, robj *key, robj *val)
dbAdd	server.h	/^void dbAdd(redisDb *db, robj *key, robj *val);$/;"	p	language:C	signature:(redisDb *db, robj *key, robj *val)
dbAsyncDelete	lazyfree.c	/^int dbAsyncDelete(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
dbAsyncDelete	server.h	/^int dbAsyncDelete(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
dbDelete	db.c	/^int dbDelete(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
dbDelete	server.h	/^int dbDelete(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
dbDictType	server.c	/^dictType dbDictType = {$/;"	v	language:C
dbDictType	server.h	/^extern dictType dbDictType;$/;"	x	language:C
dbExists	db.c	/^int dbExists(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
dbExists	server.h	/^int dbExists(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
dbOverwrite	db.c	/^void dbOverwrite(redisDb *db, robj *key, robj *val) {$/;"	f	language:C	signature:(redisDb *db, robj *key, robj *val)
dbOverwrite	server.h	/^void dbOverwrite(redisDb *db, robj *key, robj *val);$/;"	p	language:C	signature:(redisDb *db, robj *key, robj *val)
dbRandomKey	db.c	/^robj *dbRandomKey(redisDb *db) {$/;"	f	language:C	signature:(redisDb *db)
dbRandomKey	server.h	/^robj *dbRandomKey(redisDb *db);$/;"	p	language:C	signature:(redisDb *db)
dbSyncDelete	db.c	/^int dbSyncDelete(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
dbSyncDelete	server.h	/^int dbSyncDelete(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
dbUnshareStringValue	db.c	/^robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {$/;"	f	language:C	signature:(redisDb *db, robj *key, robj *o)
dbUnshareStringValue	server.h	/^robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);$/;"	p	language:C	signature:(redisDb *db, robj *key, robj *o)
db_size	rdb.c	/^            uint64_t db_size, expires_size;$/;"	l	language:C
db_size	redis-check-rdb.c	/^            uint64_t db_size, expires_size;$/;"	l	language:C
dbg	scripting.c	/^    lua_Debug dbg;$/;"	l	language:C
dbid	cluster.c	/^    long dbid;$/;"	l	language:C
dbid	db.c	/^    long long dbid, expire;$/;"	l	language:C
dbid	debug.c	/^        long dbid;$/;"	l	language:C
dbid	evict.c	/^    int dbid;                   \/* Key DB number. *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
dbid	rdb.c	/^    uint64_t dbid;$/;"	l	language:C
dbid	redis-check-rdb.c	/^    uint64_t dbid;$/;"	l	language:C
dbid	server.h	/^    int argc, dbid, target;$/;"	m	language:C	struct:redisOp	access:public
dbnum	redis-benchmark.c	/^    int dbnum;$/;"	m	language:C	struct:config	file:	access:public
dbnum	redis-cli.c	/^    int dbnum;$/;"	m	language:C	struct:config	file:	access:public
dbnum	server.h	/^    int dbnum;                      \/* Total number of configured DBs *\/$/;"	m	language:C	struct:redisServer	access:public
dbnumstr	redis-benchmark.c	/^    sds dbnumstr;$/;"	m	language:C	struct:config	file:	access:public
dbs_per_call	expire.c	/^    int dbs_per_call = CRON_DBS_PER_CALL;$/;"	l	language:C
dbs_per_call	server.c	/^        int dbs_per_call = CRON_DBS_PER_CALL;$/;"	l	language:C
dbsizeCommand	db.c	/^void dbsizeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
dbsizeCommand	server.h	/^void dbsizeCommand(client *c);$/;"	p	language:C	signature:(client *c)
dbuf	geo.c	/^    char dbuf[128];$/;"	l	language:C
dbuf	networking.c	/^    char dbuf[128], sbuf[128];$/;"	l	language:C
dbuf	rio.c	/^    char dbuf[128];$/;"	l	language:C
dbuf	scripting.c	/^        char dbuf[64];$/;"	l	language:C
de	aof.c	/^        dictEntry *de;$/;"	l	language:C
de	aof.c	/^    dictEntry *de;$/;"	l	language:C
de	cluster.c	/^        dictEntry *de = dictGetRandomKey(server.cluster->nodes);$/;"	l	language:C
de	cluster.c	/^        dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);$/;"	l	language:C
de	cluster.c	/^        dictEntry *de;$/;"	l	language:C
de	cluster.c	/^    dictEntry *de;$/;"	l	language:C
de	config.c	/^    dictEntry *de;$/;"	l	language:C
de	db.c	/^    dictEntry *de = dictFind(db->dict,key->ptr);$/;"	l	language:C
de	db.c	/^    dictEntry *de;$/;"	l	language:C
de	db.c	/^    dictEntry *kde, *de;$/;"	l	language:C
de	debug.c	/^                    dictEntry *de;$/;"	l	language:C
de	debug.c	/^        dictEntry *de;$/;"	l	language:C
de	debug.c	/^    dictEntry *de;$/;"	l	language:C
de	dict.c	/^        dictEntry *de, *nextde;$/;"	l	language:C
de	dict.c	/^    const dictEntry *de, *next;$/;"	l	language:C
de	evict.c	/^        dictEntry *de;$/;"	l	language:C
de	expire.c	/^                dictEntry *de;$/;"	l	language:C
de	expire.c	/^    dictEntry *de;$/;"	l	language:C
de	latency.c	/^        dictEntry *de;$/;"	l	language:C
de	latency.c	/^    dictEntry *de;$/;"	l	language:C
de	lazyfree.c	/^    dictEntry *de = dictFind(db->dict,key->ptr);$/;"	l	language:C
de	module.c	/^        dictEntry *de;$/;"	l	language:C
de	module.c	/^    dictEntry *de;$/;"	l	language:C
de	object.c	/^    dictEntry *de;$/;"	l	language:C
de	pubsub.c	/^        dictEntry *de;$/;"	l	language:C
de	pubsub.c	/^    dictEntry *de;$/;"	l	language:C
de	rdb.c	/^            dictEntry *de;$/;"	l	language:C
de	rdb.c	/^    dictEntry *de;$/;"	l	language:C
de	sentinel.c	/^        dictEntry *de;$/;"	l	language:C
de	sentinel.c	/^    dictEntry *de = dictFind(counters,runid);$/;"	l	language:C
de	sentinel.c	/^    dictEntry *de;$/;"	l	language:C
de	server.c	/^    dictEntry *de;$/;"	l	language:C
de	server.h	/^    dictEntry *de;$/;"	m	language:C	struct:__anon34	access:public
de	t_hash.c	/^        dictEntry *de = dictFind(o->ptr,field);$/;"	l	language:C
de	t_hash.c	/^    dictEntry *de;$/;"	l	language:C
de	t_list.c	/^                dictEntry *de;$/;"	l	language:C
de	t_list.c	/^    dictEntry *de;$/;"	l	language:C
de	t_set.c	/^            dictEntry *de;$/;"	l	language:C
de	t_set.c	/^        dictEntry *de = dictAddRaw(ht,value);$/;"	l	language:C
de	t_set.c	/^        dictEntry *de = dictGetRandomKey(setobj->ptr);$/;"	l	language:C
de	t_set.c	/^        dictEntry *de = dictNext(si->di);$/;"	l	language:C
de	t_set.c	/^        dictEntry *de;$/;"	l	language:C
de	t_zset.c	/^                dictEntry *de;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
de	t_zset.c	/^            dictEntry *de;$/;"	l	language:C
de	t_zset.c	/^        dictEntry *de = dictFind(zs->dict, member);$/;"	l	language:C
de	t_zset.c	/^        dictEntry *de;$/;"	l	language:C
debug	ziplist.c	/^#define debug(/;"	d	language:C	file:
debugCommand	debug.c	/^void debugCommand(client *c) {$/;"	f	language:C	signature:(client *c)
debugCommand	server.h	/^void debugCommand(client *c);$/;"	p	language:C	signature:(client *c)
dec	object.c	/^    robj *dec;$/;"	l	language:C
dec	rdb.c	/^    robj *o = NULL, *ele, *dec;$/;"	l	language:C
decodeGeohash	geo.c	/^int decodeGeohash(double bits, double *xy) {$/;"	f	language:C	signature:(double bits, double *xy)
decoded	db.c	/^        robj *decoded = getDecodedObject(o);$/;"	l	language:C
decoded	debug.c	/^        robj *decoded;$/;"	l	language:C
decoded	hyperloglog.c	/^        sds decoded = sdsempty();$/;"	l	language:C
decoded	module.c	/^                    robj *decoded = getDecodedObject(*valueptr);$/;"	l	language:C
decoded	module.c	/^    robj *decoded = getDecodedObject(ele);$/;"	l	language:C
decompressed	quicklist.c	/^    void *decompressed = zmalloc(node->sz);$/;"	l	language:C
decrCommand	server.h	/^void decrCommand(client *c);$/;"	p	language:C	signature:(client *c)
decrCommand	t_string.c	/^void decrCommand(client *c) {$/;"	f	language:C	signature:(client *c)
decrRefCount	object.c	/^void decrRefCount(robj *o) {$/;"	f	language:C	signature:(robj *o)
decrRefCount	server.h	/^void decrRefCount(robj *o);$/;"	p	language:C	signature:(robj *o)
decrRefCountVoid	object.c	/^void decrRefCountVoid(void *o) {$/;"	f	language:C	signature:(void *o)
decrRefCountVoid	server.h	/^void decrRefCountVoid(void *o);$/;"	p	language:C	signature:(void *o)
decr_step	server.c	/^                rlim_t decr_step = 16;$/;"	l	language:C
decrbyCommand	server.h	/^void decrbyCommand(client *c);$/;"	p	language:C	signature:(client *c)
decrbyCommand	t_string.c	/^void decrbyCommand(client *c) {$/;"	f	language:C	signature:(client *c)
decrease_step	geohash_helper.c	/^    int decrease_step = 0;$/;"	l	language:C
defsections	sentinel.c	/^    int defsections = 0, allsections = 0;$/;"	l	language:C
defsections	server.c	/^    int allsections = 0, defsections = 0;$/;"	l	language:C
deg_rad	geohash_helper.c	/^static inline double deg_rad(double ang) { return ang * D_R; }$/;"	f	language:C	file:	signature:(double ang)
deinterleave64	geohash.c	/^static inline uint64_t deinterleave64(uint64_t interleaved) {$/;"	f	language:C	file:	signature:(uint64_t interleaved)
del	cluster.c	/^        int del = !strcasecmp(c->argv[1]->ptr,"delslots");$/;"	l	language:C
del	quicklist.c	/^                int del = 2;$/;"	l	language:C
del	quicklist.c	/^        unsigned long del;$/;"	l	language:C
del	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
delCommand	db.c	/^void delCommand(client *c) {$/;"	f	language:C	signature:(client *c)
delCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::redisCommand	access:public
delCommand	server.h	/^void delCommand(client *c);$/;"	p	language:C	signature:(client *c)
delGenericCommand	db.c	/^void delGenericCommand(client *c, int lazy) {$/;"	f	language:C	signature:(client *c, int lazy)
delKeysInSlot	db.c	/^unsigned int delKeysInSlot(unsigned int hashslot) {$/;"	f	language:C	signature:(unsigned int hashslot)
delKeysInSlot	server.h	/^unsigned int delKeysInSlot(unsigned int hashslot);$/;"	p	language:C	signature:(unsigned int hashslot)
del_idx	cluster.c	/^    int del_idx = 1; \/* Index of the key argument for the replicated DEL op. *\/$/;"	l	language:C
delay	cluster.c	/^        mstime_t delay;$/;"	l	language:C
delay	debug.c	/^        long long delay = 0;$/;"	l	language:C
delay	sentinel.c	/^            mstime_t delay = sj->start_time ? (sj->start_time-mstime()) : 0;$/;"	l	language:C
delay	sentinel.c	/^    mstime_t delay = SENTINEL_SCRIPT_RETRY_DELAY;$/;"	l	language:C
delete_entire_node	quicklist.c	/^        int delete_entire_node = 0;$/;"	l	language:C
deleted	cluster.c	/^    int deleted = 0, j;$/;"	l	language:C
deleted	db.c	/^        int deleted  = lazy ? dbAsyncDelete(c->db,c->argv[j]) :$/;"	l	language:C
deleted	expire.c	/^        int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c->db,key) :$/;"	l	language:C
deleted	t_hash.c	/^    int deleted = 0;$/;"	l	language:C
deleted	t_hash.c	/^    int j, deleted = 0, keyremoved = 0;$/;"	l	language:C
deleted	t_set.c	/^        int deleted = dbDelete(c->db,dstkey);$/;"	l	language:C
deleted	t_set.c	/^    int j, deleted = 0, keyremoved = 0;$/;"	l	language:C
deleted	t_zset.c	/^    int deleted = 0, keyremoved = 0, j;$/;"	l	language:C
deleted	t_zset.c	/^    unsigned long deleted = 0;$/;"	l	language:C
deleted	ziplist.c	/^    unsigned int i, totlen, deleted = 0;$/;"	l	language:C
deleted_node	quicklist.c	/^    int deleted_node = quicklistDelIndex((quicklist *)entry->quicklist,$/;"	l	language:C
delhook	scripting.c	/^    int delhook = 0, err;$/;"	l	language:C
delta	evict.c	/^    long long delta;$/;"	l	language:C
delta	latency.c	/^        int64_t delta;$/;"	l	language:C
delta	sentinel.c	/^    mstime_t delta = now - sentinel.previous_time;$/;"	l	language:C
deltalen	hyperloglog.c	/^     int deltalen = seqlen-oldlen;$/;"	l	language:C
dense	hyperloglog.c	/^    sds sparse = o->ptr, dense;$/;"	l	language:C
dense_retval	hyperloglog.c	/^    int dense_retval = hllDenseAdd(hdr->registers, ele, elesize);$/;"	l	language:C
depth	quicklist.c	/^    int depth = 0;$/;"	l	language:C
depth	t_list.c	/^        int depth = server.list_compress_depth;$/;"	l	language:C
desc	sort.c	/^    int desc = 0, alpha = 0;$/;"	l	language:C
designed	modules/INTRO.md	/^so a given module does not need to be designed, or recompiled, in order to$/;"	v	language:C
dfd	replication.c	/^    int dfd, maxtries = 5;$/;"	l	language:C
di	aof.c	/^        dictIterator *di = dictGetIterator(o->ptr);$/;"	l	language:C
di	aof.c	/^        dictIterator *di = dictGetIterator(zs->dict);$/;"	l	language:C
di	aof.c	/^    dictIterator *di = NULL;$/;"	l	language:C
di	cluster.c	/^        dictIterator *di;$/;"	l	language:C
di	cluster.c	/^    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);$/;"	l	language:C
di	cluster.c	/^    dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);$/;"	l	language:C
di	cluster.c	/^    dictIterator *di;$/;"	l	language:C
di	config.c	/^    dictIterator *di = dictGetIterator(state->option_to_line);$/;"	l	language:C
di	db.c	/^    dictIterator *di;$/;"	l	language:C
di	debug.c	/^                    dictIterator *di = dictGetIterator(zs->dict);$/;"	l	language:C
di	debug.c	/^    dictIterator *di = NULL;$/;"	l	language:C
di	latency.c	/^    dictIterator *di;$/;"	l	language:C
di	module.c	/^        dictIterator *di = dictGetIterator(modules);$/;"	l	language:C
di	module.c	/^    dictIterator *di = dictGetIterator(modules);$/;"	l	language:C
di	module.c	/^    dictIterator *di = dictGetSafeIterator(server.commands);$/;"	l	language:C
di	pubsub.c	/^        dictIterator *di = dictGetIterator(server.pubsub_channels);$/;"	l	language:C
di	pubsub.c	/^    dictIterator *di = dictGetSafeIterator(c->pubsub_channels);$/;"	l	language:C
di	rdb.c	/^            dictIterator *di = dictGetIterator(o->ptr);$/;"	l	language:C
di	rdb.c	/^            dictIterator *di = dictGetIterator(set);$/;"	l	language:C
di	rdb.c	/^            dictIterator *di = dictGetIterator(zs->dict);$/;"	l	language:C
di	rdb.c	/^    dictIterator *di = NULL;$/;"	l	language:C
di	sentinel.c	/^        dictIterator  *di;$/;"	l	language:C
di	sentinel.c	/^        dictIterator *di;$/;"	l	language:C
di	sentinel.c	/^    dictIterator *di, *di2;$/;"	l	language:C
di	sentinel.c	/^    dictIterator *di;$/;"	l	language:C
di	server.c	/^    dictIterator *di;$/;"	l	language:C
di	server.h	/^    dictIterator *di;$/;"	m	language:C	struct:__anon33	access:public
di	server.h	/^    dictIterator *di;$/;"	m	language:C	struct:__anon34	access:public
di	sort.c	/^        dictIterator *di;$/;"	l	language:C
di	t_list.c	/^    dictIterator *di;$/;"	l	language:C
di	t_set.c	/^        dictIterator *di;$/;"	l	language:C
di	t_zset.c	/^                dictIterator *di;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
di	t_zset.c	/^        dictIterator *di;$/;"	l	language:C
di2	sentinel.c	/^    dictIterator *di, *di2;$/;"	l	language:C
dict	dict.h	/^typedef struct dict {$/;"	s	language:C
dict	dict.h	/^} dict;$/;"	t	language:C	typeref:struct:dict
dict	evict.c	/^        dict *dict;$/;"	l	language:C
dict	server.h	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	language:C	struct:redisDb	access:public
dict	server.h	/^    dict *dict;$/;"	m	language:C	struct:zset	access:public
dict	t_hash.c	/^        dict *dict;$/;"	l	language:C
dict	t_zset.c	/^                dict *dict;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
dict::ht	dict.h	/^    dictht ht[2];$/;"	m	language:C	struct:dict	access:public
dict::iterators	dict.h	/^    unsigned long iterators; \/* number of iterators currently running *\/$/;"	m	language:C	struct:dict	access:public
dict::privdata	dict.h	/^    void *privdata;$/;"	m	language:C	struct:dict	access:public
dict::rehashidx	dict.h	/^    long rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	language:C	struct:dict	access:public
dict::type	dict.h	/^    dictType *type;$/;"	m	language:C	struct:dict	access:public
dictAdd	dict.c	/^int dictAdd(dict *d, void *key, void *val)$/;"	f	language:C	signature:(dict *d, void *key, void *val)
dictAdd	dict.h	/^int dictAdd(dict *d, void *key, void *val);$/;"	p	language:C	signature:(dict *d, void *key, void *val)
dictAddRaw	dict.c	/^dictEntry *dictAddRaw(dict *d, void *key)$/;"	f	language:C	signature:(dict *d, void *key)
dictAddRaw	dict.h	/^dictEntry *dictAddRaw(dict *d, void *key);$/;"	p	language:C	signature:(dict *d, void *key)
dictCStringKeyCompare	module.c	/^int dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {$/;"	f	language:C	signature:(void *privdata, const void *key1, const void *key2)
dictCStringKeyHash	module.c	/^unsigned int dictCStringKeyHash(const void *key) {$/;"	f	language:C	signature:(const void *key)
dictCompareKeys	dict.h	/^#define dictCompareKeys(/;"	d	language:C
dictCreate	dict.c	/^dict *dictCreate(dictType *type,$/;"	f	language:C	signature:(dictType *type, void *privDataPtr)
dictCreate	dict.h	/^dict *dictCreate(dictType *type, void *privDataPtr);$/;"	p	language:C	signature:(dictType *type, void *privDataPtr)
dictDelete	dict.c	/^int dictDelete(dict *ht, const void *key) {$/;"	f	language:C	signature:(dict *ht, const void *key)
dictDelete	dict.h	/^int dictDelete(dict *d, const void *key);$/;"	p	language:C	signature:(dict *d, const void *key)
dictDeleteNoFree	dict.c	/^int dictDeleteNoFree(dict *ht, const void *key) {$/;"	f	language:C	signature:(dict *ht, const void *key)
dictDeleteNoFree	dict.h	/^int dictDeleteNoFree(dict *d, const void *key);$/;"	p	language:C	signature:(dict *d, const void *key)
dictDisableResize	dict.c	/^void dictDisableResize(void) {$/;"	f	language:C	signature:(void)
dictDisableResize	dict.h	/^void dictDisableResize(void);$/;"	p	language:C	signature:(void)
dictEmpty	dict.c	/^void dictEmpty(dict *d, void(callback)(void*)) {$/;"	f	language:C	signature:(dict *d, void(callback)(void*))
dictEmpty	dict.h	/^void dictEmpty(dict *d, void(callback)(void*));$/;"	p	language:C	signature:(dict *d, void(callback)(void*))
dictEnableResize	dict.c	/^void dictEnableResize(void) {$/;"	f	language:C	signature:(void)
dictEnableResize	dict.h	/^void dictEnableResize(void);$/;"	p	language:C	signature:(void)
dictEncObjHash	server.c	/^unsigned int dictEncObjHash(const void *key) {$/;"	f	language:C	signature:(const void *key)
dictEncObjKeyCompare	server.c	/^int dictEncObjKeyCompare(void *privdata, const void *key1,$/;"	f	language:C	signature:(void *privdata, const void *key1, const void *key2)
dictEntry	dict.h	/^typedef struct dictEntry {$/;"	s	language:C
dictEntry	dict.h	/^} dictEntry;$/;"	t	language:C	typeref:struct:dictEntry
dictEntry::__anon12::d	dict.h	/^        double d;$/;"	m	language:C	union:dictEntry::__anon12	access:public
dictEntry::__anon12::s64	dict.h	/^        int64_t s64;$/;"	m	language:C	union:dictEntry::__anon12	access:public
dictEntry::__anon12::u64	dict.h	/^        uint64_t u64;$/;"	m	language:C	union:dictEntry::__anon12	access:public
dictEntry::__anon12::val	dict.h	/^        void *val;$/;"	m	language:C	union:dictEntry::__anon12	access:public
dictEntry::key	dict.h	/^    void *key;$/;"	m	language:C	struct:dictEntry	access:public
dictEntry::next	dict.h	/^    struct dictEntry *next;$/;"	m	language:C	struct:dictEntry	typeref:struct:dictEntry::dictEntry	access:public
dictEntry::v	dict.h	/^    } v;$/;"	m	language:C	struct:dictEntry	typeref:union:dictEntry::__anon12	access:public
dictExpand	dict.c	/^int dictExpand(dict *d, unsigned long size)$/;"	f	language:C	signature:(dict *d, unsigned long size)
dictExpand	dict.h	/^int dictExpand(dict *d, unsigned long size);$/;"	p	language:C	signature:(dict *d, unsigned long size)
dictFetchValue	dict.c	/^void *dictFetchValue(dict *d, const void *key) {$/;"	f	language:C	signature:(dict *d, const void *key)
dictFetchValue	dict.h	/^void *dictFetchValue(dict *d, const void *key);$/;"	p	language:C	signature:(dict *d, const void *key)
dictFind	dict.c	/^dictEntry *dictFind(dict *d, const void *key)$/;"	f	language:C	signature:(dict *d, const void *key)
dictFind	dict.h	/^dictEntry * dictFind(dict *d, const void *key);$/;"	p	language:C	signature:(dict *d, const void *key)
dictFingerprint	dict.c	/^long long dictFingerprint(dict *d) {$/;"	f	language:C	signature:(dict *d)
dictFreeKey	dict.h	/^#define dictFreeKey(/;"	d	language:C
dictFreeVal	dict.h	/^#define dictFreeVal(/;"	d	language:C
dictGenCaseHashFunction	dict.c	/^unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) {$/;"	f	language:C	signature:(const unsigned char *buf, int len)
dictGenCaseHashFunction	dict.h	/^unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len);$/;"	p	language:C	signature:(const unsigned char *buf, int len)
dictGenHashFunction	dict.c	/^unsigned int dictGenHashFunction(const void *key, int len) {$/;"	f	language:C	signature:(const void *key, int len)
dictGenHashFunction	dict.h	/^unsigned int dictGenHashFunction(const void *key, int len);$/;"	p	language:C	signature:(const void *key, int len)
dictGenericDelete	dict.c	/^static int dictGenericDelete(dict *d, const void *key, int nofree)$/;"	f	language:C	file:	signature:(dict *d, const void *key, int nofree)
dictGetDoubleVal	dict.h	/^#define dictGetDoubleVal(/;"	d	language:C
dictGetHashFunctionSeed	dict.c	/^uint32_t dictGetHashFunctionSeed(void) {$/;"	f	language:C	signature:(void)
dictGetHashFunctionSeed	dict.h	/^unsigned int dictGetHashFunctionSeed(void);$/;"	p	language:C	signature:(void)
dictGetIterator	dict.c	/^dictIterator *dictGetIterator(dict *d)$/;"	f	language:C	signature:(dict *d)
dictGetIterator	dict.h	/^dictIterator *dictGetIterator(dict *d);$/;"	p	language:C	signature:(dict *d)
dictGetKey	dict.h	/^#define dictGetKey(/;"	d	language:C
dictGetRandomKey	dict.c	/^dictEntry *dictGetRandomKey(dict *d)$/;"	f	language:C	signature:(dict *d)
dictGetRandomKey	dict.h	/^dictEntry *dictGetRandomKey(dict *d);$/;"	p	language:C	signature:(dict *d)
dictGetSafeIterator	dict.c	/^dictIterator *dictGetSafeIterator(dict *d) {$/;"	f	language:C	signature:(dict *d)
dictGetSafeIterator	dict.h	/^dictIterator *dictGetSafeIterator(dict *d);$/;"	p	language:C	signature:(dict *d)
dictGetSignedIntegerVal	dict.h	/^#define dictGetSignedIntegerVal(/;"	d	language:C
dictGetSomeKeys	dict.c	/^unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {$/;"	f	language:C	signature:(dict *d, dictEntry **des, unsigned int count)
dictGetSomeKeys	dict.h	/^unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);$/;"	p	language:C	signature:(dict *d, dictEntry **des, unsigned int count)
dictGetStats	dict.c	/^void dictGetStats(char *buf, size_t bufsize, dict *d) {$/;"	f	language:C	signature:(char *buf, size_t bufsize, dict *d)
dictGetStats	dict.h	/^void dictGetStats(char *buf, size_t bufsize, dict *d);$/;"	p	language:C	signature:(char *buf, size_t bufsize, dict *d)
dictGetUnsignedIntegerVal	dict.h	/^#define dictGetUnsignedIntegerVal(/;"	d	language:C
dictGetVal	dict.h	/^#define dictGetVal(/;"	d	language:C
dictGetVal	t_hash.c	/^            sdsfree(dictGetVal(de));$/;"	p	language:C	file:
dictHashKey	dict.h	/^#define dictHashKey(/;"	d	language:C
dictInstancesValDestructor	sentinel.c	/^void dictInstancesValDestructor (void *privdata, void *obj) {$/;"	f	language:C	signature:(void *privdata, void *obj)
dictIntHashFunction	dict.c	/^unsigned int dictIntHashFunction(unsigned int key)$/;"	f	language:C	signature:(unsigned int key)
dictIsRehashing	dict.h	/^#define dictIsRehashing(/;"	d	language:C
dictIterator	dict.h	/^typedef struct dictIterator {$/;"	s	language:C
dictIterator	dict.h	/^} dictIterator;$/;"	t	language:C	typeref:struct:dictIterator
dictIterator::d	dict.h	/^    dict *d;$/;"	m	language:C	struct:dictIterator	access:public
dictIterator::entry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	language:C	struct:dictIterator	access:public
dictIterator::fingerprint	dict.h	/^    long long fingerprint;$/;"	m	language:C	struct:dictIterator	access:public
dictIterator::index	dict.h	/^    long index;$/;"	m	language:C	struct:dictIterator	access:public
dictIterator::nextEntry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	language:C	struct:dictIterator	access:public
dictIterator::safe	dict.h	/^    int table, safe;$/;"	m	language:C	struct:dictIterator	access:public
dictIterator::table	dict.h	/^    int table, safe;$/;"	m	language:C	struct:dictIterator	access:public
dictListDestructor	config.c	/^void dictListDestructor(void *privdata, void *val);$/;"	p	language:C	file:	signature:(void *privdata, void *val)
dictListDestructor	server.c	/^void dictListDestructor(void *privdata, void *val)$/;"	f	language:C	signature:(void *privdata, void *val)
dictNext	dict.c	/^dictEntry *dictNext(dictIterator *iter)$/;"	f	language:C	signature:(dictIterator *iter)
dictNext	dict.h	/^dictEntry *dictNext(dictIterator *iter);$/;"	p	language:C	signature:(dictIterator *iter)
dictObjHash	server.c	/^unsigned int dictObjHash(const void *key) {$/;"	f	language:C	signature:(const void *key)
dictObjKeyCompare	server.c	/^int dictObjKeyCompare(void *privdata, const void *key1,$/;"	f	language:C	signature:(void *privdata, const void *key1, const void *key2)
dictObjectDestructor	server.c	/^void dictObjectDestructor(void *privdata, void *val)$/;"	f	language:C	signature:(void *privdata, void *val)
dictRehash	dict.c	/^int dictRehash(dict *d, int n) {$/;"	f	language:C	signature:(dict *d, int n)
dictRehash	dict.h	/^int dictRehash(dict *d, int n);$/;"	p	language:C	signature:(dict *d, int n)
dictRehashMilliseconds	dict.c	/^int dictRehashMilliseconds(dict *d, int ms) {$/;"	f	language:C	signature:(dict *d, int ms)
dictRehashMilliseconds	dict.h	/^int dictRehashMilliseconds(dict *d, int ms);$/;"	p	language:C	signature:(dict *d, int ms)
dictRelease	dict.c	/^void dictRelease(dict *d)$/;"	f	language:C	signature:(dict *d)
dictRelease	dict.h	/^void dictRelease(dict *d);$/;"	p	language:C	signature:(dict *d)
dictReleaseIterator	dict.c	/^void dictReleaseIterator(dictIterator *iter)$/;"	f	language:C	signature:(dictIterator *iter)
dictReleaseIterator	dict.h	/^void dictReleaseIterator(dictIterator *iter);$/;"	p	language:C	signature:(dictIterator *iter)
dictReplace	dict.c	/^int dictReplace(dict *d, void *key, void *val)$/;"	f	language:C	signature:(dict *d, void *key, void *val)
dictReplace	dict.h	/^int dictReplace(dict *d, void *key, void *val);$/;"	p	language:C	signature:(dict *d, void *key, void *val)
dictReplaceRaw	dict.c	/^dictEntry *dictReplaceRaw(dict *d, void *key) {$/;"	f	language:C	signature:(dict *d, void *key)
dictReplaceRaw	dict.h	/^dictEntry *dictReplaceRaw(dict *d, void *key);$/;"	p	language:C	signature:(dict *d, void *key)
dictResize	dict.c	/^int dictResize(dict *d)$/;"	f	language:C	signature:(dict *d)
dictResize	dict.h	/^int dictResize(dict *d);$/;"	p	language:C	signature:(dict *d)
dictScan	dict.c	/^unsigned long dictScan(dict *d,$/;"	f	language:C	signature:(dict *d, unsigned long v, dictScanFunction *fn, void *privdata)
dictScan	dict.h	/^unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);$/;"	p	language:C	signature:(dict *d, unsigned long v, dictScanFunction *fn, void *privdata)
dictScanFunction	dict.h	/^typedef void (dictScanFunction)(void *privdata, const dictEntry *de);$/;"	t	language:C
dictSdsCaseHash	config.c	/^unsigned int dictSdsCaseHash(const void *key);$/;"	p	language:C	file:	signature:(const void *key)
dictSdsCaseHash	server.c	/^unsigned int dictSdsCaseHash(const void *key) {$/;"	f	language:C	signature:(const void *key)
dictSdsDestructor	config.c	/^void dictSdsDestructor(void *privdata, void *val);$/;"	p	language:C	file:	signature:(void *privdata, void *val)
dictSdsDestructor	server.c	/^void dictSdsDestructor(void *privdata, void *val)$/;"	f	language:C	signature:(void *privdata, void *val)
dictSdsHash	sentinel.c	/^unsigned int dictSdsHash(const void *key);$/;"	p	language:C	file:	signature:(const void *key)
dictSdsHash	server.c	/^unsigned int dictSdsHash(const void *key) {$/;"	f	language:C	signature:(const void *key)
dictSdsHash	t_zset.c	/^unsigned int dictSdsHash(const void *key);$/;"	p	language:C	file:	signature:(const void *key)
dictSdsKeyCaseCompare	config.c	/^int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);$/;"	p	language:C	file:	signature:(void *privdata, const void *key1, const void *key2)
dictSdsKeyCaseCompare	server.c	/^int dictSdsKeyCaseCompare(void *privdata, const void *key1,$/;"	f	language:C	signature:(void *privdata, const void *key1, const void *key2)
dictSdsKeyCompare	sentinel.c	/^int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);$/;"	p	language:C	file:	signature:(void *privdata, const void *key1, const void *key2)
dictSdsKeyCompare	server.c	/^int dictSdsKeyCompare(void *privdata, const void *key1,$/;"	f	language:C	signature:(void *privdata, const void *key1, const void *key2)
dictSdsKeyCompare	t_zset.c	/^int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);$/;"	p	language:C	file:	signature:(void *privdata, const void *key1, const void *key2)
dictSetDoubleVal	dict.h	/^#define dictSetDoubleVal(/;"	d	language:C
dictSetHashFunctionSeed	dict.c	/^void dictSetHashFunctionSeed(uint32_t seed) {$/;"	f	language:C	signature:(uint32_t seed)
dictSetHashFunctionSeed	dict.h	/^void dictSetHashFunctionSeed(unsigned int initval);$/;"	p	language:C	signature:(unsigned int initval)
dictSetKey	dict.h	/^#define dictSetKey(/;"	d	language:C
dictSetSignedIntegerVal	dict.h	/^#define dictSetSignedIntegerVal(/;"	d	language:C
dictSetUnsignedIntegerVal	dict.h	/^#define dictSetUnsignedIntegerVal(/;"	d	language:C
dictSetVal	dict.h	/^#define dictSetVal(/;"	d	language:C
dictSize	dict.h	/^#define dictSize(/;"	d	language:C
dictSlots	dict.h	/^#define dictSlots(/;"	d	language:C
dictStringHash	latency.c	/^unsigned int dictStringHash(const void *key) {$/;"	f	language:C	signature:(const void *key)
dictStringKeyCompare	latency.c	/^int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {$/;"	f	language:C	signature:(void *privdata, const void *key1, const void *key2)
dictType	dict.h	/^typedef struct dictType {$/;"	s	language:C
dictType	dict.h	/^} dictType;$/;"	t	language:C	typeref:struct:dictType
dictType::hashFunction	dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	language:C	struct:dictType	access:public
dictType::keyCompare	dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	language:C	struct:dictType	access:public
dictType::keyDestructor	dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	language:C	struct:dictType	access:public
dictType::keyDup	dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	language:C	struct:dictType	access:public
dictType::valDestructor	dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	language:C	struct:dictType	access:public
dictType::valDup	dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	language:C	struct:dictType	access:public
dictTypeHeapStringCopyKey	dict.h	/^extern dictType dictTypeHeapStringCopyKey;$/;"	x	language:C
dictTypeHeapStringCopyKeyValue	dict.h	/^extern dictType dictTypeHeapStringCopyKeyValue;$/;"	x	language:C
dictTypeHeapStrings	dict.h	/^extern dictType dictTypeHeapStrings;$/;"	x	language:C
dictVanillaFree	latency.c	/^void dictVanillaFree(void *privdata, void *val);$/;"	p	language:C	file:	signature:(void *privdata, void *val)
dictVanillaFree	server.c	/^void dictVanillaFree(void *privdata, void *val)$/;"	f	language:C	signature:(void *privdata, void *val)
dict_can_resize	dict.c	/^static int dict_can_resize = 1;$/;"	v	language:C	file:
dict_force_resize_ratio	dict.c	/^static unsigned int dict_force_resize_ratio = 5;$/;"	v	language:C	file:
dict_hash_function_seed	dict.c	/^static uint32_t dict_hash_function_seed = 5381;$/;"	v	language:C	file:
dictht	dict.h	/^typedef struct dictht {$/;"	s	language:C
dictht	dict.h	/^} dictht;$/;"	t	language:C	typeref:struct:dictht
dictht::size	dict.h	/^    unsigned long size;$/;"	m	language:C	struct:dictht	access:public
dictht::sizemask	dict.h	/^    unsigned long sizemask;$/;"	m	language:C	struct:dictht	access:public
dictht::table	dict.h	/^    dictEntry **table;$/;"	m	language:C	struct:dictht	access:public
dictht::used	dict.h	/^    unsigned long used;$/;"	m	language:C	struct:dictht	access:public
dictid_len	replication.c	/^            int dictid_len;$/;"	l	language:C
dictid_len	server.c	/^        int dictid_len;$/;"	l	language:C
dictid_str	server.c	/^        char dictid_str[64];$/;"	l	language:C
diff	redis-check-aof.c	/^    off_t diff = size-pos;$/;"	l	language:C
diff	server.c	/^    int diff = 0;$/;"	l	language:C
diff_algo	t_set.c	/^    int diff_algo = 1;$/;"	l	language:C
difference_longitude	geohash_helper.c	/^    double difference_longitude = asin(sin(distance) \/ cos(latr));$/;"	l	language:C
digest	debug.c	/^        unsigned char digest[20];$/;"	l	language:C
digest	debug.c	/^    unsigned char digest[20];$/;"	l	language:C
digest	modules/TYPES.md	/^* A set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the `DEBUG DIGEST` command.$/;"	p	language:C	file:
digest	scripting.c	/^    char digest[41];$/;"	l	language:C
digest	server.h	/^    moduleTypeDigestFunc digest;$/;"	m	language:C	struct:RedisModuleType	access:public
digest	util.c	/^            unsigned char digest[20];$/;"	l	language:C
digits	util.c	/^    static const char digits[201] =$/;"	l	language:C	file:
digits	util.c	/^    unsigned int digits;$/;"	l	language:C
digits10	util.c	/^uint32_t digits10(uint64_t v) {$/;"	f	language:C	signature:(uint64_t v)
digits10	util.h	/^uint32_t digits10(uint64_t v);$/;"	p	language:C	signature:(uint64_t v)
direction	adlist.h	/^    int direction;$/;"	m	language:C	struct:listIter	access:public
direction	cluster.c	/^                char direction;$/;"	l	language:C
direction	quicklist.h	/^    int direction;$/;"	m	language:C	struct:quicklistIter	access:public
direction	server.h	/^    unsigned char direction; \/* Iteration direction *\/$/;"	m	language:C	struct:__anon31	access:public
dirty	server.c	/^    long long dirty, start, duration;$/;"	l	language:C
dirty	server.h	/^    long long dirty;                \/* Changes to DB from the last save *\/$/;"	m	language:C	struct:redisServer	access:public
dirty_before_bgsave	server.h	/^    long long dirty_before_bgsave;  \/* Used to restore dirty on failed BGSAVE *\/$/;"	m	language:C	struct:redisServer	access:public
dirty_slots	cluster.c	/^        int dirty_slots = 0; \/* Sender claimed slots don't match my view? *\/$/;"	l	language:C
dirty_slots	cluster.c	/^    uint16_t dirty_slots[CLUSTER_SLOTS];$/;"	l	language:C
dirty_slots_count	cluster.c	/^    int dirty_slots_count = 0;$/;"	l	language:C
disableWatchdog	debug.c	/^void disableWatchdog(void) {$/;"	f	language:C	signature:(void)
disableWatchdog	server.h	/^void disableWatchdog(void);$/;"	p	language:C	signature:(void)
discardCommand	multi.c	/^void discardCommand(client *c) {$/;"	f	language:C	signature:(client *c)
discardCommand	server.h	/^void discardCommand(client *c);$/;"	p	language:C	signature:(client *c)
discardTransaction	multi.c	/^void discardTransaction(client *c) {$/;"	f	language:C	signature:(client *c)
discardTransaction	server.h	/^void discardTransaction(client *c);$/;"	p	language:C	signature:(client *c)
disconnectAllBlockedClients	blocked.c	/^void disconnectAllBlockedClients(void) {$/;"	f	language:C	signature:(void)
disconnectAllBlockedClients	server.h	/^void disconnectAllBlockedClients(void);$/;"	p	language:C	signature:(void)
disconnectSlaves	networking.c	/^void disconnectSlaves(void) {$/;"	f	language:C	signature:(void)
disconnectSlaves	server.h	/^void disconnectSlaves(void);$/;"	p	language:C	signature:(void)
disconnected	sentinel.c	/^    int disconnected;      \/* Non-zero if we need to reconnect cc or pc. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
disk	modules/TYPES.md	/^the raw string saving API to, for example, save a structure on disk, you$/;"	v	language:C
dist	geo.h	/^    double dist;$/;"	m	language:C	struct:geoPoint	access:public
distance	geo.c	/^    double distance, xy[2];$/;"	l	language:C
distance	geo.c	/^    double distance;$/;"	l	language:C
distance	geohash_helper.c	/^    double distance = radius_meters \/ EARTH_RADIUS_IN_METERS;$/;"	l	language:C
distsamples	redis-cli.c	/^struct distsamples {$/;"	s	language:C	file:
distsamples::character	redis-cli.c	/^    int character;   \/* Associated character in visualization. *\/$/;"	m	language:C	struct:distsamples	file:	access:public
distsamples::count	redis-cli.c	/^    long long count; \/* Number of samples in this interval. *\/$/;"	m	language:C	struct:distsamples	file:	access:public
distsamples::max	redis-cli.c	/^    long long max;   \/* Max latency to fit into this interval (usec). *\/$/;"	m	language:C	struct:distsamples	file:	access:public
dlen	geo.c	/^    int dlen = snprintf(dbuf, sizeof(dbuf), "%.4f", d);$/;"	l	language:C
dlen	networking.c	/^    int dlen, slen;$/;"	l	language:C
dlen	rio.c	/^    unsigned int dlen;$/;"	l	language:C
dobj	t_list.c	/^        robj *dobj = lookupKeyWrite(c->db,c->argv[2]);$/;"	l	language:C
document	modules/INTRO.md	/^management, covered later in this document, can be a good alternative, by$/;"	v	language:C
doflush	rio.c	/^    int doflush = (buf == NULL && len == 0);$/;"	l	language:C
doing	redis-check-rdb.c	/^    int doing;                      \/* The state while reading the RDB. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
done	redis-cli.c	/^    int done = 0;$/;"	l	language:C
done	sds.c	/^            int done=0;$/;"	l	language:C
dontsort	sort.c	/^    int j, dontsort = 0, vectorlen;$/;"	l	language:C
dotPath	redis-cli.c	/^    sds dotPath = NULL;$/;"	l	language:C
double_array	modules/TYPES.md	/^    struct double_array {$/;"	s	language:C	file:
double_array::count	modules/TYPES.md	/^        size_t count;$/;"	m	language:C	struct:double_array	file:	access:public
double_array::values	modules/TYPES.md	/^        double *values;$/;"	m	language:C	struct:double_array	file:	access:public
down_after_period	sentinel.c	/^    mstime_t down_after_period; \/* Consider it down after that period. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
dst	db.c	/^    redisDb *src, *dst;$/;"	l	language:C
dst	intset.c	/^    void *src, *dst;$/;"	l	language:C
dstkey	modules/helloworld.c	/^    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],$/;"	l	language:C
dstkey	t_list.c	/^                        robj *dstkey = receiver->bpop.target;$/;"	l	language:C
dstobj	t_list.c	/^        robj *dstobj =$/;"	l	language:C
dstobj	t_zset.c	/^    robj *dstobj;$/;"	l	language:C
dstset	t_set.c	/^    robj *dstset = NULL;$/;"	l	language:C
dstset	t_set.c	/^    robj *srcset, *dstset, *ele;$/;"	l	language:C
dstzset	t_zset.c	/^    zset *dstzset;$/;"	l	language:C
dt	redis-benchmark.c	/^    float dt = (float)(mstime()-config.start)\/1000.0;$/;"	l	language:C
dtime	debug.c	/^        double dtime = strtod(c->argv[2]->ptr,NULL);$/;"	l	language:C
dumpCommand	cluster.c	/^void dumpCommand(client *c) {$/;"	f	language:C	signature:(client *c)
dumpCommand	server.h	/^void dumpCommand(client *c);$/;"	p	language:C	signature:(client *c)
dumpobj	cluster.c	/^    robj *o, *dumpobj;$/;"	l	language:C
dup	adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	language:C	struct:list	access:public
dupClientReplyValue	networking.c	/^void *dupClientReplyValue(void *o) {$/;"	f	language:C	signature:(void *o)
dupClientReplyValue	server.h	/^void *dupClientReplyValue(void *o);$/;"	p	language:C	signature:(void *o)
dupSentinelAddr	sentinel.c	/^sentinelAddr *dupSentinelAddr(sentinelAddr *src) {$/;"	f	language:C	signature:(sentinelAddr *src)
dupStringObject	object.c	/^robj *dupStringObject(const robj *o) {$/;"	f	language:C	signature:(const robj *o)
dupStringObject	server.h	/^robj *dupStringObject(const robj *o);$/;"	p	language:C	signature:(const robj *o)
duration	networking.c	/^        long long duration;$/;"	l	language:C
duration	server.c	/^    long long dirty, start, duration;$/;"	l	language:C
duration	slowlog.h	/^    long long duration; \/* Time spent by the query, in nanoseconds. *\/$/;"	m	language:C	struct:slowlogEntry	access:public
e	ae_epoll.c	/^            struct epoll_event *e = state->events+j;$/;"	l	language:C
e	ae_kqueue.c	/^            struct kevent *e = state->events+j;$/;"	l	language:C
e	cluster.c	/^    int s, e; \/* start-end indexes of { and } *\/$/;"	l	language:C
e	sentinel.c	/^            sds e = sdscatfmt(sdsempty(),$/;"	l	language:C
e	sentinel.c	/^    redisAeEvents *e = (redisAeEvents*)privdata;$/;"	l	language:C
e	sentinel.c	/^    redisAeEvents *e;$/;"	l	language:C
e	sha1.c	/^    uint32_t a, b, c, d, e;$/;"	l	language:C
e	ziplist.c	/^        zipEntry(ziplistIndex(zl, i), &e[i]);$/;"	l	language:C
e	ziplist.c	/^        zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,$/;"	l	language:C
e	zipmap.c	/^            unsigned char e;$/;"	l	language:C
east	geohash.h	/^    GeoHashBits east;$/;"	m	language:C	struct:__anon17	access:public
east	geohash_helper.c	/^        GeoHashArea north, south, east, west;$/;"	l	language:C
echo	redis-cli.c	/^                        char echo[] =$/;"	l	language:C
echoCommand	server.c	/^void echoCommand(client *c) {$/;"	f	language:C	signature:(client *c)
echoCommand	server.h	/^void echoCommand(client *c);$/;"	p	language:C	signature:(client *c)
ee	ae_epoll.c	/^    struct epoll_event ee = {0}; \/* avoid valgrind warning *\/$/;"	l	language:C
eip	debug.c	/^    void *eip = getMcontextEip(uc);$/;"	l	language:C
el	redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	language:C	struct:config	file:	access:public
el	server.h	/^    aeEventLoop *el;$/;"	m	language:C	struct:redisServer	access:public
elapsed	expire.c	/^                long long elapsed = ustime()-start;$/;"	l	language:C
elapsed	latency.c	/^        int elapsed;$/;"	l	language:C
elapsed	networking.c	/^            time_t elapsed = server.unixtime - c->obuf_soft_limit_reached_time;$/;"	l	language:C
elapsed	redis-cli.c	/^                    long long start_time = mstime(), elapsed;$/;"	l	language:C
elapsed	scripting.c	/^        mstime_t elapsed = mstime() - server.lua_time_start;$/;"	l	language:C
elapsed	scripting.c	/^    long long elapsed;$/;"	l	language:C
elapsed	sentinel.c	/^        mstime_t elapsed = mstime() - ri->last_master_down_reply_time;$/;"	l	language:C
elapsed	sentinel.c	/^    mstime_t elapsed = 0;$/;"	l	language:C
elapsed	sentinel.c	/^    mstime_t elapsed = mstime() - master->failover_state_change_time;$/;"	l	language:C
elapsed	server.c	/^            time_t eta, elapsed;$/;"	l	language:C
elapsed	syncio.c	/^        long long elapsed;$/;"	l	language:C
ele	aof.c	/^            sds ele = dictGetKey(de);$/;"	l	language:C
ele	geo.c	/^            sds ele = ln->ele;$/;"	l	language:C
ele	hyperloglog.c	/^    uint64_t ele;$/;"	l	language:C
ele	module.c	/^        RedisModuleCallReply *ele = reply->val.array+j;$/;"	l	language:C
ele	module.c	/^        sds ele = ziplistGetObject(eptr);$/;"	l	language:C
ele	modules/hellotype.c	/^        int64_t ele = RedisModule_LoadSigned(rdb);$/;"	l	language:C
ele	modules/helloworld.c	/^        RedisModuleCallReply *ele = RedisModule_CallReplyArrayElement(reply,j);$/;"	l	language:C
ele	modules/helloworld.c	/^        RedisModuleString *ele = RedisModule_ListPop(key,REDISMODULE_LIST_TAIL);$/;"	l	language:C
ele	modules/helloworld.c	/^        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);$/;"	l	language:C
ele	modules/helloworld.c	/^        RedisModuleString *ele;$/;"	l	language:C
ele	rdb.c	/^                sds ele = dictGetKey(de);$/;"	l	language:C
ele	rdb.c	/^    robj *o = NULL, *ele, *dec;$/;"	l	language:C
ele	server.h	/^    sds ele;$/;"	m	language:C	struct:zskiplistNode	access:public
ele	t_hash.c	/^        sds ele = hashTypeCurrentFromHashTable(hi, what);$/;"	l	language:C
ele	t_set.c	/^    robj *set, *ele, *aux;$/;"	l	language:C
ele	t_set.c	/^    robj *srcset, *dstset, *ele;$/;"	l	language:C
ele	t_set.c	/^    sds ele;$/;"	l	language:C
ele	t_zset.c	/^            sds ele = dictGetKey(de);$/;"	l	language:C
ele	t_zset.c	/^        sds ele = val->ele;$/;"	l	language:C
ele	t_zset.c	/^        sds ele;$/;"	l	language:C
ele	t_zset.c	/^    robj *ele = c->argv[2];$/;"	l	language:C
ele	t_zset.c	/^    sds ele;$/;"	l	language:C
ele	t_zset.c	/^    sds ele;$/;"	m	language:C	struct:__anon46	file:	access:public
election_timeout	sentinel.c	/^        int election_timeout = SENTINEL_ELECTION_TIMEOUT;$/;"	l	language:C
eledigest	debug.c	/^                    unsigned char eledigest[20];$/;"	l	language:C
eledigest	debug.c	/^                unsigned char eledigest[20];$/;"	l	language:C
elelen	geo.c	/^            size_t elelen = sdslen(gp->member);$/;"	l	language:C
element	t_set.c	/^        sds element;$/;"	l	language:C
elements	geo.c	/^    int elements = (c->argc - 2) \/ 3;$/;"	l	language:C
elements	modules/API.md	/^length, since we produce a fixed number of elements, but in the practice$/;"	v	language:C
elements	modules/hellotype.c	/^    uint64_t elements = RedisModule_LoadUnsigned(rdb);$/;"	l	language:C
elements	sds.c	/^    int elements = 0, slots = 5, start = 0, j;$/;"	l	language:C
elements	t_zset.c	/^    int j, elements;$/;"	l	language:C
elen	redis-cli.c	/^        int elen = line[1] == ' ' ? 2 : 5; \/* "e " or "eval "? *\/$/;"	l	language:C
elen	t_zset.c	/^    unsigned int elen;$/;"	m	language:C	struct:__anon46	file:	access:public
elen	ziplist.c	/^    unsigned int elen;$/;"	l	language:C
eleobj	debug.c	/^                    robj *eleobj = listTypeGet(&entry);$/;"	l	language:C
elesds	t_set.c	/^    sds elesds;$/;"	l	language:C
ell	t_zset.c	/^            int64_t ell;$/;"	l	language:C
ell	t_zset.c	/^    long long ell;$/;"	m	language:C	struct:__anon46	file:	access:public
emask	networking.c	/^    int emask;$/;"	l	language:C
emb	object.c	/^        robj *emb;$/;"	l	language:C
empty	modules/API.md	/^If the key is NULL, is not associated with a module type, or is empty,$/;"	v	language:C
empty	modules/API.md	/^If the key pointer is NULL or the key is empty, zero is returned.$/;"	v	language:C
empty	modules/TYPES.md	/^is empty, if it contains a value of the right kind, and so forth. So$/;"	v	language:C
empty	modules/TYPES.md	/^the key is empty, or retrieve the reference to the value associated to the$/;"	v	language:C
empty	zipmap.c	/^    unsigned int empty, vempty;$/;"	l	language:C
emptyDb	db.c	/^long long emptyDb(int dbnum, int flags, void(callback)(void*)) {$/;"	f	language:C	signature:(int dbnum, int flags, void(callback)(void*))
emptyDb	server.h	/^long long emptyDb(int dbnum, int flags, void(callback)(void*));$/;"	p	language:C	signature:(int dbnum, int flags, void(callback)(void*))
emptyDbAsync	lazyfree.c	/^void emptyDbAsync(redisDb *db) {$/;"	f	language:C	signature:(redisDb *db)
emptyDbAsync	server.h	/^void emptyDbAsync(redisDb *db);$/;"	p	language:C	signature:(redisDb *db)
empty_visits	dict.c	/^    int empty_visits = n*10; \/* Max number of empty buckets to visit. *\/$/;"	l	language:C
emptybulk	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
emptylen	dict.c	/^    unsigned long emptylen = 0; \/* Continuous empty entries so far. *\/$/;"	l	language:C
emptymultibulk	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
emptyscan	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
emptystring	module.c	/^    char *emptystring = "<dma-empty-string>";$/;"	l	language:C
enable	config.c	/^        int enable = yesnotoi(o->ptr);$/;"	l	language:C
enableWatchdog	debug.c	/^void enableWatchdog(int period) {$/;"	f	language:C	signature:(int period)
enableWatchdog	server.h	/^void enableWatchdog(int period);$/;"	p	language:C	signature:(int period)
enable_ldb_on_eval	redis-cli.c	/^    int enable_ldb_on_eval; \/* Handle manual SCRIPT DEBUG + EVAL commands. *\/$/;"	m	language:C	struct:config	file:	access:public
enabled	modules/INTRO.md	/^wrong number of arguments. In the above cases the `errno` var is set to `EINVAL`. NULL is also returned when, in an instance with Cluster enabled, the target$/;"	v	language:C
enc	rdb.c	/^    unsigned char enc[4];$/;"	l	language:C
enclen	rdb.c	/^    int enclen = rdbEncodeInteger(value,buf);$/;"	l	language:C
enclen	rdb.c	/^    int enclen;$/;"	l	language:C
encode	rdb.c	/^    int encode = flags & RDB_LOAD_ENC;$/;"	l	language:C
encoded	rdb.c	/^        unsigned char *encoded =$/;"	l	language:C
encoding	hyperloglog.c	/^    uint8_t encoding;   \/* HLL_DENSE or HLL_SPARSE. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
encoding	intset.c	/^        uint32_t encoding = intrev32ifbe(is->encoding);$/;"	l	language:C
encoding	intset.c	/^    uint32_t encoding = intrev32ifbe(is->encoding);$/;"	l	language:C
encoding	intset.h	/^    uint32_t encoding;$/;"	m	language:C	struct:intset	access:public
encoding	quicklist.h	/^    unsigned int encoding : 2;   \/* RAW==1 or LZF==2 *\/$/;"	m	language:C	struct:quicklistNode	access:public
encoding	server.h	/^    int encoding;$/;"	m	language:C	struct:__anon33	access:public
encoding	server.h	/^    int encoding;$/;"	m	language:C	struct:__anon34	access:public
encoding	server.h	/^    unsigned char encoding;$/;"	m	language:C	struct:__anon31	access:public
encoding	server.h	/^    unsigned encoding:4;$/;"	m	language:C	struct:redisObject	access:public
encoding	t_set.c	/^    int encoding;$/;"	l	language:C
encoding	t_zset.c	/^    int encoding;$/;"	m	language:C	struct:__anon40	file:	access:public
encoding	ziplist.c	/^        unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
encoding	ziplist.c	/^    unsigned char encoding = 0;$/;"	l	language:C
encoding	ziplist.c	/^    unsigned char encoding;$/;"	m	language:C	struct:zlentry	file:	access:public
encoding	ziplist.c	/^    unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
encodingstr	hyperloglog.c	/^        char *encodingstr[2] = {"dense","sparse"};$/;"	l	language:C
encver	modules/API.md	/^  and to register the type with encver=1. However this module may$/;"	v	language:C
end	bitops.c	/^    long bit, start, end, strlen;$/;"	l	language:C
end	bitops.c	/^    long start, end, strlen;$/;"	l	language:C
end	debug.c	/^        char *start, *end, *p = line;$/;"	l	language:C
end	hyperloglog.c	/^        uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);$/;"	l	language:C
end	hyperloglog.c	/^    const uint8_t *end = data + (len-(len&7));$/;"	l	language:C
end	hyperloglog.c	/^    uint8_t *end = sparse+sparselen, *p = sparse;$/;"	l	language:C
end	hyperloglog.c	/^    uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);$/;"	l	language:C
end	hyperloglog.c	/^    uint8_t oldcount, count, *sparse, *end, *p, *prev, *next;$/;"	l	language:C
end	memtest.c	/^    unsigned long *end = (unsigned long*) (((unsigned char*)m)+(bytes-MEMTEST_DECACHE_SIZE));$/;"	l	language:C
end	redis-cli.c	/^        long long start, end, latency;$/;"	l	language:C
end	sds.c	/^    char *start, *end, *sp, *ep;$/;"	l	language:C
end	sentinel.c	/^            char *ip, *port, *end;$/;"	l	language:C
end	setproctitle.c	/^	char *base, *end, *nul, *tmp;$/;"	l	language:C
end	setproctitle.c	/^	char *base, *end;$/;"	m	language:C	struct:__anon37	file:	access:public
end	sort.c	/^    long limit_start = 0, limit_count = -1, start, end;$/;"	l	language:C
end	t_list.c	/^    long start, end, llen, ltrim, rtrim;$/;"	l	language:C
end	t_list.c	/^    long start, end, llen, rangelen;$/;"	l	language:C
end	t_string.c	/^    long long start, end;$/;"	l	language:C
end	t_zset.c	/^    long end;$/;"	l	language:C
end	t_zset.c	/^    long start, end, llen;$/;"	l	language:C
end	util.c	/^                    int end = pattern[2];$/;"	l	language:C
end_addr	debug.c	/^    size_t start_addr, end_addr, size;$/;"	l	language:C
end_given	bitops.c	/^    int end_given = 0;$/;"	l	language:C
endianconvTest	endianconv.c	/^int endianconvTest(int argc, char *argv[]) {$/;"	f	language:C	signature:(int argc, char *argv[])
endianconvTest	endianconv.h	/^int endianconvTest(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
endptr	rdb.c	/^    char *endptr, buf[32];$/;"	l	language:C
endptr	util.c	/^    char *endptr;$/;"	l	language:C
endspace	redis-cli.c	/^    int endspace = buflen && isspace(buf[buflen-1]);$/;"	l	language:C
enough	modules/TYPES.md	/^course this is not enough, we need the information needed to link a specific$/;"	v	language:C
enough	modules/TYPES.md	/^problems, this is not enough, and the implementation of new data structures$/;"	v	language:C
entry	aof.c	/^        quicklistEntry entry;$/;"	l	language:C
entry	debug.c	/^                listTypeEntry entry;$/;"	l	language:C
entry	dict.c	/^    dictEntry *entry = dictAddRaw(d,key);$/;"	l	language:C
entry	dict.c	/^    dictEntry *entry = dictFind(d,key);$/;"	l	language:C
entry	dict.c	/^    dictEntry *entry, auxentry;$/;"	l	language:C
entry	dict.c	/^    dictEntry *entry;$/;"	l	language:C
entry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	language:C	struct:dictIterator	access:public
entry	quicklist.c	/^                    quicklistEntry entry;$/;"	l	language:C
entry	quicklist.c	/^                quicklistEntry entry;$/;"	l	language:C
entry	quicklist.c	/^            quicklistEntry entry;$/;"	l	language:C
entry	quicklist.c	/^    quicklistEntry entry;$/;"	l	language:C
entry	redis-cli.c	/^        redisReply *entry = reply->element[j];$/;"	l	language:C
entry	redis-cli.c	/^    helpEntry *entry;$/;"	l	language:C
entry	server.h	/^    quicklistEntry entry; \/* Entry in quicklist *\/$/;"	m	language:C	struct:__anon32	access:public
entry	sort.c	/^            listTypeEntry entry;$/;"	l	language:C
entry	sort.c	/^        listTypeEntry entry;$/;"	l	language:C
entry	t_list.c	/^            listTypeEntry entry;$/;"	l	language:C
entry	t_list.c	/^        quicklistEntry entry;$/;"	l	language:C
entry	t_list.c	/^    listTypeEntry entry;$/;"	l	language:C
entry	ziplist.c	/^    unsigned char *entry;$/;"	l	language:C
entry	ziplist.c	/^    zlentry entry;$/;"	l	language:C
environ	sentinel.c	/^extern char **environ;$/;"	x	language:C
environ	server.c	/^extern char **environ;$/;"	x	language:C
environ	setproctitle.c	/^	extern char **environ;$/;"	x	language:C
environ	setproctitle.c	/^extern char **environ;$/;"	x	language:C
envp	setproctitle.c	/^        char **envp = environ;$/;"	l	language:C
eof	redis-cli.c	/^    int eof = 0; \/* True once we consumed all the standard input. *\/$/;"	l	language:C
eof_reached	replication.c	/^    int eof_reached = 0;$/;"	l	language:C
eofmark	rdb.c	/^    char eofmark[RDB_EOF_MARK_SIZE];$/;"	l	language:C
eofmark	replication.c	/^    static char eofmark[CONFIG_RUN_ID_SIZE];$/;"	l	language:C	file:
ep	evict.c	/^    struct evictionPoolEntry *ep;$/;"	l	language:C
ep	sds.c	/^    char *start, *end, *sp, *ep;$/;"	l	language:C
epfd	ae_epoll.c	/^    int epfd;$/;"	m	language:C	struct:aeApiState	file:	access:public
epoch	cluster.c	/^        long long epoch;$/;"	l	language:C
epos	redis-check-aof.c	/^static off_t epos;$/;"	v	language:C	file:
eptr	aof.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
eptr	config.c	/^            char *eptr;$/;"	l	language:C
eptr	db.c	/^    char *eptr;$/;"	l	language:C
eptr	debug.c	/^                    unsigned char *eptr, *sptr;$/;"	l	language:C
eptr	geo.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
eptr	module.c	/^        unsigned char *eptr = key->zcurrent;$/;"	l	language:C
eptr	module.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
eptr	object.c	/^    char *eptr;$/;"	l	language:C
eptr	redis-check-aof.c	/^    char buf[128], *eptr;$/;"	l	language:C
eptr	sort.c	/^                    char *eptr;$/;"	l	language:C
eptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
eptr	t_zset.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
eptr	t_zset.c	/^        unsigned char *eptr;$/;"	l	language:C
eptr	t_zset.c	/^    char *eptr;$/;"	l	language:C
eptr	t_zset.c	/^    unsigned char *eptr = ziplistIndex(zl,-2), *sptr;$/;"	l	language:C
eptr	t_zset.c	/^    unsigned char *eptr = ziplistIndex(zl,0), *sptr;$/;"	l	language:C
eptr	t_zset.c	/^    unsigned char *eptr, *sptr;$/;"	l	language:C
eptr	util.c	/^    char *eptr;$/;"	l	language:C
eq	setproctitle.c	/^	char *eq;$/;"	l	language:C
equalStringObjects	object.c	/^int equalStringObjects(robj *a, robj *b) {$/;"	f	language:C	signature:(robj *a, robj *b)
equalStringObjects	server.h	/^int equalStringObjects(robj *a, robj *b);$/;"	p	language:C	signature:(robj *a, robj *b)
err	ae_evport.c	/^    int rv, err;$/;"	l	language:C
err	bio.c	/^    int err, j;$/;"	l	language:C
err	bitops.c	/^    char *err = "Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is.";$/;"	l	language:C
err	bitops.c	/^    char *err = "bit is not an integer or out of range";$/;"	l	language:C
err	bitops.c	/^    char *err = "bit offset is not an integer or out of range";$/;"	l	language:C
err	config.c	/^    char *err = NULL;$/;"	l	language:C
err	config.c	/^    int err;$/;"	l	language:C
err	networking.c	/^            char *err =$/;"	l	language:C
err	networking.c	/^        char *err = "-ERR max number of clients reached\\r\\n";$/;"	l	language:C
err	quicklist.c	/^    unsigned int err = 0;$/;"	l	language:C
err	replication.c	/^    char tmpfile[256], *err = NULL;$/;"	l	language:C
err	scripting.c	/^            sds err = sdsnew(lua_tostring(lua,-1));$/;"	l	language:C
err	scripting.c	/^    int delhook = 0, err;$/;"	l	language:C
err	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
errh_func	scripting.c	/^        char *errh_func =       "local dbg = debug\\n"$/;"	l	language:C
errlen	replication.c	/^    socklen_t errlen = sizeof(sockerr);$/;"	l	language:C
errmsg	module.c	/^            char *errmsg;$/;"	l	language:C
errmsg	module.c	/^        const char *errmsg = "(NULL string reply referenced in module)";$/;"	l	language:C
error	module.c	/^        char *error = dlerror();$/;"	l	language:C
error	modules/API.md	/^error, that is, the key is not open for writing, is not a string$/;"	v	language:C
error	modules/INTRO.md	/^If the reply type is not a string or an error, NULL is returned.$/;"	v	language:C
error	rdb.c	/^    int error = 0;$/;"	l	language:C
error	redis-check-aof.c	/^static char error[1024];$/;"	v	language:C	file:
error	redis-check-rdb.c	/^    char error[1024];$/;"	m	language:C	struct:__anon23	file:	access:public
error	server.h	/^    int error;          \/* True if error condition happened. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
error	setproctitle.c	/^	int error;$/;"	m	language:C	struct:__anon37	file:	access:public
error	setproctitle.c	/^	int i, error;$/;"	l	language:C
error	setproctitle.c	/^	int len, error;$/;"	l	language:C
error_code	server.c	/^        int error_code;$/;"	l	language:C
error_from_target	cluster.c	/^    int error_from_target = 0;$/;"	l	language:C
error_set	redis-check-rdb.c	/^    int error_set;                  \/* True if error is populated. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
errorcode	rdb.c	/^            int errorcode = 0;$/;"	l	language:C
errors	debug.c	/^    int errors = 0;$/;"	l	language:C
errors	memtest.c	/^    int errors = 0;$/;"	l	language:C
errors	modules/INTRO.md	/^similar errors, the function will return `REDISMODULE_ERR`, and the module$/;"	v	language:C
errors	quicklist.c	/^    int errors = 0;$/;"	l	language:C
errors	redis-cli.c	/^    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;$/;"	l	language:C
errstr	debug.c	/^        sds errstr = sdsnewlen("-",1);$/;"	l	language:C
estimateObjectIdleTime	evict.c	/^unsigned long long estimateObjectIdleTime(robj *o) {$/;"	f	language:C	signature:(robj *o)
estimateObjectIdleTime	server.h	/^unsigned long long estimateObjectIdleTime(robj *o);$/;"	p	language:C	signature:(robj *o)
estr	t_zset.c	/^    unsigned char *estr;$/;"	m	language:C	struct:__anon46	file:	access:public
eta	server.c	/^            time_t eta, elapsed;$/;"	l	language:C
eval	redis-cli.c	/^    char *eval;$/;"	m	language:C	struct:config	file:	access:public
evalCommand	scripting.c	/^void evalCommand(client *c) {$/;"	f	language:C	signature:(client *c)
evalCommand	server.h	/^void evalCommand(client *c);$/;"	p	language:C	signature:(client *c)
evalGenericCommand	scripting.c	/^void evalGenericCommand(client *c, int evalsha) {$/;"	f	language:C	signature:(client *c, int evalsha)
evalGenericCommandWithDebugging	scripting.c	/^void evalGenericCommandWithDebugging(client *c, int evalsha) {$/;"	f	language:C	signature:(client *c, int evalsha)
evalGenericCommandWithDebugging	scripting.c	/^void evalGenericCommandWithDebugging(client *c, int evalsha);$/;"	p	language:C	file:	signature:(client *c, int evalsha)
evalGetKeys	db.c	/^int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
evalGetKeys	server.h	/^int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
evalMode	redis-cli.c	/^static int evalMode(int argc, char **argv) {$/;"	f	language:C	file:	signature:(int argc, char **argv)
evalShaCommand	scripting.c	/^void evalShaCommand(client *c) {$/;"	f	language:C	signature:(client *c)
evalShaCommand	server.h	/^void evalShaCommand(client *c);$/;"	p	language:C	signature:(client *c)
eval_ldb	redis-cli.c	/^        int eval_ldb = config.eval_ldb; \/* Save it, may be reverteed. *\/$/;"	l	language:C
eval_ldb	redis-cli.c	/^    int eval_ldb;$/;"	m	language:C	struct:config	file:	access:public
eval_ldb_end	redis-cli.c	/^    int eval_ldb_end;   \/* Lua debugging session ended. *\/$/;"	m	language:C	struct:config	file:	access:public
eval_ldb_sync	redis-cli.c	/^    int eval_ldb_sync;  \/* Ask for synchronous mode of the Lua debugger. *\/$/;"	m	language:C	struct:config	file:	access:public
event	ae_evport.c	/^    port_event_t event[MAX_EVENT_BATCHSZ];$/;"	l	language:C
event	latency.c	/^        char *event = dictGetKey(de);$/;"	l	language:C
event	latency.c	/^        char *event;$/;"	l	language:C
event	t_list.c	/^                    char *event = (where == LIST_HEAD) ? "lpop" : "rpop";$/;"	l	language:C
event	t_list.c	/^        char *event = (where == LIST_HEAD) ? "lpop" : "rpop";$/;"	l	language:C
event	t_list.c	/^        char *event = (where == LIST_HEAD) ? "lpush" : "rpush";$/;"	l	language:C
event	t_zset.c	/^        char *event[3] = {"zremrangebyrank","zremrangebyscore","zremrangebylex"};$/;"	l	language:C
eventLoop	ae.c	/^    aeEventLoop *eventLoop;$/;"	l	language:C
eventnum	latency.c	/^    int eventnum = 0;$/;"	l	language:C
eventobj	notify.c	/^    robj *chanobj, *eventobj;$/;"	l	language:C
events	ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	language:C	struct:aeEventLoop	access:public
events	ae_epoll.c	/^    struct epoll_event *events;$/;"	m	language:C	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:	access:public
events	ae_evport.c	/^    int events = 0;$/;"	l	language:C
events	ae_kqueue.c	/^    struct kevent *events;$/;"	m	language:C	struct:aeApiState	typeref:struct:aeApiState::kevent	file:	access:public
events	networking.c	/^        int events = 0;$/;"	l	language:C
events	networking.c	/^        int events;$/;"	l	language:C
events	networking.c	/^    char flags[16], events[3], *p;$/;"	l	language:C
evictPolicyToString	config.c	/^const char *evictPolicyToString(void) {$/;"	f	language:C	signature:(void)
evictPolicyToString	server.h	/^const char *evictPolicyToString(void);$/;"	p	language:C	signature:(void)
evict_policy	server.c	/^        const char *evict_policy = evictPolicyToString();$/;"	l	language:C
evictionPoolAlloc	evict.c	/^void evictionPoolAlloc(void) {$/;"	f	language:C	signature:(void)
evictionPoolAlloc	server.h	/^void evictionPoolAlloc(void);$/;"	p	language:C	signature:(void)
evictionPoolEntry	evict.c	/^struct evictionPoolEntry {$/;"	s	language:C	file:
evictionPoolEntry	server.h	/^struct evictionPoolEntry; \/* Defined in evict.c *\/$/;"	x	language:C
evictionPoolEntry::cached	evict.c	/^    sds cached;                 \/* Cached SDS object for key name. *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
evictionPoolEntry::dbid	evict.c	/^    int dbid;                   \/* Key DB number. *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
evictionPoolEntry::idle	evict.c	/^    unsigned long long idle;    \/* Object idle time (inverse frequency for LFU) *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
evictionPoolEntry::key	evict.c	/^    sds key;                    \/* Key name. *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
evictionPoolPopulate	evict.c	/^void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {$/;"	f	language:C	signature:(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)
eviction_latency	evict.c	/^    mstime_t latency, eviction_latency;$/;"	l	language:C
evport_debug	ae_evport.c	/^static int evport_debug = 0;$/;"	v	language:C	file:
execCommand	multi.c	/^void execCommand(client *c) {$/;"	f	language:C	signature:(client *c)
execCommand	server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
execCommand	server.h	/^void execCommand(client *c);$/;"	p	language:C	signature:(client *c)
execCommandPropagateMulti	multi.c	/^void execCommandPropagateMulti(client *c) {$/;"	f	language:C	signature:(client *c)
execCommandPropagateMulti	server.h	/^void execCommandPropagateMulti(client *c);$/;"	p	language:C	signature:(client *c)
exec_argv	server.h	/^    char **exec_argv;           \/* Executable argv vector (copy). *\/$/;"	m	language:C	struct:redisServer	access:public
execaborterr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
executable	server.h	/^    char *executable;           \/* Absolute executable file path. *\/$/;"	m	language:C	struct:redisServer	access:public
exist	modules/API.md	/^element does not already exist, it is added assuming the old score was$/;"	v	language:C
exist	modules/API.md	/^value of the field if the field exist, or NULL if the field did not exist.$/;"	v	language:C
exists	module.c	/^            int exists = hashTypeExists(key->value, field->ptr);$/;"	l	language:C
exists	modules/API.md	/^     int exists;$/;"	v	language:C
existsCommand	db.c	/^void existsCommand(client *c) {$/;"	f	language:C	signature:(client *c)
existsCommand	server.h	/^void existsCommand(client *c);$/;"	p	language:C	signature:(client *c)
existsptr	module.c	/^        int *existsptr;$/;"	l	language:C
exitFromChild	server.c	/^void exitFromChild(int retcode) {$/;"	f	language:C	signature:(int retcode)
exitFromChild	server.h	/^void exitFromChild(int retcode);$/;"	p	language:C	signature:(int retcode)
exit_status	redis-benchmark.c	/^    int exit_status = 1;$/;"	l	language:C
exitcode	sentinel.c	/^        int exitcode = WEXITSTATUS(statloc);$/;"	l	language:C
exitcode	server.c	/^            int exitcode = WEXITSTATUS(statloc);$/;"	l	language:C
expect	lzf_c.c	/^# define expect(/;"	d	language:C	file:
expect_false	lzf_c.c	/^#define expect_false(/;"	d	language:C	file:
expect_true	lzf_c.c	/^#define expect_true(/;"	d	language:C	file:
expected	modules/testmodule.c	/^    RedisModuleString *mystr, *expected;$/;"	l	language:C
expected	rdb.c	/^        uint64_t cksum, expected = rdb.cksum;$/;"	l	language:C
expected	redis-check-rdb.c	/^        uint64_t cksum, expected = rdb.cksum;$/;"	l	language:C
expected_index	scripting.c	/^        int expected_index = 1; \/* First index we expect in an array. *\/$/;"	l	language:C
expected_ptr	modules/testmodule.c	/^        const char *expected_ptr = RedisModule_StringPtrLen(expected,NULL);$/;"	l	language:C
expire	cluster.c	/^        int64_t expire = dictGetUnsignedIntegerVal(de);$/;"	l	language:C
expire	db.c	/^    long long dbid, expire;$/;"	l	language:C
expire	db.c	/^    long long expire;$/;"	l	language:C
expire	expire.c	/^    long long expire, ttl = -1;$/;"	l	language:C
expire	module.c	/^    mstime_t expire = getExpire(key->db,key->key);$/;"	l	language:C
expire	rdb.c	/^            long long expire;$/;"	l	language:C
expire	t_string.c	/^    robj *expire = NULL;$/;"	l	language:C
expireCommand	expire.c	/^void expireCommand(client *c) {$/;"	f	language:C	signature:(client *c)
expireCommand	server.h	/^void expireCommand(client *c);$/;"	p	language:C	signature:(client *c)
expireGenericCommand	expire.c	/^void expireGenericCommand(client *c, long long basetime, int unit) {$/;"	f	language:C	signature:(client *c, long long basetime, int unit)
expireIfNeeded	db.c	/^int expireIfNeeded(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
expireIfNeeded	server.h	/^int expireIfNeeded(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
expireat	cluster.c	/^    long long ttl, expireat;$/;"	l	language:C
expireatCommand	expire.c	/^void expireatCommand(client *c) {$/;"	f	language:C	signature:(client *c)
expireatCommand	server.h	/^void expireatCommand(client *c);$/;"	p	language:C	signature:(client *c)
expired	expire.c	/^        int expired;$/;"	l	language:C
expires	redis-check-rdb.c	/^    unsigned long expires;          \/* Number of keys with an expire. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
expires	server.h	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	language:C	struct:redisDb	access:public
expires_size	rdb.c	/^            uint64_t db_size, expires_size;$/;"	l	language:C
expires_size	redis-check-rdb.c	/^            uint64_t db_size, expires_size;$/;"	l	language:C
expiretime	aof.c	/^            long long expiretime;$/;"	l	language:C
expiretime	debug.c	/^            long long expiretime;$/;"	l	language:C
expiretime	rdb.c	/^    long long expiretime, now = mstime();$/;"	l	language:C
expiretime	redis-check-rdb.c	/^    long long expiretime, now = mstime();$/;"	l	language:C
explen	cluster.c	/^        uint32_t explen = sizeof(clusterMsg)-sizeof(union clusterMsgData);$/;"	l	language:C
explen	cluster.c	/^        uint32_t explen; \/* expected length of this packet *\/$/;"	l	language:C
expr	scripting.c	/^    sds expr = sdscatsds(sdsnew("return "),code);$/;"	l	language:C
extent	quicklist.c	/^    unsigned long extent = count; \/* range is inclusive of start position *\/$/;"	l	language:C
extra	debug.c	/^        char extra[128] = {0};$/;"	l	language:C
extra	quicklist.h	/^    unsigned int extra : 10; \/* more bits to steal for future usage *\/$/;"	m	language:C	struct:quicklistNode	access:public
extra	ziplist.c	/^    size_t offset, noffset, extra;$/;"	l	language:C
extractDistanceOrReply	geo.c	/^double extractDistanceOrReply(client *c, robj **argv,$/;"	f	language:C	signature:(client *c, robj **argv, double *conversion)
extractLongLatOrReply	geo.c	/^int extractLongLatOrReply(client *c, robj **argv, double *xy) {$/;"	f	language:C	signature:(client *c, robj **argv, double *xy)
extractUnitOrReply	geo.c	/^double extractUnitOrReply(client *c, robj *unit) {$/;"	f	language:C	signature:(client *c, robj *unit)
ez	hyperloglog.c	/^    int ez = 0, idx = 0, runlen, regval;$/;"	l	language:C
ez	hyperloglog.c	/^    int j, ez = 0;$/;"	l	language:C
ez	hyperloglog.c	/^    int j, ez; \/* Number of registers equal to 0. *\/$/;"	l	language:C
f	sds.c	/^    const char *f = fmt;$/;"	l	language:C
f	server.c	/^        char *f = c->sflags;$/;"	l	language:C
f	sort.c	/^    char *p, *f, *k;$/;"	l	language:C
f	t_hash.c	/^            sds f,v;$/;"	l	language:C
fail	cluster.h	/^    } fail;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon7	access:public
fail_reports	cluster.h	/^    list *fail_reports;         \/* List of nodes signaling this as failing *\/$/;"	m	language:C	struct:clusterNode	access:public
fail_time	cluster.h	/^    mstime_t fail_time;      \/* Unix time when FAIL flag was set *\/$/;"	m	language:C	struct:clusterNode	access:public
failing	cluster.c	/^        clusterNode *failing;$/;"	l	language:C
failover_auth_count	cluster.h	/^    int failover_auth_count;    \/* Number of votes received so far. *\/$/;"	m	language:C	struct:clusterState	access:public
failover_auth_epoch	cluster.h	/^    uint64_t failover_auth_epoch; \/* Epoch of the current election. *\/$/;"	m	language:C	struct:clusterState	access:public
failover_auth_rank	cluster.h	/^    int failover_auth_rank;     \/* This slave rank for current auth request. *\/$/;"	m	language:C	struct:clusterState	access:public
failover_auth_sent	cluster.h	/^    int failover_auth_sent;     \/* True if we already asked for votes. *\/$/;"	m	language:C	struct:clusterState	access:public
failover_auth_time	cluster.h	/^    mstime_t failover_auth_time; \/* Time of previous or next election. *\/$/;"	m	language:C	struct:clusterState	access:public
failover_delay_logged	sentinel.c	/^    mstime_t failover_delay_logged; \/* For what failover_start_time value we$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
failover_epoch	sentinel.c	/^    uint64_t failover_epoch; \/* Epoch of the currently started failover. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
failover_start_time	sentinel.c	/^    mstime_t failover_start_time;   \/* Last failover attempt start time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
failover_state	sentinel.c	/^    int failover_state; \/* See SENTINEL_FAILOVER_STATE_* defines. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
failover_state_change_time	sentinel.c	/^    mstime_t failover_state_change_time;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
failover_timeout	sentinel.c	/^    mstime_t failover_timeout;      \/* Max time to refresh failover state. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
failures	cluster.c	/^    int failures;$/;"	l	language:C
fakeClient	aof.c	/^    struct client *fakeClient;$/;"	l	language:C
fd	ae.c	/^            int fd = eventLoop->fired[j].fd;$/;"	l	language:C
fd	ae.h	/^    int fd;$/;"	m	language:C	struct:aeFiredEvent	access:public
fd	anet.c	/^    int fd;$/;"	l	language:C
fd	cluster.c	/^            int fd;$/;"	l	language:C
fd	cluster.c	/^    int fd = open(filename,O_WRONLY|O_CREAT,0644);$/;"	l	language:C
fd	cluster.c	/^    int fd;$/;"	l	language:C
fd	cluster.c	/^    int fd;$/;"	m	language:C	struct:migrateCachedSocket	file:	access:public
fd	cluster.h	/^    int fd;                     \/* TCP socket file descriptor *\/$/;"	m	language:C	struct:clusterLink	access:public
fd	config.c	/^    int fd = open(configfile,O_RDWR|O_CREAT,0644);$/;"	l	language:C
fd	debug.c	/^    int fd = log_to_stdout ?$/;"	l	language:C
fd	debug.c	/^    int fd = openDirectLogFiledes();$/;"	l	language:C
fd	debug.c	/^    int trace_size = 0, fd = openDirectLogFiledes();$/;"	l	language:C
fd	redis-cli.c	/^    int fd = context->fd;$/;"	l	language:C
fd	redis-cli.c	/^    int fd;$/;"	l	language:C
fd	replication.c	/^    int fd = server.repl_transfer_s;$/;"	l	language:C
fd	replication.c	/^    int fd;$/;"	l	language:C
fd	scripting.c	/^    int fd;     \/* Socket of the debugging client. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
fd	sentinel.c	/^    int fd = -1;$/;"	l	language:C
fd	sentinel.c	/^    int fd;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
fd	server.c	/^    int fd = 1;$/;"	l	language:C
fd	server.c	/^    int fd;$/;"	l	language:C
fd	server.h	/^    int fd;                 \/* Client socket. *\/$/;"	m	language:C	struct:client	access:public
fd	zmalloc.c	/^    int fd, count;$/;"	l	language:C
fds	aof.c	/^    int fds[6] = {-1, -1, -1, -1, -1, -1};$/;"	l	language:C
fds	rdb.c	/^    int *fds;$/;"	l	language:C
fds	rio.h	/^            int *fds;       \/* File descriptors. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
fdset	rio.h	/^        } fdset;$/;"	m	language:C	union:_rio::__anon25	typeref:struct:_rio::__anon25::__anon28	access:public
fe	ae.c	/^            aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];$/;"	l	language:C
fe	ae.c	/^    aeFileEvent *fe = &eventLoop->events[fd];$/;"	l	language:C
fe	ae_select.c	/^            aeFileEvent *fe = &eventLoop->events[j];$/;"	l	language:C
feedAppendOnlyFile	aof.c	/^void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {$/;"	f	language:C	signature:(struct redisCommand *cmd, int dictid, robj **argv, int argc)
feedAppendOnlyFile	server.h	/^void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);$/;"	p	language:C	signature:(struct redisCommand *cmd, int dictid, robj **argv, int argc)
feedReplicationBacklog	replication.c	/^void feedReplicationBacklog(void *ptr, size_t len) {$/;"	f	language:C	signature:(void *ptr, size_t len)
feedReplicationBacklogWithObject	replication.c	/^void feedReplicationBacklogWithObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
field	module.c	/^        RedisModuleString *field, **valueptr;$/;"	l	language:C
field	module.c	/^        RedisModuleString *field, *value;$/;"	l	language:C
field	rdb.c	/^                sds field = dictGetKey(de);$/;"	l	language:C
field	rdb.c	/^        sds field, value;$/;"	l	language:C
fieldlen	sort.c	/^    int prefixlen, sublen, postfixlen, fieldlen;$/;"	l	language:C
fieldobj	sort.c	/^    robj *keyobj, *fieldobj = NULL, *o;$/;"	l	language:C
fields	sentinel.c	/^    int fields = 0;$/;"	l	language:C
file	modules/API.md	/^from the RDB file, that was previously saved with `RedisModule_SaveString()`$/;"	v	language:C
file	rio.h	/^        } file;$/;"	m	language:C	union:_rio::__anon25	typeref:struct:_rio::__anon25::__anon27	access:public
filed	modules/API.md	/^                    associated to an existing filed, but no new fields$/;"	v	language:C
filename	redis-check-aof.c	/^    char *filename;$/;"	l	language:C
filename	zmalloc.c	/^    char filename[256];$/;"	l	language:C
files	modules/TYPES.md	/^so when it saves new RDB files, the new version will be stored on disk. However$/;"	v	language:C
fill	quicklist.c	/^    int fill = quicklist->fill;$/;"	l	language:C
fill	quicklist.h	/^    int fill : 16;              \/* fill factor for individual nodes *\/$/;"	m	language:C	struct:quicklist	access:public
filter	db.c	/^        int filter = 0;$/;"	l	language:C
finalcount	sha1.c	/^    unsigned char finalcount[8];$/;"	l	language:C
finalizerProc	ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	language:C	struct:aeTimeEvent	access:public
findBigKeys	redis-cli.c	/^static void findBigKeys(void) {$/;"	f	language:C	file:	signature:(void)
fingerprint	dict.h	/^    long long fingerprint;$/;"	m	language:C	struct:dictIterator	access:public
fired	ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	language:C	struct:aeEventLoop	access:public
first	db.c	/^    int i, num, first, *keys;$/;"	l	language:C
first	hyperloglog.c	/^    long index, first, span;$/;"	l	language:C
first	modules/hellotype.c	/^    long long first, count;$/;"	l	language:C
first	ziplist.c	/^    zlentry first, tail;$/;"	l	language:C
first_call_time	cluster.c	/^    static mstime_t first_call_time = 0;$/;"	l	language:C	file:
first_key	cluster.c	/^    int first_key = 3; \/* Argument index of the first key. *\/$/;"	l	language:C
first_len	ziplist.c	/^    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));$/;"	l	language:C
first_offset	ziplist.c	/^    size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));$/;"	l	language:C
firstarg	redis-cli.c	/^    int firstarg;$/;"	l	language:C
firstkey	cluster.c	/^    robj *firstkey = NULL;$/;"	l	language:C
firstkey	server.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	language:C	struct:redisCommand	access:public
fix	redis-check-aof.c	/^    int fix = 0;$/;"	l	language:C
flag	cluster.c	/^    uint16_t flag;$/;"	m	language:C	struct:redisNodeFlags	file:	access:public
flag	modules/API.md	/^flag "getkeys-api", is called in a special way to get the keys positions$/;"	v	language:C
flagTransaction	multi.c	/^void flagTransaction(client *c) {$/;"	f	language:C	signature:(client *c)
flagTransaction	server.h	/^void flagTransaction(client *c);$/;"	p	language:C	signature:(client *c)
flagcount	server.c	/^        int flagcount = 0;$/;"	l	language:C
flaglen	server.c	/^        void *flaglen = addDeferredMultiBulkLength(c);$/;"	l	language:C
flags	anet.c	/^    int flags;$/;"	l	language:C
flags	cluster.c	/^        uint16_t flags = ntohs(g->flags);$/;"	l	language:C
flags	cluster.c	/^    uint16_t flags = ntohs(hdr->flags);$/;"	l	language:C
flags	cluster.h	/^    int flags;      \/* CLUSTER_NODE_... *\/$/;"	m	language:C	struct:clusterNode	access:public
flags	cluster.h	/^    uint16_t flags;             \/* node->flags copy *\/$/;"	m	language:C	struct:__anon2	access:public
flags	cluster.h	/^    uint16_t flags;      \/* Sender node flags *\/$/;"	m	language:C	struct:__anon10	access:public
flags	config.c	/^            int flags = keyspaceEventsStringToFlags(argv[1]);$/;"	l	language:C
flags	config.c	/^        int flags = keyspaceEventsStringToFlags(o->ptr);$/;"	l	language:C
flags	config.c	/^    sds line, flags;$/;"	l	language:C
flags	db.c	/^    int flags = 0;$/;"	l	language:C
flags	db.c	/^    int flags;$/;"	l	language:C
flags	debug.c	/^        int flags = !strcasecmp(c->argv[1]->ptr,"restart") ?$/;"	l	language:C
flags	module.c	/^    int argc = 0, flags = 0, j;$/;"	l	language:C
flags	module.c	/^    int argc = 0, flags = 0;$/;"	l	language:C
flags	module.c	/^    int flags = 0;$/;"	l	language:C
flags	module.c	/^    int flags = strflags ? commandFlagsFromString((char*)strflags) : 0;$/;"	l	language:C
flags	module.c	/^    int flags;                      \/* REDISMODULE_CTX_... flags. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
flags	module.c	/^    int flags;      \/* REDISMODULE_REPLYFLAG_...  *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
flags	modules/API.md	/^Conversion from\/to public flags of the Modules API and our private flags,$/;"	v	language:C
flags	modules/API.md	/^The behavior of the command changes with the specified flags, that can be$/;"	v	language:C
flags	networking.c	/^    char flags[16], events[3], *p;$/;"	l	language:C
flags	notify.c	/^    int c, flags = 0;$/;"	l	language:C
flags	scripting.c	/^    int flags;$/;"	l	language:C
flags	sds.c	/^    unsigned char flags = s[-1];$/;"	l	language:C
flags	sds.h	/^    unsigned char flags = s[-1];$/;"	l	language:C
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr16	access:public
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr32	access:public
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr64	access:public
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr8	access:public
flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, and 5 msb of string length *\/$/;"	m	language:C	struct:sdshdr5	access:public
flags	sentinel.c	/^    char *flags = sdsempty();$/;"	l	language:C
flags	sentinel.c	/^    int flags;              \/* Script job flags: SENTINEL_SCRIPT_* *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
flags	sentinel.c	/^    int flags;      \/* See SRI_... defines *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
flags	server.h	/^    int flags;              \/* Client flags: CLIENT_* macros. *\/$/;"	m	language:C	struct:client	access:public
flags	server.h	/^    int flags;    \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	language:C	struct:redisCommand	access:public
flags	t_string.c	/^    int flags = OBJ_SET_NO_FLAGS;$/;"	l	language:C
flags	t_zset.c	/^    int flags;$/;"	m	language:C	struct:__anon46	file:	access:public
flagsobj	config.c	/^        robj *flagsobj = createObject(OBJ_STRING,$/;"	l	language:C
flen	rdb.c	/^                    unsigned int flen, vlen;$/;"	l	language:C
flen	zmalloc.c	/^    int flen = strlen(field);$/;"	l	language:C
flush	rio.h	/^    int (*flush)(struct _rio *);$/;"	m	language:C	struct:_rio	access:public
flushAppendOnlyFile	aof.c	/^void flushAppendOnlyFile(int force) {$/;"	f	language:C	signature:(int force)
flushAppendOnlyFile	server.h	/^void flushAppendOnlyFile(int force);$/;"	p	language:C	signature:(int force)
flushSlavesOutputBuffers	networking.c	/^void flushSlavesOutputBuffers(void) {$/;"	f	language:C	signature:(void)
flushSlavesOutputBuffers	server.h	/^void flushSlavesOutputBuffers(void);$/;"	p	language:C	signature:(void)
flushallCommand	db.c	/^void flushallCommand(client *c) {$/;"	f	language:C	signature:(client *c)
flushallCommand	server.h	/^void flushallCommand(client *c);$/;"	p	language:C	signature:(client *c)
flushdbCommand	db.c	/^void flushdbCommand(client *c) {$/;"	f	language:C	signature:(client *c)
flushdbCommand	server.h	/^void flushdbCommand(client *c);$/;"	p	language:C	signature:(client *c)
footer	cluster.c	/^    unsigned char *footer;$/;"	l	language:C
force	cluster.c	/^        int force = 0, takeover = 0;$/;"	l	language:C
force	config.c	/^        int force = (server.client_obuf_limits[j].hard_limit_bytes !=$/;"	l	language:C
force	config.c	/^    int force = 1;$/;"	l	language:C
force	config.c	/^    int force = server.notify_keyspace_events != 0;$/;"	l	language:C
force	config.c	/^    int force = value != LOG_LOCAL0;$/;"	l	language:C
force	config.c	/^    int force = value != defval;$/;"	l	language:C
force	config.c	/^    int force = value != defvalue;$/;"	l	language:C
forceCommandPropagation	server.c	/^void forceCommandPropagation(client *c, int flags) {$/;"	f	language:C	signature:(client *c, int flags)
forceCommandPropagation	server.h	/^void forceCommandPropagation(client *c, int flags);$/;"	p	language:C	signature:(client *c, int flags)
force_ack	cluster.c	/^    int force_ack = request->mflags[0] & CLUSTERMSG_FLAG0_FORCEACK;$/;"	l	language:C
force_cancel_loop	redis-cli.c	/^static volatile sig_atomic_t force_cancel_loop = 0;$/;"	v	language:C	file:
forever	modules/INTRO.md	/^is not guaranteed to be here forever, so should not be considered part$/;"	v	language:C
fork_quality	latency.c	/^            char *fork_quality;$/;"	l	language:C
forked	scripting.c	/^    int forked; \/* Is this a fork()ed debugging session? *\/$/;"	m	language:C	struct:ldbState	file:	access:public
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v	language:C
forward	quicklist.c	/^    int forward = idx < 0 ? 0 : 1; \/* < 0 -> reverse, 0+ -> forward *\/$/;"	l	language:C
forward	server.h	/^        struct zskiplistNode *forward;$/;"	m	language:C	struct:zskiplistNode::zskiplistLevel	typeref:struct:zskiplistNode::zskiplistLevel::zskiplistNode	access:public
found_store	db.c	/^    int i, j, num, *keys, found_store = 0;$/;"	l	language:C
fp	aof.c	/^    FILE *fp = fopen(filename,"r");$/;"	l	language:C
fp	aof.c	/^    FILE *fp;$/;"	l	language:C
fp	cluster.c	/^    FILE *fp = fopen(filename,"r");$/;"	l	language:C
fp	config.c	/^        FILE *fp;$/;"	l	language:C
fp	config.c	/^    FILE *fp = fopen(path,"r");$/;"	l	language:C
fp	debug.c	/^    FILE *fp;$/;"	l	language:C
fp	latency.c	/^    FILE *fp = fopen("\/sys\/kernel\/mm\/transparent_hugepage\/enabled","r");$/;"	l	language:C
fp	rdb.c	/^    FILE *fp;$/;"	l	language:C
fp	redis-check-aof.c	/^    FILE *fp = fopen(filename,"r+");$/;"	l	language:C
fp	redis-check-rdb.c	/^    FILE *fp;$/;"	l	language:C
fp	redis-cli.c	/^    FILE *fp;$/;"	l	language:C
fp	rio.h	/^            FILE *fp;$/;"	m	language:C	struct:_rio::__anon25::__anon27	access:public
fp	sds.c	/^            unsigned char *fp = ((unsigned char*)s)-1;$/;"	l	language:C
fp	sds.c	/^    unsigned char *fp; \/* flags pointer. *\/$/;"	l	language:C
fp	sds.h	/^                unsigned char *fp = ((unsigned char*)s)-1;$/;"	l	language:C
fp	server.c	/^    FILE *fp = fopen("\/proc\/sys\/net\/core\/somaxconn","r");$/;"	l	language:C
fp	server.c	/^    FILE *fp = fopen("\/proc\/sys\/vm\/overcommit_memory","r");$/;"	l	language:C
fp	server.c	/^    FILE *fp = fopen(server.pidfile,"w");$/;"	l	language:C
fp	server.c	/^    FILE *fp;$/;"	l	language:C
fp	util.c	/^        FILE *fp = fopen("\/dev\/urandom","r");$/;"	l	language:C
fp	zmalloc.c	/^    FILE *fp = fopen("\/proc\/self\/smaps","r");$/;"	l	language:C
fptr	server.h	/^    unsigned char *fptr, *vptr;$/;"	m	language:C	struct:__anon34	access:public
fptr	t_hash.c	/^        unsigned char *fptr, *vptr;$/;"	l	language:C
fptr	t_hash.c	/^        unsigned char *zl, *fptr, *vptr;$/;"	l	language:C
fptr	t_hash.c	/^        unsigned char *zl, *fptr;$/;"	l	language:C
fptr	t_hash.c	/^    unsigned char *zl, *fptr = NULL, *vptr = NULL;$/;"	l	language:C
fr	cluster.c	/^    clusterNodeFailReport *fr;$/;"	l	language:C
free	adlist.h	/^    void (*free)(void *ptr);$/;"	m	language:C	struct:list	access:public
free	aof.c	/^    unsigned long used, free;$/;"	m	language:C	struct:aofrwblock	file:	access:public
free	modules/TYPES.md	/^    #define free /;"	d	language:C	file:
free	server.h	/^    moduleTypeFreeFunc free;$/;"	m	language:C	struct:RedisModuleType	access:public
free	server.h	/^void free(void *ptr) __attribute__ ((deprecated));$/;"	p	language:C	signature:(void *ptr)
free	zipmap.c	/^        unsigned char free;$/;"	l	language:C
free	zmalloc.c	/^#define free(/;"	d	language:C	file:
freeAllClients	redis-benchmark.c	/^static void freeAllClients(void) {$/;"	f	language:C	file:	signature:(void)
freeClient	networking.c	/^void freeClient(client *c) {$/;"	f	language:C	signature:(client *c)
freeClient	redis-benchmark.c	/^static void freeClient(client c) {$/;"	f	language:C	file:	signature:(client c)
freeClient	server.h	/^void freeClient(client *c);$/;"	p	language:C	signature:(client *c)
freeClientArgv	networking.c	/^static void freeClientArgv(client *c) {$/;"	f	language:C	file:	signature:(client *c)
freeClientAsync	networking.c	/^void freeClientAsync(client *c) {$/;"	f	language:C	signature:(client *c)
freeClientAsync	server.h	/^void freeClientAsync(client *c);$/;"	p	language:C	signature:(client *c)
freeClientMultiState	multi.c	/^void freeClientMultiState(client *c) {$/;"	f	language:C	signature:(client *c)
freeClientMultiState	server.h	/^void freeClientMultiState(client *c);$/;"	p	language:C	signature:(client *c)
freeClientReplyValue	networking.c	/^void freeClientReplyValue(void *o) {$/;"	f	language:C	signature:(void *o)
freeClientsInAsyncFreeQueue	networking.c	/^void freeClientsInAsyncFreeQueue(void) {$/;"	f	language:C	signature:(void)
freeClientsInAsyncFreeQueue	server.h	/^void freeClientsInAsyncFreeQueue(void);$/;"	p	language:C	signature:(void)
freeClusterLink	cluster.c	/^void freeClusterLink(clusterLink *link) {$/;"	f	language:C	signature:(clusterLink *link)
freeClusterNode	cluster.c	/^void freeClusterNode(clusterNode *n) {$/;"	f	language:C	signature:(clusterNode *n)
freeFakeClient	aof.c	/^void freeFakeClient(struct client *c) {$/;"	f	language:C	signature:(struct client *c)
freeFakeClientArgv	aof.c	/^void freeFakeClientArgv(struct client *c) {$/;"	f	language:C	signature:(struct client *c)
freeHashObject	object.c	/^void freeHashObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
freeHashObject	server.h	/^void freeHashObject(robj *o);$/;"	p	language:C	signature:(robj *o)
freeHintsCallback	redis-cli.c	/^static void freeHintsCallback(void *ptr) {$/;"	f	language:C	file:	signature:(void *ptr)
freeListObject	object.c	/^void freeListObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
freeListObject	server.h	/^void freeListObject(robj *o);$/;"	p	language:C	signature:(robj *o)
freeMemoryIfNeeded	evict.c	/^int freeMemoryIfNeeded(void) {$/;"	f	language:C	signature:(void)
freeMemoryIfNeeded	server.h	/^int freeMemoryIfNeeded(void);$/;"	p	language:C	signature:(void)
freeModuleObject	object.c	/^void freeModuleObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
freePubsubPattern	pubsub.c	/^void freePubsubPattern(void *p) {$/;"	f	language:C	signature:(void *p)
freePubsubPattern	server.h	/^void freePubsubPattern(void *p);$/;"	p	language:C	signature:(void *p)
freeReplicationBacklog	replication.c	/^void freeReplicationBacklog(void) {$/;"	f	language:C	signature:(void)
freeSetObject	object.c	/^void freeSetObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
freeSetObject	server.h	/^void freeSetObject(robj *o);$/;"	p	language:C	signature:(robj *o)
freeSparklineSequence	sparkline.c	/^void freeSparklineSequence(struct sequence *seq) {$/;"	f	language:C	signature:(struct sequence *seq)
freeSparklineSequence	sparkline.h	/^void freeSparklineSequence(struct sequence *seq);$/;"	p	language:C	signature:(struct sequence *seq)
freeStringObject	object.c	/^void freeStringObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
freeStringObject	server.h	/^void freeStringObject(robj *o);$/;"	p	language:C	signature:(robj *o)
freeZsetObject	object.c	/^void freeZsetObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
freeZsetObject	server.h	/^void freeZsetObject(robj *o);$/;"	p	language:C	signature:(robj *o)
free_effort	lazyfree.c	/^        size_t free_effort = lazyfreeGetFreeEffort(val);$/;"	l	language:C
freelen	zipmap.c	/^    unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen);$/;"	l	language:C
freelen	zipmap.c	/^    unsigned int zmlen, freelen;$/;"	l	language:C
freshnodes	cluster.c	/^    int freshnodes = dictSize(server.cluster->nodes)-2;$/;"	l	language:C
fromport	sentinel.c	/^    char fromport[32], toport[32];$/;"	l	language:C
fstr	rdb.c	/^                    unsigned char *fstr, *vstr;$/;"	l	language:C
fsync	cluster.c	/^        int fsync = server.cluster->todo_before_sleep &$/;"	l	language:C
ftello	aof.c	/^            loadingProgress(ftello(fp));$/;"	p	language:C	file:
full	quicklist.c	/^    int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;$/;"	l	language:C
full	redis-cli.c	/^    sds full;$/;"	m	language:C	struct:__anon24	file:	access:public
full_next	quicklist.c	/^    int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;$/;"	l	language:C
full_prev	quicklist.c	/^    int full = 0, at_tail = 0, at_head = 0, full_next = 0, full_prev = 0;$/;"	l	language:C
fullmask	ae_evport.c	/^    int fullmask, pfd;$/;"	l	language:C
func	module.c	/^    RedisModuleCmdFunc func;$/;"	m	language:C	struct:RedisModuleCommandProxy	file:	access:public
funcdef	scripting.c	/^    sds funcdef = sdsempty();$/;"	l	language:C
funcname	scripting.c	/^        char funcname[43];$/;"	l	language:C
funcname	scripting.c	/^    char funcname[43];$/;"	l	language:C
g	cluster.c	/^    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;$/;"	l	language:C
ga	geo.c	/^    geoArray *ga = geoArrayCreate();$/;"	l	language:C
ga	geo.c	/^    geoArray *ga = zmalloc(sizeof(*ga));$/;"	l	language:C
gb	config.c	/^    int gb = 1024*1024*1024;$/;"	l	language:C
gc_count	scripting.c	/^        static long gc_count = 0;$/;"	l	language:C	file:
genClientPeerId	networking.c	/^void genClientPeerId(client *client, char *peerid,$/;"	f	language:C	signature:(client *client, char *peerid, size_t peerid_len)
genRedisInfoString	server.c	/^sds genRedisInfoString(char *section) {$/;"	f	language:C	signature:(char *section)
genRedisInfoString	server.h	/^sds genRedisInfoString(char *section);$/;"	p	language:C	signature:(char *section)
genericHgetallCommand	t_hash.c	/^void genericHgetallCommand(client *c, int flags) {$/;"	f	language:C	signature:(client *c, int flags)
genericZrangebylexCommand	t_zset.c	/^void genericZrangebylexCommand(client *c, int reverse) {$/;"	f	language:C	signature:(client *c, int reverse)
genericZrangebyscoreCommand	t_zset.c	/^void genericZrangebyscoreCommand(client *c, int reverse) {$/;"	f	language:C	signature:(client *c, int reverse)
genstr	quicklist.c	/^static char *genstr(char *prefix, int i) {$/;"	f	language:C	file:	signature:(char *prefix, int i)
geoAppendIfWithinRadius	geo.c	/^int geoAppendIfWithinRadius(geoArray *ga, double lon, double lat, double radius, double score, sds member) {$/;"	f	language:C	signature:(geoArray *ga, double lon, double lat, double radius, double score, sds member)
geoArray	geo.h	/^typedef struct geoArray {$/;"	s	language:C
geoArray	geo.h	/^} geoArray;$/;"	t	language:C	typeref:struct:geoArray
geoArray::array	geo.h	/^    struct geoPoint *array;$/;"	m	language:C	struct:geoArray	typeref:struct:geoArray::geoPoint	access:public
geoArray::buckets	geo.h	/^    size_t buckets;$/;"	m	language:C	struct:geoArray	access:public
geoArray::used	geo.h	/^    size_t used;$/;"	m	language:C	struct:geoArray	access:public
geoArrayAppend	geo.c	/^geoPoint *geoArrayAppend(geoArray *ga) {$/;"	f	language:C	signature:(geoArray *ga)
geoArrayCreate	geo.c	/^geoArray *geoArrayCreate(void) {$/;"	f	language:C	signature:(void)
geoArrayFree	geo.c	/^void geoArrayFree(geoArray *ga) {$/;"	f	language:C	signature:(geoArray *ga)
geoGetPointsInRange	geo.c	/^int geoGetPointsInRange(robj *zobj, double min, double max, double lon, double lat, double radius, geoArray *ga) {$/;"	f	language:C	signature:(robj *zobj, double min, double max, double lon, double lat, double radius, geoArray *ga)
geoPoint	geo.h	/^typedef struct geoPoint {$/;"	s	language:C
geoPoint	geo.h	/^} geoPoint;$/;"	t	language:C	typeref:struct:geoPoint
geoPoint::dist	geo.h	/^    double dist;$/;"	m	language:C	struct:geoPoint	access:public
geoPoint::latitude	geo.h	/^    double latitude;$/;"	m	language:C	struct:geoPoint	access:public
geoPoint::longitude	geo.h	/^    double longitude;$/;"	m	language:C	struct:geoPoint	access:public
geoPoint::member	geo.h	/^    char *member;$/;"	m	language:C	struct:geoPoint	access:public
geoPoint::score	geo.h	/^    double score;$/;"	m	language:C	struct:geoPoint	access:public
geoaddCommand	geo.c	/^void geoaddCommand(client *c) {$/;"	f	language:C	signature:(client *c)
geoaddCommand	server.h	/^void geoaddCommand(client *c);$/;"	p	language:C	signature:(client *c)
geoalphabet	geo.c	/^    char *geoalphabet= "0123456789bcdefghjkmnpqrstuvwxyz";$/;"	l	language:C
geodecodeCommand	server.h	/^void geodecodeCommand(client *c);$/;"	p	language:C	signature:(client *c)
geodistCommand	geo.c	/^void geodistCommand(client *c) {$/;"	f	language:C	signature:(client *c)
geodistCommand	server.h	/^void geodistCommand(client *c);$/;"	p	language:C	signature:(client *c)
geoencodeCommand	server.h	/^void geoencodeCommand(client *c);$/;"	p	language:C	signature:(client *c)
geohashAlign52Bits	geohash_helper.c	/^GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {$/;"	f	language:C	signature:(const GeoHashBits hash)
geohashAlign52Bits	geohash_helper.h	/^GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash);$/;"	p	language:C	signature:(const GeoHashBits hash)
geohashBoundingBox	geohash_helper.c	/^int geohashBoundingBox(double longitude, double latitude, double radius_meters,$/;"	f	language:C	signature:(double longitude, double latitude, double radius_meters, double *bounds)
geohashBoundingBox	geohash_helper.h	/^int geohashBoundingBox(double longitude, double latitude, double radius_meters,$/;"	p	language:C	signature:(double longitude, double latitude, double radius_meters, double *bounds)
geohashCommand	geo.c	/^void geohashCommand(client *c) {$/;"	f	language:C	signature:(client *c)
geohashCommand	server.h	/^void geohashCommand(client *c);$/;"	p	language:C	signature:(client *c)
geohashDecode	geohash.c	/^int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,$/;"	f	language:C	signature:(const GeoHashRange long_range, const GeoHashRange lat_range, const GeoHashBits hash, GeoHashArea *area)
geohashDecode	geohash.h	/^int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,$/;"	p	language:C	signature:(const GeoHashRange long_range, const GeoHashRange lat_range, const GeoHashBits hash, GeoHashArea *area)
geohashDecodeAreaToLongLat	geohash.c	/^int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {$/;"	f	language:C	signature:(const GeoHashArea *area, double *xy)
geohashDecodeAreaToLongLat	geohash.h	/^int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy);$/;"	p	language:C	signature:(const GeoHashArea *area, double *xy)
geohashDecodeToLongLatMercator	geohash.h	/^int geohashDecodeToLongLatMercator(const GeoHashBits hash, double *xy);$/;"	p	language:C	signature:(const GeoHashBits hash, double *xy)
geohashDecodeToLongLatType	geohash.c	/^int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {$/;"	f	language:C	signature:(const GeoHashBits hash, double *xy)
geohashDecodeToLongLatType	geohash.h	/^int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy);$/;"	p	language:C	signature:(const GeoHashBits hash, double *xy)
geohashDecodeToLongLatWGS84	geohash.c	/^int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {$/;"	f	language:C	signature:(const GeoHashBits hash, double *xy)
geohashDecodeToLongLatWGS84	geohash.h	/^int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy);$/;"	p	language:C	signature:(const GeoHashBits hash, double *xy)
geohashDecodeType	geohash.c	/^int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {$/;"	f	language:C	signature:(const GeoHashBits hash, GeoHashArea *area)
geohashDecodeType	geohash.h	/^int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area);$/;"	p	language:C	signature:(const GeoHashBits hash, GeoHashArea *area)
geohashDecodeWGS84	geohash.c	/^int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {$/;"	f	language:C	signature:(const GeoHashBits hash, GeoHashArea *area)
geohashDecodeWGS84	geohash.h	/^int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area);$/;"	p	language:C	signature:(const GeoHashBits hash, GeoHashArea *area)
geohashEncode	geohash.c	/^int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,$/;"	f	language:C	signature:(const GeoHashRange *long_range, const GeoHashRange *lat_range, double longitude, double latitude, uint8_t step, GeoHashBits *hash)
geohashEncode	geohash.h	/^int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,$/;"	p	language:C	signature:(const GeoHashRange *long_range, const GeoHashRange *lat_range, double longitude, double latitude, uint8_t step, GeoHashBits *hash)
geohashEncodeType	geohash.c	/^int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {$/;"	f	language:C	signature:(double longitude, double latitude, uint8_t step, GeoHashBits *hash)
geohashEncodeType	geohash.h	/^int geohashEncodeType(double longitude, double latitude,$/;"	p	language:C	signature:(double longitude, double latitude, uint8_t step, GeoHashBits *hash)
geohashEncodeWGS84	geohash.c	/^int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,$/;"	f	language:C	signature:(double longitude, double latitude, uint8_t step, GeoHashBits *hash)
geohashEncodeWGS84	geohash.h	/^int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,$/;"	p	language:C	signature:(double longitude, double latitude, uint8_t step, GeoHashBits *hash)
geohashEstimateStepsByRadius	geohash_helper.c	/^uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {$/;"	f	language:C	signature:(double range_meters, double lat)
geohashEstimateStepsByRadius	geohash_helper.h	/^uint8_t geohashEstimateStepsByRadius(double range_meters, double lat);$/;"	p	language:C	signature:(double range_meters, double lat)
geohashGetAreasByRadius	geohash_helper.c	/^GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double radius_meters) {$/;"	f	language:C	signature:(double longitude, double latitude, double radius_meters)
geohashGetAreasByRadius	geohash_helper.h	/^GeoHashRadius geohashGetAreasByRadius(double longitude,$/;"	p	language:C	signature:(double longitude, double latitude, double radius_meters)
geohashGetAreasByRadiusMercator	geohash_helper.h	/^GeoHashRadius geohashGetAreasByRadiusMercator(double longitude, double latitude,$/;"	p	language:C	signature:(double longitude, double latitude, double radius_meters)
geohashGetAreasByRadiusWGS84	geohash_helper.c	/^GeoHashRadius geohashGetAreasByRadiusWGS84(double longitude, double latitude,$/;"	f	language:C	signature:(double longitude, double latitude, double radius_meters)
geohashGetAreasByRadiusWGS84	geohash_helper.h	/^GeoHashRadius geohashGetAreasByRadiusWGS84(double longitude, double latitude,$/;"	p	language:C	signature:(double longitude, double latitude, double radius_meters)
geohashGetCoordRange	geohash.c	/^void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {$/;"	f	language:C	signature:(GeoHashRange *long_range, GeoHashRange *lat_range)
geohashGetCoordRange	geohash.h	/^void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range);$/;"	p	language:C	signature:(GeoHashRange *long_range, GeoHashRange *lat_range)
geohashGetDistance	geohash_helper.c	/^double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {$/;"	f	language:C	signature:(double lon1d, double lat1d, double lon2d, double lat2d)
geohashGetDistance	geohash_helper.h	/^double geohashGetDistance(double lon1d, double lat1d,$/;"	p	language:C	signature:(double lon1d, double lat1d, double lon2d, double lat2d)
geohashGetDistanceIfInRadius	geohash_helper.c	/^int geohashGetDistanceIfInRadius(double x1, double y1,$/;"	f	language:C	signature:(double x1, double y1, double x2, double y2, double radius, double *distance)
geohashGetDistanceIfInRadius	geohash_helper.h	/^int geohashGetDistanceIfInRadius(double x1, double y1,$/;"	p	language:C	signature:(double x1, double y1, double x2, double y2, double radius, double *distance)
geohashGetDistanceIfInRadiusWGS84	geohash_helper.c	/^int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,$/;"	f	language:C	signature:(double x1, double y1, double x2, double y2, double radius, double *distance)
geohashGetDistanceIfInRadiusWGS84	geohash_helper.h	/^int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,$/;"	p	language:C	signature:(double x1, double y1, double x2, double y2, double radius, double *distance)
geohashNeighbors	geohash.c	/^void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {$/;"	f	language:C	signature:(const GeoHashBits *hash, GeoHashNeighbors *neighbors)
geohashNeighbors	geohash.h	/^void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors);$/;"	p	language:C	signature:(const GeoHashBits *hash, GeoHashNeighbors *neighbors)
geohash_move_x	geohash.c	/^static void geohash_move_x(GeoHashBits *hash, int8_t d) {$/;"	f	language:C	file:	signature:(GeoHashBits *hash, int8_t d)
geohash_move_y	geohash.c	/^static void geohash_move_y(GeoHashBits *hash, int8_t d) {$/;"	f	language:C	file:	signature:(GeoHashBits *hash, int8_t d)
geoposCommand	geo.c	/^void geoposCommand(client *c) {$/;"	f	language:C	signature:(client *c)
geoposCommand	server.h	/^void geoposCommand(client *c);$/;"	p	language:C	signature:(client *c)
georadius	geo.c	/^    GeoHashRadius georadius =$/;"	l	language:C
georadiusByMemberCommand	geo.c	/^void georadiusByMemberCommand(client *c) {$/;"	f	language:C	signature:(client *c)
georadiusByMemberCommand	server.h	/^void georadiusByMemberCommand(client *c);$/;"	p	language:C	signature:(client *c)
georadiusCommand	geo.c	/^void georadiusCommand(client *c) {$/;"	f	language:C	signature:(client *c)
georadiusCommand	server.h	/^void georadiusCommand(client *c);$/;"	p	language:C	signature:(client *c)
georadiusGeneric	geo.c	/^void georadiusGeneric(client *c, int type) {$/;"	f	language:C	signature:(client *c, int type)
getAbsolutePath	util.c	/^sds getAbsolutePath(char *filename) {$/;"	f	language:C	signature:(char *filename)
getAbsolutePath	util.h	/^sds getAbsolutePath(char *filename);$/;"	p	language:C	signature:(char *filename)
getAllClientsInfoString	networking.c	/^sds getAllClientsInfoString(void) {$/;"	f	language:C	signature:(void)
getAllClientsInfoString	server.h	/^sds getAllClientsInfoString(void);$/;"	p	language:C	signature:(void)
getBitOffsetFromArgument	bitops.c	/^int getBitOffsetFromArgument(client *c, robj *o, size_t *offset, int hash, int bits) {$/;"	f	language:C	signature:(client *c, robj *o, size_t *offset, int hash, int bits)
getBitfieldTypeFromArgument	bitops.c	/^int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {$/;"	f	language:C	signature:(client *c, robj *o, int *sign, int *bits)
getClientOutputBufferMemoryUsage	networking.c	/^unsigned long getClientOutputBufferMemoryUsage(client *c) {$/;"	f	language:C	signature:(client *c)
getClientOutputBufferMemoryUsage	server.h	/^unsigned long getClientOutputBufferMemoryUsage(client *c);$/;"	p	language:C	signature:(client *c)
getClientPeerId	networking.c	/^char *getClientPeerId(client *c) {$/;"	f	language:C	signature:(client *c)
getClientPeerId	server.h	/^char *getClientPeerId(client *client);$/;"	p	language:C	signature:(client *client)
getClientType	networking.c	/^int getClientType(client *c) {$/;"	f	language:C	signature:(client *c)
getClientType	server.h	/^int getClientType(client *c);$/;"	p	language:C	signature:(client *c)
getClientTypeByName	networking.c	/^int getClientTypeByName(char *name) {$/;"	f	language:C	signature:(char *name)
getClientTypeByName	server.h	/^int getClientTypeByName(char *name);$/;"	p	language:C	signature:(char *name)
getClientTypeName	networking.c	/^char *getClientTypeName(int class) {$/;"	f	language:C	signature:(int class)
getClientTypeName	server.h	/^char *getClientTypeName(int class);$/;"	p	language:C	signature:(int class)
getClientsMaxBuffers	networking.c	/^void getClientsMaxBuffers(unsigned long *longest_output_list,$/;"	f	language:C	signature:(unsigned long *longest_output_list, unsigned long *biggest_input_buffer)
getClientsMaxBuffers	server.h	/^void getClientsMaxBuffers(unsigned long *longest_output_list,$/;"	p	language:C	signature:(unsigned long *longest_output_list, unsigned long *biggest_input_buffer)
getCommand	server.h	/^void getCommand(client *c);$/;"	p	language:C	signature:(client *c)
getCommand	t_string.c	/^void getCommand(client *c) {$/;"	f	language:C	signature:(client *c)
getDbSize	redis-cli.c	/^static int getDbSize(void) {$/;"	f	language:C	file:	signature:(void)
getDecodedObject	object.c	/^robj *getDecodedObject(robj *o) {$/;"	f	language:C	signature:(robj *o)
getDecodedObject	server.h	/^robj *getDecodedObject(robj *o);$/;"	p	language:C	signature:(robj *o)
getDotfilePath	redis-cli.c	/^static sds getDotfilePath(char *envoverride, char *dotfilename) {$/;"	f	language:C	file:	signature:(char *envoverride, char *dotfilename)
getDoubleFromObject	object.c	/^int getDoubleFromObject(const robj *o, double *target) {$/;"	f	language:C	signature:(const robj *o, double *target)
getDoubleFromObject	server.h	/^int getDoubleFromObject(const robj *o, double *target);$/;"	p	language:C	signature:(const robj *o, double *target)
getDoubleFromObjectOrReply	object.c	/^int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {$/;"	f	language:C	signature:(client *c, robj *o, double *target, const char *msg)
getDoubleFromObjectOrReply	server.h	/^int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg);$/;"	p	language:C	signature:(client *c, robj *o, double *target, const char *msg)
getExpire	db.c	/^long long getExpire(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
getExpire	server.h	/^long long getExpire(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
getFlushCommandFlags	db.c	/^int getFlushCommandFlags(client *c, int *flags) {$/;"	f	language:C	signature:(client *c, int *flags)
getGenericCommand	t_string.c	/^int getGenericCommand(client *c) {$/;"	f	language:C	signature:(client *c)
getInfoField	redis-cli.c	/^static char *getInfoField(char *info, char *field) {$/;"	f	language:C	file:	signature:(char *info, char *field)
getInstantaneousMetric	server.c	/^long long getInstantaneousMetric(int metric) {$/;"	f	language:C	signature:(int metric)
getKeySizes	redis-cli.c	/^static void getKeySizes(redisReply *keys, int *types,$/;"	f	language:C	file:	signature:(redisReply *keys, int *types, unsigned long long *sizes)
getKeyTypes	redis-cli.c	/^static void getKeyTypes(redisReply *keys, int *types) {$/;"	f	language:C	file:	signature:(redisReply *keys, int *types)
getKeysFreeResult	db.c	/^void getKeysFreeResult(int *result) {$/;"	f	language:C	signature:(int *result)
getKeysFreeResult	server.h	/^void getKeysFreeResult(int *result);$/;"	p	language:C	signature:(int *result)
getKeysFromCommand	db.c	/^int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
getKeysFromCommand	server.h	/^int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
getKeysInSlot	db.c	/^unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count) {$/;"	f	language:C	signature:(unsigned int hashslot, robj **keys, unsigned int count)
getKeysInSlot	server.h	/^unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);$/;"	p	language:C	signature:(unsigned int hashslot, robj **keys, unsigned int count)
getKeysUsingCommandTable	db.c	/^int *getKeysUsingCommandTable(struct redisCommand *cmd,robj **argv, int argc, int *numkeys) {$/;"	f	language:C	signature:(struct redisCommand *cmd,robj **argv, int argc, int *numkeys)
getLRUClock	evict.c	/^unsigned int getLRUClock(void) {$/;"	f	language:C	signature:(void)
getLRUClock	server.h	/^unsigned int getLRUClock(void);$/;"	p	language:C	signature:(void)
getLongDoubleFromObject	object.c	/^int getLongDoubleFromObject(robj *o, long double *target) {$/;"	f	language:C	signature:(robj *o, long double *target)
getLongDoubleFromObject	server.h	/^int getLongDoubleFromObject(robj *o, long double *target);$/;"	p	language:C	signature:(robj *o, long double *target)
getLongDoubleFromObjectOrReply	object.c	/^int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {$/;"	f	language:C	signature:(client *c, robj *o, long double *target, const char *msg)
getLongDoubleFromObjectOrReply	server.h	/^int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg);$/;"	p	language:C	signature:(client *c, robj *o, long double *target, const char *msg)
getLongFromObjectOrReply	object.c	/^int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {$/;"	f	language:C	signature:(client *c, robj *o, long *target, const char *msg)
getLongFromObjectOrReply	server.h	/^int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg);$/;"	p	language:C	signature:(client *c, robj *o, long *target, const char *msg)
getLongInfoField	redis-cli.c	/^static long getLongInfoField(char *info, char *field) {$/;"	f	language:C	file:	signature:(char *info, char *field)
getLongLongFromObject	object.c	/^int getLongLongFromObject(robj *o, long long *target) {$/;"	f	language:C	signature:(robj *o, long long *target)
getLongLongFromObject	server.h	/^int getLongLongFromObject(robj *o, long long *target);$/;"	p	language:C	signature:(robj *o, long long *target)
getLongLongFromObjectOrReply	object.c	/^int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {$/;"	f	language:C	signature:(client *c, robj *o, long long *target, const char *msg)
getLongLongFromObjectOrReply	server.h	/^int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg);$/;"	p	language:C	signature:(client *c, robj *o, long long *target, const char *msg)
getMcontextEip	debug.c	/^static void *getMcontextEip(ucontext_t *uc) {$/;"	f	language:C	file:	signature:(ucontext_t *uc)
getNodeByQuery	cluster.c	/^clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {$/;"	f	language:C	signature:(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code)
getNodeByQuery	cluster.h	/^clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *ask);$/;"	p	language:C	signature:(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *ask)
getObjectReadOnlyString	bitops.c	/^unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {$/;"	f	language:C	signature:(robj *o, long *len, char *llbuf)
getPsyncInitialOffset	replication.c	/^long long getPsyncInitialOffset(void) {$/;"	f	language:C	signature:(void)
getPsyncInitialOffset	server.h	/^long long getPsyncInitialOffset(void);$/;"	p	language:C	signature:(void)
getRDB	redis-cli.c	/^static void getRDB(void) {$/;"	f	language:C	file:	signature:(void)
getRandomHexChars	server.h	/^void getRandomHexChars(char *p, unsigned int len);$/;"	p	language:C	signature:(char *p, unsigned int len)
getRandomHexChars	util.c	/^void getRandomHexChars(char *p, unsigned int len) {$/;"	f	language:C	signature:(char *p, unsigned int len)
getSentinelRedisInstanceByAddrAndRunID	sentinel.c	/^sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid) {$/;"	f	language:C	signature:(dict *instances, char *ip, int port, char *runid)
getSentinelRedisInstanceByAddrAndRunID	sentinel.c	/^sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid);$/;"	p	language:C	file:	signature:(dict *instances, char *ip, int port, char *runid)
getSignedBitfield	bitops.c	/^int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {$/;"	f	language:C	signature:(unsigned char *p, uint64_t offset, uint64_t bits)
getSlotOrReply	cluster.c	/^int getSlotOrReply(client *c, robj *o) {$/;"	f	language:C	signature:(client *c, robj *o)
getStringObjectSdsUsedMemory	networking.c	/^size_t getStringObjectSdsUsedMemory(robj *o) {$/;"	f	language:C	signature:(robj *o)
getTimeoutFromObjectOrReply	blocked.c	/^int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit) {$/;"	f	language:C	signature:(client *c, robj *object, mstime_t *timeout, int unit)
getTimeoutFromObjectOrReply	server.h	/^int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit);$/;"	p	language:C	signature:(client *c, robj *object, mstime_t *timeout, int unit)
getUnsignedBitfield	bitops.c	/^uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {$/;"	f	language:C	signature:(unsigned char *p, uint64_t offset, uint64_t bits)
get_ack_from_slaves	server.h	/^    int get_ack_from_slaves;            \/* If true we send REPLCONF GETACK. *\/$/;"	m	language:C	struct:redisServer	access:public
getapifuncptr	module.c	/^    void *getapifuncptr;            \/* NOTE: Must be the first field. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
getapifuncptr	redismodule.h	/^    void *getapifuncptr = ((void**)ctx)[0];$/;"	l	language:C
getbitCommand	bitops.c	/^void getbitCommand(client *c) {$/;"	f	language:C	signature:(client *c)
getbitCommand	server.h	/^void getbitCommand(client *c);$/;"	p	language:C	signature:(client *c)
getkeys_proc	server.h	/^    redisGetKeysProc *getkeys_proc;$/;"	m	language:C	struct:redisCommand	access:public
getop	sort.c	/^    int getop = 0; \/* GET operation counter *\/$/;"	l	language:C
getpid	debug.c	/^    kill(getpid(),sig);$/;"	p	language:C	file:
getpid	server.c	/^        rdbRemoveTempFile(getpid());$/;"	p	language:C	file:
getrangeCommand	server.h	/^void getrangeCommand(client *c);$/;"	p	language:C	signature:(client *c)
getrangeCommand	t_string.c	/^void getrangeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
getrdb_mode	redis-cli.c	/^    int getrdb_mode;$/;"	m	language:C	struct:config	file:	access:public
getsetCommand	server.h	/^void getsetCommand(client *c);$/;"	p	language:C	signature:(client *c)
getsetCommand	t_string.c	/^void getsetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
gone	quicklist.c	/^    int gone = 0;$/;"	l	language:C
good	replication.c	/^    int good = 0;$/;"	l	language:C
gossip	cluster.c	/^        clusterMsgDataGossip *gossip;$/;"	l	language:C
gossip	cluster.h	/^        clusterMsgDataGossip gossip[1];$/;"	m	language:C	struct:clusterMsgData::__anon6	access:public
gossipcount	cluster.c	/^    int gossipcount = 0; \/* Number of gossip sections added so far. *\/$/;"	l	language:C
got_comma	redis-cli.c	/^    int j, got_comma, keys;$/;"	l	language:C
gp	geo.c	/^            geoPoint *gp = ga->array+i;$/;"	l	language:C
gp	geo.c	/^    geoPoint *gp = ga->array+ga->used;$/;"	l	language:C
gp	geo.c	/^    geoPoint *gp = geoArrayAppend(ga);$/;"	l	language:C
gpa	geo.c	/^    const struct geoPoint *gpa = a, *gpb = b;$/;"	l	language:C
gpb	geo.c	/^    const struct geoPoint *gpa = a, *gpb = b;$/;"	l	language:C
graph	latency.c	/^        sds graph;$/;"	l	language:C
graph	latency.c	/^    sds graph = sdsempty();$/;"	l	language:C
group	help.h	/^  int group;$/;"	m	language:C	struct:commandHelp	access:public
group	redis-cli.c	/^    int group = -1;$/;"	l	language:C
groupslen	redis-cli.c	/^    int groupslen = sizeof(commandGroups)\/sizeof(char*);$/;"	l	language:C
growth	server.c	/^            long long growth = (server.aof_current_size*100\/base) - 100;$/;"	l	language:C
h	dict.c	/^            unsigned int h;$/;"	l	language:C
h	dict.c	/^    uint32_t h = seed ^ len;$/;"	l	language:C
h	dict.c	/^    unsigned int h, idx, table;$/;"	l	language:C
h	dict.c	/^    unsigned int h, idx;$/;"	l	language:C
h	dict.c	/^    unsigned int h;$/;"	l	language:C
h	hyperloglog.c	/^    uint64_t h = seed ^ (len * m);$/;"	l	language:C
h	quicklist.c	/^                char *h = genstr("hello", i);$/;"	l	language:C
handle	module.c	/^    void *handle;   \/* Module dlopen() handle. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
handle	module.c	/^    void *handle;$/;"	l	language:C
handle	modules/TYPES.md	/^for writing, and gets three arguments: the key handle, the reference to the$/;"	v	language:C
handleClientsBlockedOnLists	server.h	/^void handleClientsBlockedOnLists(void);$/;"	p	language:C	signature:(void)
handleClientsBlockedOnLists	t_list.c	/^void handleClientsBlockedOnLists(void) {$/;"	f	language:C	signature:(void)
handleClientsWithPendingWrites	networking.c	/^int handleClientsWithPendingWrites(void) {$/;"	f	language:C	signature:(void)
handleClientsWithPendingWrites	server.h	/^int handleClientsWithPendingWrites(void);$/;"	p	language:C	signature:(void)
handleLinkIOError	cluster.c	/^void handleLinkIOError(clusterLink *link) {$/;"	f	language:C	signature:(clusterLink *link)
handshake_timeout	cluster.c	/^    mstime_t handshake_timeout;$/;"	l	language:C
hard	cluster.c	/^        int hard = 0;$/;"	l	language:C
hard	config.c	/^            unsigned long long hard, soft;$/;"	l	language:C
hard	config.c	/^        char hard[64], soft[64];$/;"	l	language:C
hard	networking.c	/^    int soft = 0, hard = 0, class;$/;"	l	language:C
hard_limit_bytes	server.h	/^    unsigned long long hard_limit_bytes;$/;"	m	language:C	struct:clientBufferLimitsConfig	access:public
has_tail	config.c	/^    int has_tail;         \/* True if we already added directives that were$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
hash	debug.c	/^    unsigned char hash[20], *s = ptr;$/;"	l	language:C
hash	dict.c	/^    long long integers[6], hash = 0;$/;"	l	language:C
hash	dict.c	/^    unsigned int hash = (unsigned int)dict_hash_function_seed;$/;"	l	language:C
hash	geo.c	/^            GeoHashBits hash;$/;"	l	language:C
hash	geo.c	/^        GeoHashBits hash;$/;"	l	language:C
hash	geo.c	/^    GeoHashBits hash = { .bits = (uint64_t)bits, .step = GEO_STEP_MAX };$/;"	l	language:C
hash	geohash.h	/^    GeoHashBits hash;$/;"	m	language:C	struct:__anon16	access:public
hash	geohash_helper.c	/^    GeoHashBits hash;$/;"	l	language:C
hash	geohash_helper.h	/^    GeoHashBits hash;$/;"	m	language:C	struct:__anon18	access:public
hash	hyperloglog.c	/^    uint64_t hash, bit, index;$/;"	l	language:C
hash	scripting.c	/^    unsigned char hash[20];$/;"	l	language:C
hash	server.c	/^            unsigned int hash;$/;"	l	language:C
hash	sha1.c	/^    unsigned char hash[20], buf[BUFSIZE];$/;"	l	language:C
hashDictType	server.c	/^dictType hashDictType = {$/;"	v	language:C
hashDictType	server.h	/^extern dictType hashDictType;$/;"	x	language:C
hashFunction	dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	language:C	struct:dictType	access:public
hashTypeConvert	server.h	/^void hashTypeConvert(robj *o, int enc);$/;"	p	language:C	signature:(robj *o, int enc)
hashTypeConvert	t_hash.c	/^void hashTypeConvert(robj *o, int enc) {$/;"	f	language:C	signature:(robj *o, int enc)
hashTypeConvertZiplist	t_hash.c	/^void hashTypeConvertZiplist(robj *o, int enc) {$/;"	f	language:C	signature:(robj *o, int enc)
hashTypeCurrentFromHashTable	server.h	/^sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what);$/;"	p	language:C	signature:(hashTypeIterator *hi, int what)
hashTypeCurrentFromHashTable	t_hash.c	/^sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {$/;"	f	language:C	signature:(hashTypeIterator *hi, int what)
hashTypeCurrentFromZiplist	server.h	/^void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,$/;"	p	language:C	signature:(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeCurrentFromZiplist	t_hash.c	/^void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,$/;"	f	language:C	signature:(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeCurrentObject	server.h	/^void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll);$/;"	p	language:C	signature:(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeCurrentObject	t_hash.c	/^void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {$/;"	f	language:C	signature:(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeCurrentObjectNewSds	server.h	/^sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what);$/;"	p	language:C	signature:(hashTypeIterator *hi, int what)
hashTypeCurrentObjectNewSds	t_hash.c	/^sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {$/;"	f	language:C	signature:(hashTypeIterator *hi, int what)
hashTypeDelete	server.h	/^int hashTypeDelete(robj *o, sds key);$/;"	p	language:C	signature:(robj *o, sds key)
hashTypeDelete	t_hash.c	/^int hashTypeDelete(robj *o, sds field) {$/;"	f	language:C	signature:(robj *o, sds field)
hashTypeExists	server.h	/^int hashTypeExists(robj *o, sds key);$/;"	p	language:C	signature:(robj *o, sds key)
hashTypeExists	t_hash.c	/^int hashTypeExists(robj *o, sds field) {$/;"	f	language:C	signature:(robj *o, sds field)
hashTypeGetFromHashTable	t_hash.c	/^sds hashTypeGetFromHashTable(robj *o, sds field) {$/;"	f	language:C	signature:(robj *o, sds field)
hashTypeGetFromZiplist	t_hash.c	/^int hashTypeGetFromZiplist(robj *o, sds field,$/;"	f	language:C	signature:(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeGetValue	t_hash.c	/^int hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {$/;"	f	language:C	signature:(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeGetValueLength	t_hash.c	/^size_t hashTypeGetValueLength(robj *o, sds field) {$/;"	f	language:C	signature:(robj *o, sds field)
hashTypeGetValueObject	server.h	/^robj *hashTypeGetValueObject(robj *o, sds field);$/;"	p	language:C	signature:(robj *o, sds field)
hashTypeGetValueObject	t_hash.c	/^robj *hashTypeGetValueObject(robj *o, sds field) {$/;"	f	language:C	signature:(robj *o, sds field)
hashTypeInitIterator	server.h	/^hashTypeIterator *hashTypeInitIterator(robj *subject);$/;"	p	language:C	signature:(robj *subject)
hashTypeInitIterator	t_hash.c	/^hashTypeIterator *hashTypeInitIterator(robj *subject) {$/;"	f	language:C	signature:(robj *subject)
hashTypeIterator	server.h	/^} hashTypeIterator;$/;"	t	language:C	typeref:struct:__anon34
hashTypeLength	server.h	/^unsigned long hashTypeLength(const robj *o);$/;"	p	language:C	signature:(const robj *o)
hashTypeLength	t_hash.c	/^unsigned long hashTypeLength(const robj *o) {$/;"	f	language:C	signature:(const robj *o)
hashTypeLookupWriteOrCreate	server.h	/^robj *hashTypeLookupWriteOrCreate(client *c, robj *key);$/;"	p	language:C	signature:(client *c, robj *key)
hashTypeLookupWriteOrCreate	t_hash.c	/^robj *hashTypeLookupWriteOrCreate(client *c, robj *key) {$/;"	f	language:C	signature:(client *c, robj *key)
hashTypeNext	server.h	/^int hashTypeNext(hashTypeIterator *hi);$/;"	p	language:C	signature:(hashTypeIterator *hi)
hashTypeNext	t_hash.c	/^int hashTypeNext(hashTypeIterator *hi) {$/;"	f	language:C	signature:(hashTypeIterator *hi)
hashTypeReleaseIterator	server.h	/^void hashTypeReleaseIterator(hashTypeIterator *hi);$/;"	p	language:C	signature:(hashTypeIterator *hi)
hashTypeReleaseIterator	t_hash.c	/^void hashTypeReleaseIterator(hashTypeIterator *hi) {$/;"	f	language:C	signature:(hashTypeIterator *hi)
hashTypeSet	server.h	/^int hashTypeSet(robj *o, sds field, sds value, int flags);$/;"	p	language:C	signature:(robj *o, sds field, sds value, int flags)
hashTypeSet	t_hash.c	/^int hashTypeSet(robj *o, sds field, sds value, int flags) {$/;"	f	language:C	signature:(robj *o, sds field, sds value, int flags)
hashTypeTryConversion	server.h	/^void hashTypeTryConversion(robj *subject, robj **argv, int start, int end);$/;"	p	language:C	signature:(robj *subject, robj **argv, int start, int end)
hashTypeTryConversion	t_hash.c	/^void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {$/;"	f	language:C	signature:(robj *o, robj **argv, int start, int end)
hashTypeTryObjectEncoding	server.h	/^void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);$/;"	p	language:C	signature:(robj *subject, robj **o1, robj **o2)
hash_max_ziplist_entries	server.h	/^    size_t hash_max_ziplist_entries;$/;"	m	language:C	struct:redisServer	access:public
hash_max_ziplist_value	server.h	/^    size_t hash_max_ziplist_value;$/;"	m	language:C	struct:redisServer	access:public
hash_sep	geohash.c	/^    uint64_t hash_sep = deinterleave64(hash.bits); \/* hash = [LAT][LONG] *\/$/;"	l	language:C
hashedpass	modules/API.md	/^     RedisModuleString *username, *hashedpass;$/;"	v	language:C
hashslot	db.c	/^    unsigned int hashslot = keyHashSlot(key->ptr,sdslen(key->ptr));$/;"	l	language:C
hashslot	server.c	/^        int hashslot;$/;"	l	language:C
hdelCommand	server.h	/^void hdelCommand(client *c);$/;"	p	language:C	signature:(client *c)
hdelCommand	t_hash.c	/^void hdelCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hdr	cluster.c	/^    clusterMsg *hdr = (clusterMsg*) buf;$/;"	l	language:C
hdr	cluster.c	/^    clusterMsg *hdr = (clusterMsg*) link->rcvbuf;$/;"	l	language:C
hdr	cluster.c	/^    clusterMsg *hdr;$/;"	l	language:C
hdr	hyperloglog.c	/^    struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;$/;"	l	language:C
hdr	hyperloglog.c	/^    struct hllhdr *hdr = hll->ptr;$/;"	l	language:C
hdr	hyperloglog.c	/^    struct hllhdr *hdr = o->ptr;$/;"	l	language:C
hdr	hyperloglog.c	/^    struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;$/;"	l	language:C
hdr	hyperloglog.c	/^    struct hllhdr *hdr;$/;"	l	language:C
hdr	server.c	/^    struct msghdr hdr;$/;"	l	language:C
hdr2	hyperloglog.c	/^    struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;$/;"	l	language:C
hdrlen	sds.c	/^    int hdrlen = sdsHdrSize(type);$/;"	l	language:C
hdrlen	sds.c	/^    int hdrlen;$/;"	l	language:C
he	dict.c	/^            dictEntry *he = d->ht[j].table[i];$/;"	l	language:C
he	dict.c	/^        dictEntry *he, *nextHe;$/;"	l	language:C
he	dict.c	/^        dictEntry *he;$/;"	l	language:C
he	dict.c	/^    dictEntry *he, *orighe;$/;"	l	language:C
he	dict.c	/^    dictEntry *he, *prevHe;$/;"	l	language:C
he	dict.c	/^    dictEntry *he;$/;"	l	language:C
he	module.c	/^    dictEntry *he = dictFind(server.moduleapi, funcname);$/;"	l	language:C
he	redis-cli.c	/^            helpEntry *he = helpEntries+i;$/;"	l	language:C
head	adlist.h	/^    listNode *head;$/;"	m	language:C	struct:list	access:public
head	module.c	/^    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;$/;"	l	language:C
head	modules/hellotype.c	/^    struct HelloTypeNode *head;$/;"	m	language:C	struct:HelloTypeObject	typeref:struct:HelloTypeObject::HelloTypeNode	file:	access:public
head	quicklist.h	/^    quicklistNode *head;$/;"	m	language:C	struct:quicklist	access:public
head	server.c	/^        listNode *head;$/;"	l	language:C
header	server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	language:C	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode	access:public
headersize	ziplist.c	/^    unsigned int headersize;$/;"	m	language:C	struct:zlentry	file:	access:public
help	redis-cli.c	/^    struct commandHelp *help;$/;"	l	language:C
helpEntries	redis-cli.c	/^static helpEntry *helpEntries;$/;"	v	language:C	file:
helpEntriesLen	redis-cli.c	/^static int helpEntriesLen;$/;"	v	language:C	file:
helpEntry	redis-cli.c	/^} helpEntry;$/;"	t	language:C	typeref:struct:__anon24	file:
hex_digit_to_int	sds.c	/^int hex_digit_to_int(char c) {$/;"	f	language:C	signature:(char c)
hexistsCommand	server.h	/^void hexistsCommand(client *c);$/;"	p	language:C	signature:(client *c)
hexistsCommand	t_hash.c	/^void hexistsCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hgetCommand	server.h	/^void hgetCommand(client *c);$/;"	p	language:C	signature:(client *c)
hgetCommand	t_hash.c	/^void hgetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hgetallCommand	server.h	/^void hgetallCommand(client *c);$/;"	p	language:C	signature:(client *c)
hgetallCommand	t_hash.c	/^void hgetallCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hi	aof.c	/^    hashTypeIterator *hi;$/;"	l	language:C
hi	debug.c	/^                hashTypeIterator *hi = hashTypeInitIterator(o);$/;"	l	language:C
hi	t_hash.c	/^        hashTypeIterator *hi;$/;"	l	language:C
hi	t_hash.c	/^    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));$/;"	l	language:C
hi	t_hash.c	/^    hashTypeIterator *hi;$/;"	l	language:C
higest_write_offset	bitops.c	/^    long higest_write_offset = 0;$/;"	l	language:C
high_raw	quicklist.c	/^                    unsigned int high_raw = ql->len - ql->compress;$/;"	l	language:C
high_raw	quicklist.c	/^        unsigned int high_raw = ql->len - ql->compress;$/;"	l	language:C
hincrbyCommand	server.h	/^void hincrbyCommand(client *c);$/;"	p	language:C	signature:(client *c)
hincrbyCommand	t_hash.c	/^void hincrbyCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hincrbyfloatCommand	server.h	/^void hincrbyfloatCommand(client *c);$/;"	p	language:C	signature:(client *c)
hincrbyfloatCommand	t_hash.c	/^void hincrbyfloatCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hint	redis-cli.c	/^            sds hint = sdsnew(helpEntries[i].org->params);$/;"	l	language:C
hints	anet.c	/^    struct addrinfo hints, *info;$/;"	l	language:C
hints	anet.c	/^    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;$/;"	l	language:C
hints	anet.c	/^    struct addrinfo hints, *servinfo, *p;$/;"	l	language:C
hints	redis-cli.c	/^    int hints;$/;"	m	language:C	struct:pref	file:	access:public
hintsCallback	redis-cli.c	/^static char *hintsCallback(const char *buf, int *color, int *bold) {$/;"	f	language:C	file:	signature:(const char *buf, int *color, int *bold)
history	redis-cli.c	/^    int history = 0;$/;"	l	language:C
history_interval	redis-cli.c	/^    long long history_interval =$/;"	l	language:C
history_start	redis-cli.c	/^    long long history_start = mstime();$/;"	l	language:C
history_start	redis-cli.c	/^    long long history_start = ustime();$/;"	l	language:C
historyfile	redis-cli.c	/^    sds historyfile = NULL;$/;"	l	language:C
hits	redis-cli.c	/^        long long hits = 0, misses = 0;$/;"	l	language:C
hkeysCommand	server.h	/^void hkeysCommand(client *c);$/;"	p	language:C	signature:(client *c)
hkeysCommand	t_hash.c	/^void hkeysCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hlenCommand	server.h	/^void hlenCommand(client *c);$/;"	p	language:C	signature:(client *c)
hlenCommand	t_hash.c	/^void hlenCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hllAdd	hyperloglog.c	/^int hllAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f	language:C	signature:(robj *o, unsigned char *ele, size_t elesize)
hllCount	hyperloglog.c	/^uint64_t hllCount(struct hllhdr *hdr, int *invalid) {$/;"	f	language:C	signature:(struct hllhdr *hdr, int *invalid)
hllDenseAdd	hyperloglog.c	/^int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {$/;"	f	language:C	signature:(uint8_t *registers, unsigned char *ele, size_t elesize)
hllDenseSum	hyperloglog.c	/^double hllDenseSum(uint8_t *registers, double *PE, int *ezp) {$/;"	f	language:C	signature:(uint8_t *registers, double *PE, int *ezp)
hllMerge	hyperloglog.c	/^int hllMerge(uint8_t *max, robj *hll) {$/;"	f	language:C	signature:(uint8_t *max, robj *hll)
hllPatLen	hyperloglog.c	/^int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {$/;"	f	language:C	signature:(unsigned char *ele, size_t elesize, long *regp)
hllRawSum	hyperloglog.c	/^double hllRawSum(uint8_t *registers, double *PE, int *ezp) {$/;"	f	language:C	signature:(uint8_t *registers, double *PE, int *ezp)
hllSparseAdd	hyperloglog.c	/^int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f	language:C	signature:(robj *o, unsigned char *ele, size_t elesize)
hllSparseSum	hyperloglog.c	/^double hllSparseSum(uint8_t *sparse, int sparselen, double *PE, int *ezp, int *invalid) {$/;"	f	language:C	signature:(uint8_t *sparse, int sparselen, double *PE, int *ezp, int *invalid)
hllSparseToDense	hyperloglog.c	/^int hllSparseToDense(robj *o) {$/;"	f	language:C	signature:(robj *o)
hll_sparse_max_bytes	server.h	/^    size_t hll_sparse_max_bytes;$/;"	m	language:C	struct:redisServer	access:public
hllhdr	hyperloglog.c	/^struct hllhdr {$/;"	s	language:C	file:
hllhdr::card	hyperloglog.c	/^    uint8_t card[8];    \/* Cached cardinality, little endian. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
hllhdr::encoding	hyperloglog.c	/^    uint8_t encoding;   \/* HLL_DENSE or HLL_SPARSE. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
hllhdr::magic	hyperloglog.c	/^    char magic[4];      \/* "HYLL" *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
hllhdr::notused	hyperloglog.c	/^    uint8_t notused[3]; \/* Reserved for future use, must be zero. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
hllhdr::registers	hyperloglog.c	/^    uint8_t registers[]; \/* Data bytes. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
hmem	server.c	/^        char hmem[64];$/;"	l	language:C
hmgetCommand	server.h	/^void hmgetCommand(client *c);$/;"	p	language:C	signature:(client *c)
hmgetCommand	t_hash.c	/^void hmgetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hmsetCommand	server.h	/^void hmsetCommand(client *c);$/;"	p	language:C	signature:(client *c)
hmsetCommand	t_hash.c	/^void hmsetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
home	redis-cli.c	/^        char *home = getenv("HOME");$/;"	l	language:C
hostip	redis-benchmark.c	/^    const char *hostip;$/;"	m	language:C	struct:config	file:	access:public
hostip	redis-cli.c	/^    char *hostip;$/;"	m	language:C	struct:config	file:	access:public
hostport	redis-benchmark.c	/^    int hostport;$/;"	m	language:C	struct:config	file:	access:public
hostport	redis-cli.c	/^    int hostport;$/;"	m	language:C	struct:config	file:	access:public
hostsocket	redis-benchmark.c	/^    const char *hostsocket;$/;"	m	language:C	struct:config	file:	access:public
hostsocket	redis-cli.c	/^    char *hostsocket;$/;"	m	language:C	struct:config	file:	access:public
hscanCommand	server.h	/^void hscanCommand(client *c);$/;"	p	language:C	signature:(client *c)
hscanCommand	t_hash.c	/^void hscanCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hsetCommand	server.h	/^void hsetCommand(client *c);$/;"	p	language:C	signature:(client *c)
hsetCommand	t_hash.c	/^void hsetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hsetnxCommand	server.h	/^void hsetnxCommand(client *c);$/;"	p	language:C	signature:(client *c)
hsetnxCommand	t_hash.c	/^void hsetnxCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hslot	lzf_c.c	/^      LZF_HSLOT *hslot;$/;"	l	language:C
hstrlenCommand	server.h	/^void hstrlenCommand(client *c);$/;"	p	language:C	signature:(client *c)
hstrlenCommand	t_hash.c	/^void hstrlenCommand(client *c) {$/;"	f	language:C	signature:(client *c)
ht	db.c	/^    dict *ht;$/;"	l	language:C
ht	dict.c	/^            dictht *ht = &iter->d->ht[iter->table];$/;"	l	language:C
ht	dict.c	/^    dictht *ht;$/;"	l	language:C
ht	dict.h	/^    dictht ht[2];$/;"	m	language:C	struct:dict	access:public
ht	lazyfree.c	/^        dict *ht = obj->ptr;$/;"	l	language:C
ht	t_set.c	/^        dict *ht = subject->ptr;$/;"	l	language:C
ht	t_zset.c	/^            dict *ht = op->subject->ptr;$/;"	l	language:C
ht	t_zset.c	/^            } ht;$/;"	m	language:C	union:__anon40::__anon41::_iterset	typeref:struct:__anon40::__anon41::_iterset::__anon43	file:	access:public
htNeedsResize	server.c	/^int htNeedsResize(dict *dict) {$/;"	f	language:C	signature:(dict *dict)
htNeedsResize	server.h	/^int htNeedsResize(dict *dict);$/;"	p	language:C	signature:(dict *dict)
htab	lzf_c.c	/^  LZF_STATE htab;$/;"	l	language:C
hto	modules/hellotype.c	/^    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);$/;"	l	language:C
hto	modules/hellotype.c	/^    struct HelloTypeObject *hto = createHelloTypeObject();$/;"	l	language:C
hto	modules/hellotype.c	/^    struct HelloTypeObject *hto = value;$/;"	l	language:C
hto	modules/hellotype.c	/^    struct HelloTypeObject *hto;$/;"	l	language:C
htonu64	endianconv.h	/^#define htonu64(/;"	d	language:C
hval	lzf_c.c	/^  unsigned int hval;$/;"	l	language:C
hvalsCommand	server.h	/^void hvalsCommand(client *c);$/;"	p	language:C	signature:(client *c)
hvalsCommand	t_hash.c	/^void hvalsCommand(client *c) {$/;"	f	language:C	signature:(client *c)
hz	server.h	/^    int hz;                     \/* serverCron() calls frequency in hertz *\/$/;"	m	language:C	struct:redisServer	access:public
hz	server.h	/^#undef hz$/;"	d	language:C
i	ae.c	/^    int i;$/;"	l	language:C
i	ae_evport.c	/^    int i;$/;"	l	language:C
i	ae_evport.c	/^    int mask, i;$/;"	l	language:C
i	bitops.c	/^            int i;$/;"	l	language:C
i	bitops.c	/^            unsigned long i;$/;"	l	language:C
i	bitops.c	/^        unsigned long i;$/;"	l	language:C
i	bitops.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon1	file:	access:public
i	bitops.c	/^    unsigned long j, i, byte;$/;"	l	language:C
i	cluster.c	/^            int bit, i;$/;"	l	language:C
i	cluster.c	/^        int i, size = sizeof(redisNodeFlagsTable)\/sizeof(struct redisNodeFlags);$/;"	l	language:C
i	cluster.c	/^    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;$/;"	l	language:C
i	config.c	/^    int i;$/;"	l	language:C
i	config.c	/^    int linenum = 0, totlines, i;$/;"	l	language:C
i	db.c	/^    int i, j, num, *keys, found_store = 0;$/;"	l	language:C
i	db.c	/^    int i, j;$/;"	l	language:C
i	db.c	/^    int i, num, *keys;$/;"	l	language:C
i	db.c	/^    int i, num, first, *keys;$/;"	l	language:C
i	db.c	/^    int j, i = 0, last, *keys;$/;"	l	language:C
i	debug.c	/^    int i;$/;"	l	language:C
i	dict.c	/^    dictIterator *i = dictGetIterator(d);$/;"	l	language:C
i	dict.c	/^    unsigned long i = DICT_HT_INITIAL_SIZE;$/;"	l	language:C
i	dict.c	/^    unsigned long i = random() & maxsizemask;$/;"	l	language:C
i	dict.c	/^    unsigned long i, slots = 0, chainlen, maxchainlen = 0;$/;"	l	language:C
i	dict.c	/^    unsigned long i;$/;"	l	language:C
i	evict.c	/^        int j, k, i, keys_freed = 0;$/;"	l	language:C
i	geo.c	/^            int i;$/;"	l	language:C
i	geo.c	/^        int i;$/;"	l	language:C
i	geo.c	/^    int i;$/;"	l	language:C
i	geo.c	/^    size_t i;$/;"	l	language:C
i	geo.c	/^    unsigned int i, count = 0, last_processed = 0;$/;"	l	language:C
i	hyperloglog.c	/^    int i;$/;"	l	language:C
i	hyperloglog.c	/^    unsigned int j, i;$/;"	l	language:C
i	intset.c	/^        int i, bits = 20;$/;"	l	language:C
i	intset.c	/^        int i, v1, v2;$/;"	l	language:C
i	intset.c	/^    int i;$/;"	l	language:C
i	latency.c	/^        int i = (ts->idx + j) % LATENCY_TS_LEN;$/;"	l	language:C
i	module.c	/^             size_t i = 0;$/;"	l	language:C
i	module.c	/^            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;$/;"	l	language:C
i	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon21	file:	access:public
i	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon22	file:	access:public
i	multi.c	/^        int i;$/;"	l	language:C
i	networking.c	/^            int i = 2; \/* Next option index. *\/$/;"	l	language:C
i	quicklist.c	/^                int i = 0;$/;"	l	language:C
i	quicklist.c	/^                int i = 437;$/;"	l	language:C
i	quicklist.c	/^            int i = 0;$/;"	l	language:C
i	quicklist.c	/^            int i = 499, count = 0;$/;"	l	language:C
i	quicklist.c	/^    int i = 0;$/;"	l	language:C
i	rdb.c	/^    unsigned int i;$/;"	l	language:C
i	redis-benchmark.c	/^    int i, curlat = 0;$/;"	l	language:C
i	redis-benchmark.c	/^    int i;$/;"	l	language:C
i	redis-benchmark.c	/^    size_t i;$/;"	l	language:C
i	redis-check-aof.c	/^    int i, multi = 0;$/;"	l	language:C
i	redis-cli.c	/^            unsigned int i, idxlen = 0;$/;"	l	language:C
i	redis-cli.c	/^        int i;$/;"	l	language:C
i	redis-cli.c	/^    int i = 0;$/;"	l	language:C
i	redis-cli.c	/^    int i, argc, buflen = strlen(buf);$/;"	l	language:C
i	redis-cli.c	/^    int i, j, len;$/;"	l	language:C
i	redis-cli.c	/^    int i, len, pos = 0;$/;"	l	language:C
i	redis-cli.c	/^    int i;$/;"	l	language:C
i	redis-cli.c	/^    size_t i;$/;"	l	language:C
i	redis-cli.c	/^    unsigned char s[256], i, j, t;$/;"	l	language:C
i	redis-cli.c	/^    unsigned int arrsize=0, i;$/;"	l	language:C
i	redis-cli.c	/^    unsigned int i;$/;"	l	language:C
i	scripting.c	/^        int i = 1; \/* Variable index. *\/$/;"	l	language:C
i	sds.c	/^            int step = 10, j, i;$/;"	l	language:C
i	sds.c	/^        int i;$/;"	l	language:C
i	sds.c	/^    int i;$/;"	l	language:C
i	sds.c	/^    size_t j, i, l = sdslen(s);$/;"	l	language:C
i	server.c	/^        int i;$/;"	l	language:C
i	setproctitle.c	/^	int i, error;$/;"	l	language:C
i	setproctitle.c	/^	int i;$/;"	l	language:C
i	sha1.c	/^    int i;$/;"	l	language:C
i	sha1.c	/^    uint32_t i, j;$/;"	l	language:C
i	sha1.c	/^    unsigned i;$/;"	l	language:C
i	t_hash.c	/^    int i;$/;"	l	language:C
i	t_zset.c	/^    int i, j;$/;"	l	language:C
i	t_zset.c	/^    int i, level;$/;"	l	language:C
i	t_zset.c	/^    int i;$/;"	l	language:C
i	util.c	/^        int const i = (value % 100) * 2;$/;"	l	language:C
i	util.c	/^        int i = (uint32_t) value * 2;$/;"	l	language:C
i	ziplist.c	/^        int i,j,len,where;$/;"	l	language:C
i	ziplist.c	/^        int i,len;$/;"	l	language:C
i	ziplist.c	/^        size_t i;$/;"	l	language:C
i	ziplist.c	/^    int i,j,k;$/;"	l	language:C
i	ziplist.c	/^    unsigned int i, totlen, deleted = 0;$/;"	l	language:C
i	zipmap.c	/^        unsigned char *i = zipmapRewind(zm);$/;"	l	language:C
i	zipmap.c	/^        unsigned int vlen, i;$/;"	l	language:C
i16	intset.c	/^            int16_t *i16 = (int16_t*)is->contents;$/;"	l	language:C
i16	ziplist.c	/^    int16_t i16;$/;"	l	language:C
i32	intset.c	/^            int32_t *i32 = (int32_t*)is->contents;$/;"	l	language:C
i32	ziplist.c	/^    int32_t i32;$/;"	l	language:C
i64	bitops.c	/^        long long i64 = 0;  \/* Signed SET value. *\/$/;"	l	language:C
i64	bitops.c	/^    int64_t i64;        \/* Increment amount (INCRBY) or SET value *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
i64	intset.c	/^            int64_t *i64 = (int64_t*)is->contents;$/;"	l	language:C
i64	ziplist.c	/^    int64_t i64, ret = 0;$/;"	l	language:C
i64	ziplist.c	/^    int64_t i64;$/;"	l	language:C
ibuf	redis-cli.c	/^    char ibuf[1024*16], obuf[1024*16]; \/* Input and output buffers *\/$/;"	l	language:C
id	ae.c	/^        long long id;$/;"	l	language:C
id	ae.c	/^    long long id = eventLoop->timeEventNextId++;$/;"	l	language:C
id	ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	language:C	struct:aeTimeEvent	access:public
id	cluster.c	/^    sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);$/;"	l	language:C
id	cluster.c	/^    sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);$/;"	l	language:C
id	db.c	/^    long id;$/;"	l	language:C
id	module.c	/^        uint64_t id;$/;"	m	language:C	struct:__anon20	file:	access:public
id	module.c	/^    uint64_t id = moduleTypeEncodeId(name,encver);$/;"	l	language:C
id	networking.c	/^        uint64_t id = 0;$/;"	l	language:C
id	server.h	/^    int id;                     \/* Database ID *\/$/;"	m	language:C	struct:redisDb	access:public
id	server.h	/^    uint64_t id;            \/* Client incremental unique ID. *\/$/;"	m	language:C	struct:client	access:public
id	server.h	/^    uint64_t id; \/* Higher 54 bits of type ID + 10 lower bits of encoding ver. *\/$/;"	m	language:C	struct:RedisModuleType	access:public
id	slowlog.h	/^    long long id;       \/* Unique entry identifier. *\/$/;"	m	language:C	struct:slowlogEntry	access:public
idle	evict.c	/^        unsigned long long idle;$/;"	l	language:C
idle	evict.c	/^    unsigned long long idle;    \/* Object idle time (inverse frequency for LFU) *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
idle	replication.c	/^        time_t idle = server.unixtime - server.repl_no_slaves_since;$/;"	l	language:C
idle	replication.c	/^        time_t idle, max_idle = 0;$/;"	l	language:C
idlemode	redis-benchmark.c	/^    int idlemode;$/;"	m	language:C	struct:config	file:	access:public
idletime	server.c	/^    time_t idletime = server.unixtime - c->lastinteraction;$/;"	l	language:C
ids	rdb.c	/^            uint64_t *ids = len+1;$/;"	l	language:C
idx	dict.c	/^    unsigned int h, idx, table;$/;"	l	language:C
idx	dict.c	/^    unsigned int h, idx;$/;"	l	language:C
idx	geo.c	/^                int idx = (hash.bits >> (52-((i+1)*5))) & 0x1f;$/;"	l	language:C
idx	hyperloglog.c	/^    int ez = 0, idx = 0, runlen, regval;$/;"	l	language:C
idx	hyperloglog.c	/^    int idx = 0, runlen, regval;$/;"	l	language:C
idx	latency.h	/^    int idx; \/* Index of the next sample to store. *\/$/;"	m	language:C	struct:latencyTimeSeries	access:public
idx	scripting.c	/^    int idx = line-1;$/;"	l	language:C
idx	server.h	/^        int idx;$/;"	m	language:C	struct:redisServer::__anon29	access:public
idxlen	redis-cli.c	/^            unsigned int i, idxlen = 0;$/;"	l	language:C
ii	aof.c	/^        int ii = 0;$/;"	l	language:C
ii	server.h	/^    int ii; \/* intset iterator *\/$/;"	m	language:C	struct:__anon33	access:public
ii	t_zset.c	/^                int ii;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon42	file:	access:public
ilato	geohash.c	/^    uint32_t ilato = hash_sep;       \/* get lat part of deinterleaved hash *\/$/;"	l	language:C
ilono	geohash.c	/^    uint32_t ilono = hash_sep >> 32; \/* shift over to get long part of hash *\/$/;"	l	language:C
implementation	modules/INTRO.md	/^received from the `argv` parameter in the command implementation, binary$/;"	v	language:C
importing_slot	cluster.c	/^    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;$/;"	l	language:C
importing_slots_from	cluster.h	/^    clusterNode *importing_slots_from[CLUSTER_SLOTS];$/;"	m	language:C	struct:clusterState	access:public
in_depth	quicklist.c	/^    int in_depth = 0;$/;"	l	language:C
in_end	lzf_c.c	/^  const u8 *in_end  = ip + in_len;$/;"	l	language:C
in_end	lzf_d.c	/^  u8 const *const in_end  = ip + in_len;$/;"	l	language:C
in_progress	sentinel.c	/^    int in_progress = 0;$/;"	l	language:C
incr	t_hash.c	/^    long double value, incr;$/;"	l	language:C
incr	t_hash.c	/^    long long value, incr, oldvalue;$/;"	l	language:C
incr	t_string.c	/^    long double incr, value;$/;"	l	language:C
incr	t_string.c	/^    long long incr;$/;"	l	language:C
incr	t_zset.c	/^    int incr = (*flags & ZADD_INCR) != 0;$/;"	l	language:C
incr	t_zset.c	/^    int incr = (flags & ZADD_INCR) != 0;$/;"	l	language:C
incrCommand	server.h	/^void incrCommand(client *c);$/;"	p	language:C	signature:(client *c)
incrCommand	t_string.c	/^void incrCommand(client *c) {$/;"	f	language:C	signature:(client *c)
incrDecrCommand	t_string.c	/^void incrDecrCommand(client *c, long long incr) {$/;"	f	language:C	signature:(client *c, long long incr)
incrRefCount	object.c	/^void incrRefCount(robj *o) {$/;"	f	language:C	signature:(robj *o)
incrRefCount	server.h	/^void incrRefCount(robj *o);$/;"	p	language:C	signature:(robj *o)
incrbyCommand	server.h	/^void incrbyCommand(client *c);$/;"	p	language:C	signature:(client *c)
incrbyCommand	t_string.c	/^void incrbyCommand(client *c) {$/;"	f	language:C	signature:(client *c)
incrbyfloatCommand	server.h	/^void incrbyfloatCommand(client *c);$/;"	p	language:C	signature:(client *c)
incrbyfloatCommand	t_string.c	/^void incrbyfloatCommand(client *c) {$/;"	f	language:C	signature:(client *c)
incrementallyRehash	server.c	/^int incrementallyRehash(int dbid) {$/;"	f	language:C	signature:(int dbid)
incremented	modules/API.md	/^a new score, the score of the existing element is incremented, or if the$/;"	v	language:C
index	dict.c	/^    int index;$/;"	l	language:C
index	dict.h	/^    long index;$/;"	m	language:C	struct:dictIterator	access:public
index	hyperloglog.c	/^    long index, first, span;$/;"	l	language:C
index	hyperloglog.c	/^    long index;$/;"	l	language:C
index	hyperloglog.c	/^    uint64_t hash, bit, index;$/;"	l	language:C
index	quicklist.c	/^    unsigned long long index;$/;"	l	language:C
index	t_list.c	/^    long index;$/;"	l	language:C
index	ziplist.c	/^    int index = 0;$/;"	l	language:C
info	anet.c	/^    struct addrinfo hints, *info;$/;"	l	language:C
info	cluster.c	/^        sds info = sdscatprintf(sdsempty(),$/;"	l	language:C
info	debug.c	/^            sds info = sdsempty();$/;"	l	language:C
info	debug.c	/^    sds *info = (sds *)result;$/;"	l	language:C
info	sentinel.c	/^    sds info = sdsempty();$/;"	l	language:C
info	sentinel.c	/^    sds info; \/* cached INFO output *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
info	server.c	/^    sds info = sdsempty();$/;"	l	language:C
infoCommand	server.c	/^void infoCommand(client *c) {$/;"	f	language:C	signature:(client *c)
infoCommand	server.h	/^void infoCommand(client *c);$/;"	p	language:C	signature:(client *c)
info_period	sentinel.c	/^    mstime_t info_period, ping_period;$/;"	l	language:C
info_refresh	sentinel.c	/^    mstime_t info_refresh;  \/* Time at which we received INFO output from it. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
info_section_from_redis	sentinel.c	/^#define info_section_from_redis(/;"	d	language:C	file:
info_validity_time	sentinel.c	/^        mstime_t info_validity_time;$/;"	l	language:C
infostring	debug.c	/^    sds infostring, clients;$/;"	l	language:C
initClientMultiState	multi.c	/^void initClientMultiState(client *c) {$/;"	f	language:C	signature:(client *c)
initClientMultiState	server.h	/^void initClientMultiState(client *c);$/;"	p	language:C	signature:(client *c)
initEntry	quicklist.c	/^#define initEntry(/;"	d	language:C	file:
initSentinel	sentinel.c	/^void initSentinel(void) {$/;"	f	language:C	signature:(void)
initSentinel	server.h	/^void initSentinel(void);$/;"	p	language:C	signature:(void)
initSentinelConfig	sentinel.c	/^void initSentinelConfig(void) {$/;"	f	language:C	signature:(void)
initSentinelConfig	server.h	/^void initSentinelConfig(void);$/;"	p	language:C	signature:(void)
initServer	server.c	/^void initServer(void) {$/;"	f	language:C	signature:(void)
initServerConfig	server.c	/^void initServerConfig(void) {$/;"	f	language:C	signature:(void)
initStaticStringObject	server.h	/^#define initStaticStringObject(/;"	d	language:C
initialized	hyperloglog.c	/^    static int initialized = 0;$/;"	l	language:C	file:
initlen	sds.c	/^    size_t initlen = (init == NULL) ? 0 : strlen(init);$/;"	l	language:C
initlen	sds.c	/^    size_t initlen = sdslen(s);$/;"	l	language:C
inline	lzf_c.c	/^# define inline /;"	d	language:C	file:
inputCatSds	debug.c	/^void inputCatSds(void *result, const char *str) {$/;"	f	language:C	signature:(void *result, const char *str)
inq	sds.c	/^            int inq=0;  \/* set to 1 if we are in "quotes" *\/$/;"	l	language:C
inserted	t_list.c	/^    int inserted = 0;$/;"	l	language:C
inserts	intset.c	/^        uint32_t inserts = 0;$/;"	l	language:C
insq	sds.c	/^            int insq=0; \/* set to 1 if we are in 'single quotes' *\/$/;"	l	language:C
inst_metric	server.h	/^    } inst_metric[STATS_METRIC_COUNT];$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::__anon29	access:public
instance	sentinel.c	/^    sentinelRedisInstance **instance =$/;"	l	language:C
instance	sentinel.c	/^    sentinelRedisInstance *instance = NULL;$/;"	l	language:C
instanceLink	sentinel.c	/^typedef struct instanceLink {$/;"	s	language:C	file:
instanceLink	sentinel.c	/^} instanceLink;$/;"	t	language:C	typeref:struct:instanceLink	file:
instanceLink::act_ping_time	sentinel.c	/^    mstime_t act_ping_time;   \/* Time at which the last pending ping (no pong$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::cc	sentinel.c	/^    redisAsyncContext *cc; \/* Hiredis context for commands. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::cc_conn_time	sentinel.c	/^    mstime_t cc_conn_time; \/* cc connection time. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::disconnected	sentinel.c	/^    int disconnected;      \/* Non-zero if we need to reconnect cc or pc. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::last_avail_time	sentinel.c	/^    mstime_t last_avail_time; \/* Last time the instance replied to ping with$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::last_ping_time	sentinel.c	/^    mstime_t last_ping_time;  \/* Time at which we sent the last ping. This is$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::last_pong_time	sentinel.c	/^    mstime_t last_pong_time;  \/* Last time the instance replied to ping,$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::last_reconn_time	sentinel.c	/^    mstime_t last_reconn_time;  \/* Last reconnection attempt performed when$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::pc	sentinel.c	/^    redisAsyncContext *pc; \/* Hiredis context for Pub \/ Sub. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::pc_conn_time	sentinel.c	/^    mstime_t pc_conn_time; \/* pc connection time. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::pc_last_activity	sentinel.c	/^    mstime_t pc_last_activity; \/* Last time we received any message. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::pending_commands	sentinel.c	/^    int pending_commands;  \/* Number of commands sent waiting for a reply. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLink::refcount	sentinel.c	/^    int refcount;          \/* Number of sentinelRedisInstance owners. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
instanceLinkCloseConnection	sentinel.c	/^void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {$/;"	f	language:C	signature:(instanceLink *link, redisAsyncContext *c)
instanceLinkConnectionError	sentinel.c	/^void instanceLinkConnectionError(const redisAsyncContext *c) {$/;"	f	language:C	signature:(const redisAsyncContext *c)
instanceLinkConnectionError	sentinel.c	/^void instanceLinkConnectionError(const redisAsyncContext *c);$/;"	p	language:C	file:	signature:(const redisAsyncContext *c)
instances	sentinel.c	/^    int instances = 0;$/;"	l	language:C
instancesDictType	sentinel.c	/^dictType instancesDictType = {$/;"	v	language:C
instead	modules/INTRO.md	/^instead, the name the module used to register itself into the Redis core.$/;"	v	language:C
int_convertion_error	sort.c	/^    int int_convertion_error = 0;$/;"	l	language:C
integer	modules/API.md	/^Convert the string into a long long integer, storing it at `*ll`.$/;"	v	language:C
integer	modules/INTRO.md	/^of type string or integer, to API functions expecting a module string.$/;"	v	language:C
integers	dict.c	/^    long long integers[6], hash = 0;$/;"	l	language:C
integers	server.h	/^    *integers[OBJ_SHARED_INTEGERS],$/;"	m	language:C	struct:sharedObjectsStruct	access:public
intele	t_set.c	/^        int64_t intele;$/;"	l	language:C
intele	t_set.c	/^    int64_t intele;$/;"	l	language:C
interactive	redis-cli.c	/^    int interactive;$/;"	m	language:C	struct:config	file:	access:public
interleave64	geohash.c	/^static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {$/;"	f	language:C	file:	signature:(uint32_t xlo, uint32_t ylo)
interval	redis-cli.c	/^    long interval;$/;"	m	language:C	struct:config	file:	access:public
intobj	t_set.c	/^    int64_t intobj;$/;"	l	language:C
intrev16	endianconv.c	/^uint16_t intrev16(uint16_t v) {$/;"	f	language:C	signature:(uint16_t v)
intrev16	endianconv.h	/^uint16_t intrev16(uint16_t v);$/;"	p	language:C	signature:(uint16_t v)
intrev16ifbe	endianconv.h	/^#define intrev16ifbe(/;"	d	language:C
intrev32	endianconv.c	/^uint32_t intrev32(uint32_t v) {$/;"	f	language:C	signature:(uint32_t v)
intrev32	endianconv.h	/^uint32_t intrev32(uint32_t v);$/;"	p	language:C	signature:(uint32_t v)
intrev32ifbe	endianconv.h	/^#define intrev32ifbe(/;"	d	language:C
intrev64	endianconv.c	/^uint64_t intrev64(uint64_t v) {$/;"	f	language:C	signature:(uint64_t v)
intrev64	endianconv.h	/^uint64_t intrev64(uint64_t v);$/;"	p	language:C	signature:(uint64_t v)
intrev64ifbe	endianconv.h	/^#define intrev64ifbe(/;"	d	language:C
intrinsicLatencyMode	redis-cli.c	/^static void intrinsicLatencyMode(void) {$/;"	f	language:C	file:	signature:(void)
intrinsicLatencyModeStop	redis-cli.c	/^static void intrinsicLatencyModeStop(int s) {$/;"	f	language:C	file:	signature:(int s)
intrinsic_latency_duration	redis-cli.c	/^    int intrinsic_latency_duration;$/;"	m	language:C	struct:config	file:	access:public
intrinsic_latency_mode	redis-cli.c	/^    int intrinsic_latency_mode;$/;"	m	language:C	struct:config	file:	access:public
intset	intset.h	/^typedef struct intset {$/;"	s	language:C
intset	intset.h	/^} intset;$/;"	t	language:C	typeref:struct:intset
intset::contents	intset.h	/^    int8_t contents[];$/;"	m	language:C	struct:intset	access:public
intset::encoding	intset.h	/^    uint32_t encoding;$/;"	m	language:C	struct:intset	access:public
intset::length	intset.h	/^    uint32_t length;$/;"	m	language:C	struct:intset	access:public
intsetAdd	intset.c	/^intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {$/;"	f	language:C	signature:(intset *is, int64_t value, uint8_t *success)
intsetAdd	intset.h	/^intset *intsetAdd(intset *is, int64_t value, uint8_t *success);$/;"	p	language:C	signature:(intset *is, int64_t value, uint8_t *success)
intsetBlobLen	intset.c	/^size_t intsetBlobLen(intset *is) {$/;"	f	language:C	signature:(intset *is)
intsetBlobLen	intset.h	/^size_t intsetBlobLen(intset *is);$/;"	p	language:C	signature:(intset *is)
intsetFind	intset.c	/^            assert(intsetFind(is,v1));$/;"	p	language:C	file:
intsetFind	intset.c	/^uint8_t intsetFind(intset *is, int64_t value) {$/;"	f	language:C	signature:(intset *is, int64_t value)
intsetFind	intset.h	/^uint8_t intsetFind(intset *is, int64_t value);$/;"	p	language:C	signature:(intset *is, int64_t value)
intsetGet	intset.c	/^uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {$/;"	f	language:C	signature:(intset *is, uint32_t pos, int64_t *value)
intsetGet	intset.h	/^uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);$/;"	p	language:C	signature:(intset *is, uint32_t pos, int64_t *value)
intsetLen	intset.c	/^uint32_t intsetLen(const intset *is) {$/;"	f	language:C	signature:(const intset *is)
intsetLen	intset.h	/^uint32_t intsetLen(const intset *is);$/;"	p	language:C	signature:(const intset *is)
intsetMoveTail	intset.c	/^static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {$/;"	f	language:C	file:	signature:(intset *is, uint32_t from, uint32_t to)
intsetNew	intset.c	/^intset *intsetNew(void) {$/;"	f	language:C	signature:(void)
intsetNew	intset.h	/^intset *intsetNew(void);$/;"	p	language:C	signature:(void)
intsetRandom	intset.c	/^int64_t intsetRandom(intset *is) {$/;"	f	language:C	signature:(intset *is)
intsetRandom	intset.h	/^int64_t intsetRandom(intset *is);$/;"	p	language:C	signature:(intset *is)
intsetRemove	intset.c	/^intset *intsetRemove(intset *is, int64_t value, int *success) {$/;"	f	language:C	signature:(intset *is, int64_t value, int *success)
intsetRemove	intset.h	/^intset *intsetRemove(intset *is, int64_t value, int *success);$/;"	p	language:C	signature:(intset *is, int64_t value, int *success)
intsetResize	intset.c	/^static intset *intsetResize(intset *is, uint32_t len) {$/;"	f	language:C	file:	signature:(intset *is, uint32_t len)
intsetSearch	intset.c	/^static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {$/;"	f	language:C	file:	signature:(intset *is, int64_t value, uint32_t *pos)
intsetTest	intset.c	/^int intsetTest(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
intsetTest	intset.h	/^int intsetTest(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
intsetUpgradeAndAdd	intset.c	/^static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {$/;"	f	language:C	file:	signature:(intset *is, int64_t value)
inuse	scripting.c	/^    static int inuse = 0;   \/* Recursive calls detection. *\/$/;"	l	language:C	file:
invalid	hyperloglog.c	/^            int invalid = 0;$/;"	l	language:C
invalid	modules/API.md	/^and if the module name or encver is invalid, NULL is returned.$/;"	v	language:C
invalid_hll_err	hyperloglog.c	/^static char *invalid_hll_err = "-INVALIDOBJ Corrupted HLL object detected\\r\\n";$/;"	v	language:C	file:
io	aof.c	/^    RedisModuleIO io;$/;"	l	language:C
io	rdb.c	/^        RedisModuleIO io;$/;"	l	language:C
io	rio.h	/^    } io;$/;"	m	language:C	struct:_rio	typeref:union:_rio::__anon25	access:public
iov	server.c	/^    struct iovec iov;$/;"	l	language:C
ip	anet.c	/^    char ip[INET6_ADDRSTRLEN];$/;"	l	language:C
ip	cluster.c	/^            char ip[NET_IP_STR_LEN];$/;"	l	language:C
ip	cluster.c	/^    char ip[NET_IP_STR_LEN] = {0};$/;"	l	language:C
ip	cluster.h	/^    char ip[NET_IP_STR_LEN];  \/* IP address last time it was seen *\/$/;"	m	language:C	struct:__anon2	access:public
ip	cluster.h	/^    char ip[NET_IP_STR_LEN];  \/* Latest known IP address of this node *\/$/;"	m	language:C	struct:clusterNode	access:public
ip	lzf_c.c	/^  const u8 *ip = (const u8 *)in_data;$/;"	l	language:C
ip	lzf_d.c	/^  u8 const *ip = (const u8 *)in_data;$/;"	l	language:C
ip	replication.c	/^            char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;$/;"	l	language:C
ip	replication.c	/^            sds ip = c->argv[j+1]->ptr;$/;"	l	language:C
ip	replication.c	/^    char ip[NET_IP_STR_LEN];$/;"	l	language:C
ip	sentinel.c	/^            char *ip, *port, *end;$/;"	l	language:C
ip	sentinel.c	/^        char ip[NET_IP_STR_LEN];$/;"	l	language:C
ip	sentinel.c	/^    char *ip;$/;"	m	language:C	struct:sentinelAddr	file:	access:public
ip	sentinel.c	/^    char ip[NET_IP_STR_LEN];$/;"	l	language:C
ip	server.c	/^                char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;$/;"	l	language:C
ip_len	anet.h	/^#undef ip_len$/;"	d	language:C
ipfd	server.h	/^    int ipfd[CONFIG_BINDADDR_MAX]; \/* TCP socket file descriptors *\/$/;"	m	language:C	struct:redisServer	access:public
ipfd_count	server.h	/^    int ipfd_count;             \/* Used slots in ipfd[] *\/$/;"	m	language:C	struct:redisServer	access:public
is	intset.c	/^    intset *is = intsetNew();$/;"	l	language:C
is	intset.c	/^    intset *is = zmalloc(sizeof(intset));$/;"	l	language:C
is	intset.c	/^    intset *is;$/;"	l	language:C
is	modules/API.md	/^* **encver**: Encoding version, which is, the version of the serialization$/;"	v	language:C
is	modules/API.md	/^error, that is, the key is not open for writing, is not a string$/;"	v	language:C
is	modules/API.md	/^the usage is, for example:$/;"	v	language:C
is	object.c	/^    intset *is = intsetNew();$/;"	l	language:C
is	t_zset.c	/^                intset *is;$/;"	m	language:C	struct:__anon40::__anon41::_iterset::__anon42	file:	access:public
is	t_zset.c	/^            } is;$/;"	m	language:C	union:__anon40::__anon41::_iterset	typeref:struct:__anon40::__anon41::_iterset::__anon42	file:	access:public
isColorTerm	redis-cli.c	/^int isColorTerm(void) {$/;"	f	language:C	signature:(void)
isHLLObjectOrReply	hyperloglog.c	/^int isHLLObjectOrReply(client *c, robj *o) {$/;"	f	language:C	signature:(client *c, robj *o)
isObjectRepresentableAsLongLong	object.c	/^int isObjectRepresentableAsLongLong(robj *o, long long *llval) {$/;"	f	language:C	signature:(robj *o, long long *llval)
isObjectRepresentableAsLongLong	server.h	/^int isObjectRepresentableAsLongLong(robj *o, long long *llongval);$/;"	p	language:C	signature:(robj *o, long long *llongval)
isSdsRepresentableAsLongLong	object.c	/^int isSdsRepresentableAsLongLong(sds s, long long *llval) {$/;"	f	language:C	signature:(sds s, long long *llval)
isSdsRepresentableAsLongLong	server.h	/^int isSdsRepresentableAsLongLong(sds s, long long *llval);$/;"	p	language:C	signature:(sds s, long long *llval)
is_array	scripting.c	/^        int is_array = 1; \/* Will be set to null if check fails. *\/$/;"	l	language:C
is_hex_digit	sds.c	/^int is_hex_digit(char c) {$/;"	f	language:C	signature:(char c)
is_orphaned	cluster.c	/^        int okslaves = 0, is_orphaned = 1;$/;"	l	language:C
is_val	hyperloglog.c	/^    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;$/;"	l	language:C
is_xzero	hyperloglog.c	/^    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;$/;"	l	language:C
is_zero	hyperloglog.c	/^    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;$/;"	l	language:C
isdown	sentinel.c	/^        int isdown = 0;$/;"	l	language:C
isempty	module.c	/^    int isempty;$/;"	l	language:C
isencoded	rdb.c	/^    int isencoded;$/;"	l	language:C
isfinite	solarisfixes.h	/^#define isfinite(/;"	d	language:C
isfinite	solarisfixes.h	/^#undef isfinite$/;"	d	language:C
isinf	solarisfixes.h	/^#define isinf(/;"	d	language:C
isinf	solarisfixes.h	/^#undef isinf$/;"	d	language:C
isleader	sentinel.c	/^    int isleader;$/;"	l	language:C
isnan	solarisfixes.h	/^#define isnan(/;"	d	language:C
isnan	solarisfixes.h	/^#undef isnan$/;"	d	language:C
issueCommand	redis-cli.c	/^static int issueCommand(int argc, char **argv) {$/;"	f	language:C	file:	signature:(int argc, char **argv)
issueCommandRepeat	redis-cli.c	/^static int issueCommandRepeat(int argc, char **argv, long repeat) {$/;"	f	language:C	file:	signature:(int argc, char **argv, long repeat)
it	debug.c	/^    struct itimerval it;$/;"	l	language:C
it	modules/API.md	/^If the key is open for writing, remove it, and setup the key to$/;"	v	language:C
it	modules/API.md	/^If the string is open for writing and is of string type, resize it, padding$/;"	v	language:C
it	modules/TYPES.md	/^we are going to write to it, we usually want to create a new data structure if$/;"	v	language:C
it	redis-cli.c	/^    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;$/;"	l	language:C
it	t_zset.c	/^        iterset *it = &op->iter.set;$/;"	l	language:C
it	t_zset.c	/^        iterzset *it = &op->iter.zset;$/;"	l	language:C
items	aof.c	/^    long long count = 0, items = hashTypeLength(o);$/;"	l	language:C
items	aof.c	/^    long long count = 0, items = listTypeLength(o);$/;"	l	language:C
items	aof.c	/^    long long count = 0, items = setTypeSize(o);$/;"	l	language:C
items	aof.c	/^    long long count = 0, items = zsetLength(o);$/;"	l	language:C
items	modules/API.md	/^are the first items, the ones replicated with `RedisModule_Replicate()`$/;"	v	language:C
items	modules/helloworld.c	/^    size_t items = RedisModule_CallReplyLength(reply);$/;"	l	language:C
items	modules/testmodule.c	/^    long long items = RedisModule_CallReplyLength(reply);$/;"	l	language:C
iter	adlist.c	/^    listIter *iter;$/;"	l	language:C
iter	adlist.c	/^    listIter iter;$/;"	l	language:C
iter	dict.c	/^    dictIterator *iter = zmalloc(sizeof(*iter));$/;"	l	language:C
iter	module.c	/^    void *iter;     \/* Iterator. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
iter	quicklist.c	/^                quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);$/;"	l	language:C
iter	quicklist.c	/^                quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);$/;"	l	language:C
iter	quicklist.c	/^                quicklistIter *iter =$/;"	l	language:C
iter	quicklist.c	/^            quicklistIter *iter = quicklistGetIterator(ql, AL_START_HEAD);$/;"	l	language:C
iter	quicklist.c	/^            quicklistIter *iter = quicklistGetIterator(ql, AL_START_TAIL);$/;"	l	language:C
iter	quicklist.c	/^    quicklistIter *iter =$/;"	l	language:C
iter	quicklist.c	/^    quicklistIter *iter;$/;"	l	language:C
iter	server.h	/^    quicklistIter *iter;$/;"	m	language:C	struct:__anon31	access:public
iter	t_list.c	/^        listTypeIterator *iter = listTypeInitIterator(o, start, LIST_TAIL);$/;"	l	language:C
iter	t_list.c	/^    listTypeIterator *iter;$/;"	l	language:C
iter	t_zset.c	/^    } iter;$/;"	m	language:C	struct:__anon40	typeref:union:__anon40::__anon41	file:	access:public
iter_direction	t_list.c	/^    int iter_direction =$/;"	l	language:C
iteration	cluster.c	/^    static unsigned long long iteration = 0;$/;"	l	language:C	file:
iteration	expire.c	/^    int j, iteration = 0;$/;"	l	language:C
iterations	networking.c	/^    int iterations = 4; \/* See the function top-comment. *\/$/;"	l	language:C
iterations	server.c	/^    int iterations = numclients\/server.hz;$/;"	l	language:C
iterators	dict.h	/^    unsigned long iterators; \/* number of iterators currently running *\/$/;"	m	language:C	struct:dict	access:public
iterset	t_zset.c	/^typedef union _iterset iterset;$/;"	t	language:C	typeref:union:_iterset	file:
iterzset	t_zset.c	/^typedef union _iterzset iterzset;$/;"	t	language:C	typeref:union:_iterzset	file:
itrprintr	quicklist.c	/^static int itrprintr(quicklist *ql, int print) {$/;"	f	language:C	file:	signature:(quicklist *ql, int print)
itrprintr_rev	quicklist.c	/^static int itrprintr_rev(quicklist *ql, int print) {$/;"	f	language:C	file:	signature:(quicklist *ql, int print)
iwords	memtest.c	/^    unsigned long iwords = words\/step;  \/* words per iteration *\/$/;"	l	language:C
j	ae.c	/^        int j;$/;"	l	language:C
j	ae_epoll.c	/^        int j;$/;"	l	language:C
j	ae_kqueue.c	/^        int j;$/;"	l	language:C
j	ae_select.c	/^    int retval, j, numevents = 0;$/;"	l	language:C
j	aof.c	/^        int argc, j;$/;"	l	language:C
j	aof.c	/^    int j;$/;"	l	language:C
j	aof.c	/^    int len, j;$/;"	l	language:C
j	bio.c	/^    int err, j;$/;"	l	language:C
j	bio.c	/^    int j;$/;"	l	language:C
j	bitops.c	/^    int j, numops = 0, changes = 0;$/;"	l	language:C
j	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j, value = 0;$/;"	l	language:C
j	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j;$/;"	l	language:C
j	bitops.c	/^    unsigned long j, i, byte;$/;"	l	language:C
j	bitops.c	/^    unsigned long j;$/;"	l	language:C
j	bitops.c	/^    unsigned long op, j, numkeys;$/;"	l	language:C
j	cluster.c	/^            int j;$/;"	l	language:C
j	cluster.c	/^        int j = 0, start = -1;$/;"	l	language:C
j	cluster.c	/^        int j, slot;$/;"	l	language:C
j	cluster.c	/^        int j;$/;"	l	language:C
j	cluster.c	/^        int margc, *keyindex, numkeys, j;$/;"	l	language:C
j	cluster.c	/^        unsigned int numkeys, j;$/;"	l	language:C
j	cluster.c	/^    int copy, replace, j;$/;"	l	language:C
j	cluster.c	/^    int deleted = 0, j;$/;"	l	language:C
j	cluster.c	/^    int j, new_state;$/;"	l	language:C
j	cluster.c	/^    int j, okslaves = 0;$/;"	l	language:C
j	cluster.c	/^    int j, rank = 0;$/;"	l	language:C
j	cluster.c	/^    int j, start;$/;"	l	language:C
j	cluster.c	/^    int j, type, replace = 0;$/;"	l	language:C
j	cluster.c	/^    int j;$/;"	l	language:C
j	cluster.c	/^    int maxline, j;$/;"	l	language:C
j	config.c	/^            int j, addresses = argc-1;$/;"	l	language:C
j	config.c	/^        int j;$/;"	l	language:C
j	config.c	/^        int vlen, j;$/;"	l	language:C
j	config.c	/^    int j, was_empty = 0;$/;"	l	language:C
j	config.c	/^    int j;$/;"	l	language:C
j	crc64.c	/^    uint64_t j;$/;"	l	language:C
j	db.c	/^    int i, j, num, *keys, found_store = 0;$/;"	l	language:C
j	db.c	/^    int i, j;$/;"	l	language:C
j	db.c	/^    int j = 0;$/;"	l	language:C
j	db.c	/^    int j, async = (flags & EMPTYDB_ASYNC);$/;"	l	language:C
j	db.c	/^    int j, i = 0, last, *keys;$/;"	l	language:C
j	db.c	/^    int j;$/;"	l	language:C
j	db.c	/^    int numdel = 0, j;$/;"	l	language:C
j	debug.c	/^        int j;$/;"	l	language:C
j	debug.c	/^        long keys, j;$/;"	l	language:C
j	debug.c	/^    int j;$/;"	l	language:C
j	debug.c	/^    int regions = 0, j;$/;"	l	language:C
j	dict.c	/^    int j;$/;"	l	language:C
j	dict.c	/^    unsigned long j; \/* internal hash table id, 0 or 1. *\/$/;"	l	language:C
j	evict.c	/^        int j, k, i, keys_freed = 0;$/;"	l	language:C
j	evict.c	/^    int j, k, count;$/;"	l	language:C
j	evict.c	/^    int j;$/;"	l	language:C
j	expire.c	/^    int j, iteration = 0;$/;"	l	language:C
j	geo.c	/^    int j;$/;"	l	language:C
j	hyperloglog.c	/^        int j;$/;"	l	language:C
j	hyperloglog.c	/^    int j, ez = 0;$/;"	l	language:C
j	hyperloglog.c	/^    int j, ez; \/* Number of registers equal to 0. *\/$/;"	l	language:C
j	hyperloglog.c	/^    int j;$/;"	l	language:C
j	hyperloglog.c	/^    int updated = 0, j;$/;"	l	language:C
j	hyperloglog.c	/^    unsigned int j, i;$/;"	l	language:C
j	latency.c	/^            int j, resets = 0;$/;"	l	language:C
j	latency.c	/^    int j;$/;"	l	language:C
j	latency.c	/^    int samples = 0, j;$/;"	l	language:C
j	memtest.c	/^    int j;$/;"	l	language:C
j	memtest.c	/^    size_t chars = ((unsigned long long)curr*progress_full)\/size, j;$/;"	l	language:C
j	memtest.c	/^    unsigned long j, *p;$/;"	l	language:C
j	module.c	/^            size_t j;$/;"	l	language:C
j	module.c	/^    int argc = 0, argv_size, j;$/;"	l	language:C
j	module.c	/^    int argc = 0, flags = 0, j;$/;"	l	language:C
j	module.c	/^    int count, j;$/;"	l	language:C
j	module.c	/^    int j;$/;"	l	language:C
j	module.c	/^    long long arraylen, j;$/;"	l	language:C
j	modules/helloworld.c	/^        size_t len, j;$/;"	l	language:C
j	modules/helloworld.c	/^    size_t j;$/;"	l	language:C
j	multi.c	/^    int j;$/;"	l	language:C
j	networking.c	/^        int j, len = sdslen(c->argv[2]->ptr);$/;"	l	language:C
j	networking.c	/^    int argc, j;$/;"	l	language:C
j	networking.c	/^    int j;$/;"	l	language:C
j	networking.c	/^    size_t l, j;$/;"	l	language:C
j	pubsub.c	/^        int j;$/;"	l	language:C
j	pubsub.c	/^    int j;$/;"	l	language:C
j	rdb.c	/^                int j;$/;"	l	language:C
j	rdb.c	/^            int j, msglen;$/;"	l	language:C
j	rdb.c	/^            uint64_t j;$/;"	l	language:C
j	rdb.c	/^    int j;$/;"	l	language:C
j	redis-benchmark.c	/^                        size_t j;$/;"	l	language:C
j	redis-benchmark.c	/^        size_t j;$/;"	l	language:C
j	redis-benchmark.c	/^    int j;$/;"	l	language:C
j	redis-cli.c	/^                        int j;$/;"	l	language:C
j	redis-cli.c	/^            unsigned int j;$/;"	l	language:C
j	redis-cli.c	/^        int j;$/;"	l	language:C
j	redis-cli.c	/^    int i, j, len;$/;"	l	language:C
j	redis-cli.c	/^    int j, got_comma, keys;$/;"	l	language:C
j	redis-cli.c	/^    int j, output_raw;$/;"	l	language:C
j	redis-cli.c	/^    int j, outputs = 0;$/;"	l	language:C
j	redis-cli.c	/^    int j;$/;"	l	language:C
j	redis-cli.c	/^    unsigned char s[256], i, j, t;$/;"	l	language:C
j	redis-cli.c	/^  int j;$/;"	l	language:C
j	replication.c	/^    int j, len;$/;"	l	language:C
j	replication.c	/^    int j;$/;"	l	language:C
j	replication.c	/^    long long j, skip, len;$/;"	l	language:C
j	rio.c	/^    int j;$/;"	l	language:C
j	scripting.c	/^            int j = 1, mbulklen = 0;$/;"	l	language:C
j	scripting.c	/^            int j;$/;"	l	language:C
j	scripting.c	/^        int j;$/;"	l	language:C
j	scripting.c	/^    int j = 0;$/;"	l	language:C
j	scripting.c	/^    int j, argc = lua_gettop(lua);$/;"	l	language:C
j	scripting.c	/^    int j, saved_rc = server.lua_replicate_commands;$/;"	l	language:C
j	scripting.c	/^    int j;$/;"	l	language:C
j	sds.c	/^            int step = 10, j, i;$/;"	l	language:C
j	sds.c	/^    int elements = 0, slots = 5, start = 0, j;$/;"	l	language:C
j	sds.c	/^    int j;$/;"	l	language:C
j	sds.c	/^    int len = sdslen(s), j;$/;"	l	language:C
j	sds.c	/^    size_t j, i, l = sdslen(s);$/;"	l	language:C
j	sentinel.c	/^        int j = 0;$/;"	l	language:C
j	sentinel.c	/^        int j;$/;"	l	language:C
j	sentinel.c	/^    int j = 0;$/;"	l	language:C
j	sentinel.c	/^    int j, changes = 0;$/;"	l	language:C
j	sentinel.c	/^    int j;$/;"	l	language:C
j	sentinel.c	/^    int numlines, j;$/;"	l	language:C
j	sentinel.c	/^    int numslaves = 0, j;$/;"	l	language:C
j	sentinel.c	/^    unsigned int j;$/;"	l	language:C
j	server.c	/^        int *keys, numkeys, j;$/;"	l	language:C
j	server.c	/^        int j;$/;"	l	language:C
j	server.c	/^    int j, numcommands;$/;"	l	language:C
j	server.c	/^    int j;$/;"	l	language:C
j	server.c	/^    unsigned int j;$/;"	l	language:C
j	sha1.c	/^    uint32_t i, j;$/;"	l	language:C
j	slowlog.c	/^            int j;$/;"	l	language:C
j	slowlog.c	/^    int j, slargc = argc;$/;"	l	language:C
j	slowlog.c	/^    int j;$/;"	l	language:C
j	sort.c	/^    int j, dontsort = 0, vectorlen;$/;"	l	language:C
j	sparkline.c	/^    int j;$/;"	l	language:C
j	t_hash.c	/^    int j, deleted = 0, keyremoved = 0;$/;"	l	language:C
j	t_list.c	/^    int j, pushed = 0;$/;"	l	language:C
j	t_list.c	/^    int j;$/;"	l	language:C
j	t_set.c	/^    int j, added = 0;$/;"	l	language:C
j	t_set.c	/^    int j, cardinality = 0;$/;"	l	language:C
j	t_set.c	/^    int j, deleted = 0, keyremoved = 0;$/;"	l	language:C
j	t_set.c	/^    unsigned long j, cardinality = 0;$/;"	l	language:C
j	t_string.c	/^    int j, busykeys = 0;$/;"	l	language:C
j	t_string.c	/^    int j;$/;"	l	language:C
j	t_zset.c	/^    int deleted = 0, keyremoved = 0, j;$/;"	l	language:C
j	t_zset.c	/^    int i, j;$/;"	l	language:C
j	t_zset.c	/^    int j, elements;$/;"	l	language:C
j	t_zset.c	/^    int j;$/;"	l	language:C
j	util.c	/^    unsigned int j;$/;"	l	language:C
j	ziplist.c	/^        int i,j,len,where;$/;"	l	language:C
j	ziplist.c	/^    int i,j,k;$/;"	l	language:C
job	bio.c	/^    struct bio_job *job = zmalloc(sizeof(*job));$/;"	l	language:C
job	bio.c	/^    struct bio_job *job;$/;"	l	language:C
join	sds.c	/^    sds join = sdsempty();$/;"	l	language:C
k	dict.c	/^        uint32_t k = *(uint32_t*)data;$/;"	l	language:C
k	evict.c	/^        int j, k, i, keys_freed = 0;$/;"	l	language:C
k	evict.c	/^    int j, k, count;$/;"	l	language:C
k	hyperloglog.c	/^        uint64_t k;$/;"	l	language:C
k	redis-cli.c	/^            long k;$/;"	l	language:C
k	redis-cli.c	/^    int count = 1000, k;$/;"	l	language:C
k	sort.c	/^    char *p, *f, *k;$/;"	l	language:C
k	ziplist.c	/^    int i,j,k;$/;"	l	language:C
k	zipmap.c	/^    unsigned char *p = zm+1, *k = NULL;$/;"	l	language:C
kb	config.c	/^    int kb = 1024;$/;"	l	language:C
kde	db.c	/^    dictEntry *kde, *de;$/;"	l	language:C
ke	ae_kqueue.c	/^    struct kevent ke;$/;"	l	language:C
keep	quicklist.c	/^        quicklistNode *keep = NULL, *nokeep = NULL;$/;"	l	language:C
keepalive	redis-benchmark.c	/^    int keepalive;$/;"	m	language:C	struct:config	file:	access:public
key	aof.c	/^            robj key, *o;$/;"	l	language:C
key	cluster.c	/^            robj *key = dictGetKey(de);$/;"	l	language:C
key	cluster.c	/^        sds key = c->argv[2]->ptr;$/;"	l	language:C
key	db.c	/^        robj *key = createStringObject(sdskey,sdslen(sdskey));$/;"	l	language:C
key	db.c	/^        sds key = dictGetKey(de);$/;"	l	language:C
key	db.c	/^        sds key;$/;"	l	language:C
key	db.c	/^    robj *key, *val = NULL;$/;"	l	language:C
key	db.c	/^    robj *key;$/;"	l	language:C
key	debug.c	/^            sds key;$/;"	l	language:C
key	debug.c	/^        robj *key, *val;$/;"	l	language:C
key	debug.c	/^        robj *val, *key;$/;"	l	language:C
key	debug.c	/^        sds key;$/;"	l	language:C
key	dict.h	/^    void *key;$/;"	m	language:C	struct:dictEntry	access:public
key	evict.c	/^        sds key;$/;"	l	language:C
key	evict.c	/^    sds key;                    \/* Key name. *\/$/;"	m	language:C	struct:evictionPoolEntry	file:	access:public
key	expire.c	/^        sds key = dictGetKey(de);$/;"	l	language:C
key	expire.c	/^    robj *key = c->argv[1], *param = c->argv[2];$/;"	l	language:C
key	geo.c	/^    robj *key = c->argv[1];$/;"	l	language:C
key	module.c	/^    robj *key;      \/* Key name object. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
key	modules/API.md	/^Return an handle representing a Redis key, so that it is possible$/;"	v	language:C
key	modules/API.md	/^as the value of the key, deleting the old value if any.$/;"	v	language:C
key	modules/API.md	/^the key, returns the moduel type pointer of the value stored at key.$/;"	v	language:C
key	modules/API.md	/^the key, returns the module type low-level value stored at key, as$/;"	v	language:C
key	modules/API.md	/^value of the key, deleting the old value if any.$/;"	v	language:C
key	modules/TYPES.md	/^* A set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the `DEBUG DIGEST` command.$/;"	v	language:C
key	modules/helloworld.c	/^    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],$/;"	l	language:C
key	multi.c	/^    robj *key;$/;"	m	language:C	struct:watchedKey	file:	access:public
key	rdb.c	/^            robj key, *o = dictGetVal(de);$/;"	l	language:C
key	rdb.c	/^        robj *key, *val;$/;"	l	language:C
key	redis-check-rdb.c	/^        robj *key, *val;$/;"	l	language:C
key	redis-check-rdb.c	/^    robj *key;                      \/* Current key we are reading. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
key	redis-cli.c	/^    char key[128];$/;"	l	language:C
key	replication.c	/^    sds key = sdsdup(sha1);$/;"	l	language:C
key	sentinel.c	/^    sds key;$/;"	l	language:C
key	server.h	/^    robj *key;$/;"	m	language:C	struct:readyList	access:public
key	t_hash.c	/^            sds key, value;$/;"	l	language:C
key	t_list.c	/^        robj *key = dictGetKey(de);$/;"	l	language:C
key	t_zset.c	/^    robj *key = c->argv[1];$/;"	l	language:C
key	zipmap.c	/^        unsigned char *key, *value;$/;"	l	language:C
keyCompare	dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	language:C	struct:dictType	access:public
keyDestructor	dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	language:C	struct:dictType	access:public
keyDup	dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	language:C	struct:dictType	access:public
keyHashSlot	cluster.c	/^unsigned int keyHashSlot(char *key, int keylen) {$/;"	f	language:C	signature:(char *key, int keylen)
keyHashSlot	server.h	/^unsigned int keyHashSlot(char *key, int keylen);$/;"	p	language:C	signature:(char *key, int keylen)
key_type	redis-check-rdb.c	/^    int key_type;                   \/* Current key type if != -1. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
keyindex	cluster.c	/^        int margc, *keyindex, numkeys, j;$/;"	l	language:C
keylistDictType	server.c	/^dictType keylistDictType = {$/;"	v	language:C
keyobj	db.c	/^        robj *keyobj;$/;"	l	language:C
keyobj	debug.c	/^            robj *keyobj, *o;$/;"	l	language:C
keyobj	evict.c	/^            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));$/;"	l	language:C
keyobj	expire.c	/^        robj *keyobj = createStringObject(key,sdslen(key));$/;"	l	language:C
keyobj	sort.c	/^    robj *keyobj, *fieldobj = NULL, *o;$/;"	l	language:C
keyptrDictType	server.c	/^dictType keyptrDictType = {$/;"	v	language:C
keyptrDictType	server.h	/^extern dictType keyptrDictType;$/;"	x	language:C
keyremoved	t_hash.c	/^    int j, deleted = 0, keyremoved = 0;$/;"	l	language:C
keyremoved	t_set.c	/^    int j, deleted = 0, keyremoved = 0;$/;"	l	language:C
keyremoved	t_zset.c	/^    int deleted = 0, keyremoved = 0, j;$/;"	l	language:C
keyremoved	t_zset.c	/^    int keyremoved = 0;$/;"	l	language:C
keys	cluster.c	/^        robj **keys;$/;"	l	language:C
keys	db.c	/^    int i, j, num, *keys, found_store = 0;$/;"	l	language:C
keys	db.c	/^    int i, num, *keys;$/;"	l	language:C
keys	db.c	/^    int i, num, first, *keys;$/;"	l	language:C
keys	db.c	/^    int j, i = 0, last, *keys;$/;"	l	language:C
keys	db.c	/^    list *keys = listCreate();$/;"	l	language:C
keys	db.c	/^    list *keys = pd[0];$/;"	l	language:C
keys	debug.c	/^        long keys, j;$/;"	l	language:C
keys	evict.c	/^                unsigned long total_keys = 0, keys;$/;"	l	language:C
keys	modules/API.md	/^keys, since it was flagged as "getkeys-api" during the registration,$/;"	v	language:C
keys	modules/API.md	/^order to report keys, like in the following example:$/;"	v	language:C
keys	redis-check-rdb.c	/^    unsigned long keys;             \/* Number of keys processed. *\/$/;"	m	language:C	struct:__anon23	file:	access:public
keys	redis-cli.c	/^    int j, got_comma, keys;$/;"	l	language:C
keys	redis-cli.c	/^    redisReply *reply, *keys;$/;"	l	language:C
keys	server.c	/^            long long keys, vkeys;$/;"	l	language:C
keys	server.c	/^        int *keys, numkeys, j;$/;"	l	language:C
keys	server.h	/^    dict *keys;             \/* The keys we are waiting to terminate a blocking$/;"	m	language:C	struct:blockingState	access:public
keysCommand	db.c	/^void keysCommand(client *c) {$/;"	f	language:C	signature:(client *c)
keysCommand	server.h	/^void keysCommand(client *c);$/;"	p	language:C	signature:(client *c)
keys_count	module.c	/^    int keys_count;$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
keys_freed	evict.c	/^        int j, k, i, keys_freed = 0;$/;"	l	language:C
keys_pos	module.c	/^    int *keys_pos;$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
keysds	db.c	/^        sds keysds = dictGetKey(de);$/;"	l	language:C
keysize	redis-benchmark.c	/^    int keysize;$/;"	m	language:C	struct:config	file:	access:public
keyspaceEventsFlagsToString	notify.c	/^sds keyspaceEventsFlagsToString(int flags) {$/;"	f	language:C	signature:(int flags)
keyspaceEventsFlagsToString	server.h	/^sds keyspaceEventsFlagsToString(int flags);$/;"	p	language:C	signature:(int flags)
keyspaceEventsStringToFlags	notify.c	/^int keyspaceEventsStringToFlags(char *classes) {$/;"	f	language:C	signature:(char *classes)
keyspaceEventsStringToFlags	server.h	/^int keyspaceEventsStringToFlags(char *classes);$/;"	p	language:C	signature:(char *classes)
keystep	server.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	language:C	struct:redisCommand	access:public
keystr	aof.c	/^            sds keystr;$/;"	l	language:C
keystr	rdb.c	/^            sds keystr = dictGetKey(de);$/;"	l	language:C
keytype	modules/helloworld.c	/^    int keytype = RedisModule_KeyType(key);$/;"	l	language:C
killed	networking.c	/^        int killed = 0, close_this_client = 0;$/;"	l	language:C
kind	modules/TYPES.md	/^is empty, if it contains a value of the right kind, and so forth. So$/;"	v	language:C
klen	evict.c	/^        int klen = sdslen(key);$/;"	l	language:C
klen	zipmap.c	/^        unsigned int klen, vlen;$/;"	l	language:C
kobj	db.c	/^        robj *kobj = listNodeValue(node);$/;"	l	language:C
kp	module.c	/^    RedisModuleKey *kp;$/;"	l	language:C
kqfd	ae_kqueue.c	/^    int kqfd;$/;"	m	language:C	struct:aeApiState	file:	access:public
kv	cluster.c	/^    robj **kv = NULL; \/* Key names. *\/$/;"	l	language:C
l	bitops.c	/^    unsigned long *l;$/;"	l	language:C
l	cluster.c	/^    list *l = failing->fail_reports;$/;"	l	language:C
l	cluster.c	/^    list *l = node->fail_reports;$/;"	l	language:C
l	config.c	/^        list *l = dictGetVal(de);$/;"	l	language:C
l	config.c	/^    list *l = dictFetchValue(state->option_to_line,o);$/;"	l	language:C
l	config.c	/^    list *l = dictFetchValue(state->option_to_line,option);$/;"	l	language:C
l	dict.c	/^    size_t l = 0;$/;"	l	language:C
l	dict.c	/^    size_t l;$/;"	l	language:C
l	networking.c	/^        list *l = (c->flags & CLIENT_MONITOR) ? server.monitors : server.slaves;$/;"	l	language:C
l	networking.c	/^    size_t l, j;$/;"	l	language:C
l	object.c	/^    quicklist *l = quicklistCreate();$/;"	l	language:C
l	pubsub.c	/^            list *l = dictFetchValue(server.pubsub_channels,c->argv[j]);$/;"	l	language:C
l	rdb.c	/^            size_t l = intsetBlobLen((intset*)o->ptr);$/;"	l	language:C
l	rdb.c	/^            size_t l = ziplistBlobLen((unsigned char*)o->ptr);$/;"	l	language:C
l	redis-benchmark.c	/^    int l = strlen(name);$/;"	l	language:C
l	redis-cli.c	/^    long l;$/;"	l	language:C
l	scripting.c	/^      int l = luaL_checkint(L, 1);$/;"	l	language:C
l	scripting.c	/^    int l = 0; \/* Stack level. *\/$/;"	l	language:C
l	sds.c	/^        size_t l;$/;"	l	language:C
l	sds.c	/^    size_t j, i, l = sdslen(s);$/;"	l	language:C
l	sds.c	/^    size_t l;$/;"	l	language:C
l	sentinel.c	/^        sds l = lines[j];$/;"	l	language:C
l	sha1.c	/^        uint32_t l[16];$/;"	m	language:C	union:__anon38	file:	access:public
l	t_list.c	/^        list *l;$/;"	l	language:C
l	t_list.c	/^    list *l;$/;"	l	language:C
l	t_set.c	/^    long l;$/;"	l	language:C
l	util.c	/^        unsigned int l = len;$/;"	l	language:C
l	util.c	/^    size_t l;$/;"	l	language:C
l	zipmap.c	/^    unsigned int l = zipmapDecodeLength(p);$/;"	l	language:C
l	zipmap.c	/^    unsigned int l = zipmapRawKeyLength(p);$/;"	l	language:C
l	zipmap.c	/^    unsigned int l,llen;$/;"	l	language:C
l	zipmap.c	/^    unsigned int l;$/;"	l	language:C
l	zmalloc.c	/^    size_t l = strlen(s)+1;$/;"	l	language:C
l1	memtest.c	/^    unsigned long off, w, *l1, *l2, v;$/;"	l	language:C
l1	memtest.c	/^    unsigned long off, w, *l1, *l2;$/;"	l	language:C
l1	memtest.c	/^    unsigned long w, *l1, *l2;$/;"	l	language:C
l1	sds.c	/^    size_t l1, l2, minlen;$/;"	l	language:C
l1	server.c	/^    int l1,l2;$/;"	l	language:C
l2	memtest.c	/^    unsigned long off, w, *l1, *l2, v;$/;"	l	language:C
l2	memtest.c	/^    unsigned long off, w, *l1, *l2;$/;"	l	language:C
l2	memtest.c	/^    unsigned long w, *l1, *l2;$/;"	l	language:C
l2	sds.c	/^    size_t l1, l2, minlen;$/;"	l	language:C
l2	server.c	/^    int l1,l2;$/;"	l	language:C
label	sparkline.h	/^    char *label;$/;"	m	language:C	struct:sample	access:public
label_char	sparkline.c	/^                    int label_char = row - rows - label_margin_top;$/;"	l	language:C
label_len	sparkline.c	/^                    int label_len = strlen(s->label);$/;"	l	language:C
label_margin_top	sparkline.c	/^static int label_margin_top = 1;$/;"	v	language:C	file:
labels	sparkline.h	/^    int labels;$/;"	m	language:C	struct:sequence	access:public
lag	replication.c	/^        time_t lag = server.unixtime - slave->repl_ack_time;$/;"	l	language:C
lag	server.c	/^                long lag = 0;$/;"	l	language:C
last	db.c	/^    int j, i = 0, last, *keys;$/;"	l	language:C
last	hyperloglog.c	/^    int last = first+span-1; \/* Last register covered by the sequence. *\/$/;"	l	language:C
last	latency.c	/^        int last = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;$/;"	l	language:C
lastTime	ae.h	/^    time_t lastTime;     \/* Used to detect system clock skew *\/$/;"	m	language:C	struct:aeEventLoop	access:public
lastVoteEpoch	cluster.h	/^    uint64_t lastVoteEpoch;     \/* Epoch of the last vote granted. *\/$/;"	m	language:C	struct:clusterState	access:public
last_avail_time	sentinel.c	/^    mstime_t last_avail_time; \/* Last time the instance replied to ping with$/;"	m	language:C	struct:instanceLink	file:	access:public
last_cmd_type	redis-cli.c	/^    int last_cmd_type;$/;"	m	language:C	struct:config	file:	access:public
last_dbid	cluster.c	/^    long last_dbid;$/;"	m	language:C	struct:migrateCachedSocket	file:	access:public
last_fast_cycle	expire.c	/^    static long long last_fast_cycle = 0; \/* When last fast cycle ran. *\/$/;"	l	language:C	file:
last_hello_time	sentinel.c	/^    mstime_t last_hello_time; \/* Only used if SRI_SENTINEL is set. Last time$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
last_master_down_reply_time	sentinel.c	/^    mstime_t last_master_down_reply_time; \/* Time of last reply to$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
last_numreplicas	replication.c	/^    int last_numreplicas = 0;$/;"	l	language:C
last_offset	replication.c	/^    long long last_offset = 0;$/;"	l	language:C
last_ping_time	sentinel.c	/^    mstime_t last_ping_time;  \/* Time at which we sent the last ping. This is$/;"	m	language:C	struct:instanceLink	file:	access:public
last_pong_time	sentinel.c	/^    mstime_t last_pong_time;  \/* Last time the instance replied to ping,$/;"	m	language:C	struct:instanceLink	file:	access:public
last_processed	geo.c	/^    unsigned int i, count = 0, last_processed = 0;$/;"	l	language:C
last_pub_time	sentinel.c	/^    mstime_t last_pub_time;   \/* Last time we sent hello via Pub\/Sub. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
last_read_time	redis-cli.c	/^    time_t last_read_time = time(NULL);$/;"	l	language:C
last_reconn_time	sentinel.c	/^    mstime_t last_reconn_time;  \/* Last reconnection attempt performed when$/;"	m	language:C	struct:instanceLink	file:	access:public
last_sample_count	server.h	/^        long long last_sample_count;\/* Count in last sample *\/$/;"	m	language:C	struct:redisServer::__anon29	access:public
last_sample_time	server.h	/^        long long last_sample_time; \/* Timestamp of last sample in ms *\/$/;"	m	language:C	struct:redisServer::__anon29	access:public
last_use_time	cluster.c	/^    time_t last_use_time;$/;"	m	language:C	struct:migrateCachedSocket	file:	access:public
last_write_error_log	aof.c	/^        static time_t last_write_error_log = 0;$/;"	l	language:C	file:
lastarg	redis-benchmark.c	/^    int lastarg;$/;"	l	language:C
lastarg	redis-cli.c	/^        int lastarg = i==argc-1;$/;"	l	language:C
lastbgsave_status	server.h	/^    int lastbgsave_status;          \/* C_OK or C_ERR *\/$/;"	m	language:C	struct:redisServer	access:public
lastbgsave_try	server.h	/^    time_t lastbgsave_try;          \/* Unix time of last attempted bgsave *\/$/;"	m	language:C	struct:redisServer	access:public
lastbytes	replication.c	/^    static char lastbytes[CONFIG_RUN_ID_SIZE];$/;"	l	language:C	file:
lastcmd	server.h	/^    struct redisCommand *cmd, *lastcmd;  \/* Last command executed. *\/$/;"	m	language:C	struct:client	typeref:struct:client::	access:public
lasterr_time	redis-benchmark.c	/^                    static time_t lasterr_time = 0;$/;"	l	language:C	file:
lastinteraction	server.h	/^    time_t lastinteraction; \/* Time of the last interaction, used for timeout *\/$/;"	m	language:C	struct:client	access:public
lastkey	server.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	language:C	struct:redisCommand	access:public
lastlog_time	cluster.c	/^    static time_t lastlog_time = 0;$/;"	l	language:C	file:
lastsave	server.h	/^    time_t lastsave;                \/* Unix time of last successful save *\/$/;"	m	language:C	struct:redisServer	access:public
lastsaveCommand	db.c	/^void lastsaveCommand(client *c) {$/;"	f	language:C	signature:(client *c)
lastsaveCommand	server.h	/^void lastsaveCommand(client *c);$/;"	p	language:C	signature:(client *c)
lat1r	geohash_helper.c	/^    double lat1r, lon1r, lat2r, lon2r, u, v;$/;"	l	language:C
lat2r	geohash_helper.c	/^    double lat1r, lon1r, lat2r, lon2r, u, v;$/;"	l	language:C
lat_offset	geohash.c	/^    double lat_offset =$/;"	l	language:C
lat_range	geohash_helper.c	/^    GeoHashRange long_range, lat_range;$/;"	l	language:C
lat_scale	geohash.c	/^    double lat_scale = lat_range.max - lat_range.min;$/;"	l	language:C
latency	aof.c	/^        mstime_t latency;$/;"	l	language:C
latency	aof.c	/^    mstime_t latency;$/;"	l	language:C
latency	evict.c	/^    mstime_t latency, eviction_latency;$/;"	l	language:C
latency	latency.h	/^    uint32_t latency; \/* Latency in milliseconds. *\/$/;"	m	language:C	struct:latencySample	access:public
latency	rdb.c	/^        mstime_t latency;$/;"	l	language:C
latency	redis-benchmark.c	/^    long long *latency;$/;"	m	language:C	struct:config	file:	access:public
latency	redis-benchmark.c	/^    long long latency;      \/* Request latency *\/$/;"	m	language:C	struct:_client	file:	access:public
latency	redis-cli.c	/^        long long start, end, latency;$/;"	l	language:C
latency	redis-cli.c	/^    long long start, latency, count = 0;$/;"	l	language:C
latency	redis-cli.c	/^    long long start, latency, min = 0, max = 0, tot = 0, count = 0;$/;"	l	language:C
latencyAddSample	latency.c	/^void latencyAddSample(char *event, mstime_t latency) {$/;"	f	language:C	signature:(char *event, mstime_t latency)
latencyAddSample	latency.h	/^void latencyAddSample(char *event, mstime_t latency);$/;"	p	language:C	signature:(char *event, mstime_t latency)
latencyAddSampleIfNeeded	latency.h	/^#define latencyAddSampleIfNeeded(/;"	d	language:C
latencyCommand	latency.c	/^void latencyCommand(client *c) {$/;"	f	language:C	signature:(client *c)
latencyCommand	server.h	/^void latencyCommand(client *c);$/;"	p	language:C	signature:(client *c)
latencyCommandGenSparkeline	latency.c	/^sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {$/;"	f	language:C	signature:(char *event, struct latencyTimeSeries *ts)
latencyCommandReplyWithLatestEvents	latency.c	/^void latencyCommandReplyWithLatestEvents(client *c) {$/;"	f	language:C	signature:(client *c)
latencyCommandReplyWithSamples	latency.c	/^void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {$/;"	f	language:C	signature:(client *c, struct latencyTimeSeries *ts)
latencyDistMode	redis-cli.c	/^static void latencyDistMode(void) {$/;"	f	language:C	file:	signature:(void)
latencyEndMonitor	latency.h	/^#define latencyEndMonitor(/;"	d	language:C
latencyMode	redis-cli.c	/^static void latencyMode(void) {$/;"	f	language:C	file:	signature:(void)
latencyMonitorInit	latency.c	/^void latencyMonitorInit(void) {$/;"	f	language:C	signature:(void)
latencyMonitorInit	latency.h	/^void latencyMonitorInit(void);$/;"	p	language:C	signature:(void)
latencyRemoveNestedEvent	latency.h	/^#define latencyRemoveNestedEvent(/;"	d	language:C
latencyResetEvent	latency.c	/^int latencyResetEvent(char *event_to_reset) {$/;"	f	language:C	signature:(char *event_to_reset)
latencySample	latency.h	/^struct latencySample {$/;"	s	language:C
latencySample::latency	latency.h	/^    uint32_t latency; \/* Latency in milliseconds. *\/$/;"	m	language:C	struct:latencySample	access:public
latencySample::time	latency.h	/^    int32_t time; \/* We don't use time_t to force 4 bytes usage everywhere. *\/$/;"	m	language:C	struct:latencySample	access:public
latencyStartMonitor	latency.h	/^#define latencyStartMonitor(/;"	d	language:C
latencyStats	latency.h	/^struct latencyStats {$/;"	s	language:C
latencyStats::all_time_high	latency.h	/^    uint32_t all_time_high; \/* Absolute max observed since latest reset. *\/$/;"	m	language:C	struct:latencyStats	access:public
latencyStats::avg	latency.h	/^    uint32_t avg;           \/* Average of current samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
latencyStats::mad	latency.h	/^    uint32_t mad;           \/* Mean absolute deviation. *\/$/;"	m	language:C	struct:latencyStats	access:public
latencyStats::max	latency.h	/^    uint32_t max;           \/* Max of current samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
latencyStats::min	latency.h	/^    uint32_t min;           \/* Min of current samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
latencyStats::period	latency.h	/^    time_t period;          \/* Number of seconds since first event and now. *\/$/;"	m	language:C	struct:latencyStats	access:public
latencyStats::samples	latency.h	/^    uint32_t samples;       \/* Number of non-zero samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
latencyTimeSeries	latency.h	/^struct latencyTimeSeries {$/;"	s	language:C
latencyTimeSeries::idx	latency.h	/^    int idx; \/* Index of the next sample to store. *\/$/;"	m	language:C	struct:latencyTimeSeries	access:public
latencyTimeSeries::max	latency.h	/^    uint32_t max; \/* Max latency observed for this event. *\/$/;"	m	language:C	struct:latencyTimeSeries	access:public
latencyTimeSeries::samples	latency.h	/^    struct latencySample samples[LATENCY_TS_LEN]; \/* Latest history. *\/$/;"	m	language:C	struct:latencyTimeSeries	typeref:struct:latencyTimeSeries::latencySample	access:public
latencyTimeSeriesDictType	latency.c	/^dictType latencyTimeSeriesDictType = {$/;"	v	language:C
latency_dist_mode	redis-cli.c	/^    int latency_dist_mode;$/;"	m	language:C	struct:config	file:	access:public
latency_event	server.c	/^        char *latency_event = (c->cmd->flags & CMD_FAST) ?$/;"	l	language:C
latency_events	server.h	/^    dict *latency_events;$/;"	m	language:C	struct:redisServer	access:public
latency_history	redis-cli.c	/^    int latency_history;$/;"	m	language:C	struct:config	file:	access:public
latency_mode	redis-cli.c	/^    int latency_mode;$/;"	m	language:C	struct:config	file:	access:public
latency_monitor_threshold	server.h	/^    long long latency_monitor_threshold;$/;"	m	language:C	struct:redisServer	access:public
latitude	geo.h	/^    double latitude;$/;"	m	language:C	struct:geoPoint	access:public
latitude	geohash.h	/^    GeoHashRange latitude;$/;"	m	language:C	struct:__anon16	access:public
latr	geohash_helper.c	/^    double lonr, latr;$/;"	l	language:C
lazyfreeFreeDatabaseFromBioThread	bio.c	/^void lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2);$/;"	p	language:C	file:	signature:(dict *ht1, dict *ht2)
lazyfreeFreeDatabaseFromBioThread	lazyfree.c	/^void lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2) {$/;"	f	language:C	signature:(dict *ht1, dict *ht2)
lazyfreeFreeObjectFromBioThread	bio.c	/^void lazyfreeFreeObjectFromBioThread(robj *o);$/;"	p	language:C	file:	signature:(robj *o)
lazyfreeFreeObjectFromBioThread	lazyfree.c	/^void lazyfreeFreeObjectFromBioThread(robj *o) {$/;"	f	language:C	signature:(robj *o)
lazyfreeFreeSlotsMapFromBioThread	bio.c	/^void lazyfreeFreeSlotsMapFromBioThread(zskiplist *sl);$/;"	p	language:C	file:	signature:(zskiplist *sl)
lazyfreeFreeSlotsMapFromBioThread	lazyfree.c	/^void lazyfreeFreeSlotsMapFromBioThread(zskiplist *sl) {$/;"	f	language:C	signature:(zskiplist *sl)
lazyfreeGetFreeEffort	lazyfree.c	/^size_t lazyfreeGetFreeEffort(robj *obj) {$/;"	f	language:C	signature:(robj *obj)
lazyfreeGetPendingObjectsCount	lazyfree.c	/^size_t lazyfreeGetPendingObjectsCount(void) {$/;"	f	language:C	signature:(void)
lazyfreeGetPendingObjectsCount	server.h	/^size_t lazyfreeGetPendingObjectsCount(void);$/;"	p	language:C	signature:(void)
lazyfree_lazy_eviction	server.h	/^    int lazyfree_lazy_eviction;$/;"	m	language:C	struct:redisServer	access:public
lazyfree_lazy_expire	server.h	/^    int lazyfree_lazy_expire;$/;"	m	language:C	struct:redisServer	access:public
lazyfree_lazy_server_del	server.h	/^    int lazyfree_lazy_server_del;$/;"	m	language:C	struct:redisServer	access:public
lazyfree_objects	lazyfree.c	/^static size_t lazyfree_objects = 0;$/;"	v	language:C	file:
lazyfree_objects_mutex	lazyfree.c	/^pthread_mutex_t lazyfree_objects_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	language:C
lbuf	rio.c	/^    char lbuf[32];$/;"	l	language:C
ld2string	util.c	/^int ld2string(char *buf, size_t len, long double value, int humanfriendly) {$/;"	f	language:C	signature:(char *buf, size_t len, long double value, int humanfriendly)
ld2string	util.h	/^int ld2string(char *buf, size_t len, long double value, int humanfriendly);$/;"	p	language:C	signature:(char *buf, size_t len, long double value, int humanfriendly)
ldb	scripting.c	/^} ldb;$/;"	v	language:C	typeref:struct:ldbState
ldbAddBreakpoint	scripting.c	/^int ldbAddBreakpoint(int line) {$/;"	f	language:C	signature:(int line)
ldbBreak	scripting.c	/^void ldbBreak(sds *argv, int argc) {$/;"	f	language:C	signature:(sds *argv, int argc)
ldbCatStackValue	scripting.c	/^sds ldbCatStackValue(sds s, lua_State *lua, int idx) {$/;"	f	language:C	signature:(sds s, lua_State *lua, int idx)
ldbCatStackValue	scripting.c	/^sds ldbCatStackValue(sds s, lua_State *lua, int idx);$/;"	p	language:C	file:	signature:(sds s, lua_State *lua, int idx)
ldbCatStackValueRec	scripting.c	/^sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {$/;"	f	language:C	signature:(sds s, lua_State *lua, int idx, int level)
ldbDelBreakpoint	scripting.c	/^int ldbDelBreakpoint(int line) {$/;"	f	language:C	signature:(int line)
ldbDisable	scripting.c	/^void ldbDisable(client *c) {$/;"	f	language:C	signature:(client *c)
ldbDisable	scripting.c	/^void ldbDisable(client *c);$/;"	p	language:C	file:	signature:(client *c)
ldbEnable	scripting.c	/^void ldbEnable(client *c) {$/;"	f	language:C	signature:(client *c)
ldbEnable	scripting.c	/^void ldbEnable(client *c);$/;"	p	language:C	file:	signature:(client *c)
ldbEndSession	scripting.c	/^void ldbEndSession(client *c) {$/;"	f	language:C	signature:(client *c)
ldbEval	scripting.c	/^void ldbEval(lua_State *lua, sds *argv, int argc) {$/;"	f	language:C	signature:(lua_State *lua, sds *argv, int argc)
ldbFlushLog	scripting.c	/^void ldbFlushLog(list *log) {$/;"	f	language:C	signature:(list *log)
ldbGetSourceLine	scripting.c	/^char *ldbGetSourceLine(int line) {$/;"	f	language:C	signature:(int line)
ldbInit	scripting.c	/^void ldbInit(void) {$/;"	f	language:C	signature:(void)
ldbInit	scripting.c	/^void ldbInit(void);$/;"	p	language:C	file:	signature:(void)
ldbIsBreakpoint	scripting.c	/^int ldbIsBreakpoint(int line) {$/;"	f	language:C	signature:(int line)
ldbKillForkedSessions	scripting.c	/^void ldbKillForkedSessions(void) {$/;"	f	language:C	signature:(void)
ldbKillForkedSessions	server.h	/^void ldbKillForkedSessions(void);$/;"	p	language:C	signature:(void)
ldbList	scripting.c	/^void ldbList(int around, int context) {$/;"	f	language:C	signature:(int around, int context)
ldbLog	scripting.c	/^void ldbLog(sds entry) {$/;"	f	language:C	signature:(sds entry)
ldbLog	scripting.c	/^void ldbLog(sds entry);$/;"	p	language:C	file:	signature:(sds entry)
ldbLogRedisReply	scripting.c	/^void ldbLogRedisReply(char *reply) {$/;"	f	language:C	signature:(char *reply)
ldbLogRedisReply	scripting.c	/^void ldbLogRedisReply(char *reply);$/;"	p	language:C	file:	signature:(char *reply)
ldbLogSourceLine	scripting.c	/^void ldbLogSourceLine(int lnum) {$/;"	f	language:C	signature:(int lnum)
ldbLogStackValue	scripting.c	/^void ldbLogStackValue(lua_State *lua, char *prefix) {$/;"	f	language:C	signature:(lua_State *lua, char *prefix)
ldbLogWithMaxLen	scripting.c	/^void ldbLogWithMaxLen(sds entry) {$/;"	f	language:C	signature:(sds entry)
ldbMaxlen	scripting.c	/^void ldbMaxlen(sds *argv, int argc) {$/;"	f	language:C	signature:(sds *argv, int argc)
ldbPendingChildren	scripting.c	/^int ldbPendingChildren(void) {$/;"	f	language:C	signature:(void)
ldbPendingChildren	server.h	/^int ldbPendingChildren(void);$/;"	p	language:C	signature:(void)
ldbPrint	scripting.c	/^void ldbPrint(lua_State *lua, char *varname) {$/;"	f	language:C	signature:(lua_State *lua, char *varname)
ldbPrintAll	scripting.c	/^void ldbPrintAll(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
ldbRedis	scripting.c	/^void ldbRedis(lua_State *lua, sds *argv, int argc) {$/;"	f	language:C	signature:(lua_State *lua, sds *argv, int argc)
ldbRedisProtocolToHuman	scripting.c	/^char *ldbRedisProtocolToHuman(sds *o, char *reply) {$/;"	f	language:C	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_Bulk	scripting.c	/^char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {$/;"	f	language:C	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_Bulk	scripting.c	/^char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);$/;"	p	language:C	file:	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_Int	scripting.c	/^char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {$/;"	f	language:C	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_Int	scripting.c	/^char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);$/;"	p	language:C	file:	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_MultiBulk	scripting.c	/^char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {$/;"	f	language:C	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_MultiBulk	scripting.c	/^char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);$/;"	p	language:C	file:	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_Status	scripting.c	/^char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {$/;"	f	language:C	signature:(sds *o, char *reply)
ldbRedisProtocolToHuman_Status	scripting.c	/^char *ldbRedisProtocolToHuman_Status(sds *o, char *reply);$/;"	p	language:C	file:	signature:(sds *o, char *reply)
ldbRemoveChild	scripting.c	/^int ldbRemoveChild(pid_t pid) {$/;"	f	language:C	signature:(pid_t pid)
ldbRemoveChild	server.h	/^int ldbRemoveChild(pid_t pid);$/;"	p	language:C	signature:(pid_t pid)
ldbRepl	scripting.c	/^int ldbRepl(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
ldbReplParseCommand	scripting.c	/^sds *ldbReplParseCommand(int *argcp) {$/;"	f	language:C	signature:(int *argcp)
ldbSendLogs	scripting.c	/^void ldbSendLogs(void) {$/;"	f	language:C	signature:(void)
ldbStartSession	scripting.c	/^int ldbStartSession(client *c) {$/;"	f	language:C	signature:(client *c)
ldbState	scripting.c	/^struct ldbState {$/;"	s	language:C	file:
ldbState::active	scripting.c	/^    int active; \/* Are we debugging EVAL right now? *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::bp	scripting.c	/^    int bp[LDB_BREAKPOINTS_MAX]; \/* An array of breakpoints line numbers. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::bpcount	scripting.c	/^    int bpcount; \/* Number of valid entries inside bp. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::cbuf	scripting.c	/^    sds cbuf;   \/* Debugger client command buffer. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::children	scripting.c	/^    list *children; \/* All forked debugging sessions pids. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::currentline	scripting.c	/^    int currentline;    \/* Current line number. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::fd	scripting.c	/^    int fd;     \/* Socket of the debugging client. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::forked	scripting.c	/^    int forked; \/* Is this a fork()ed debugging session? *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::lines	scripting.c	/^    int lines;  \/* Number of lines in 'src'. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::logs	scripting.c	/^    list *logs; \/* List of messages to send to the client. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::luabp	scripting.c	/^    int luabp;  \/* Stop at next line because redis.breakpoint() was called. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::maxlen	scripting.c	/^    size_t maxlen;  \/* Max var dump \/ reply length. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::maxlen_hint_sent	scripting.c	/^    int maxlen_hint_sent; \/* Did we already hint about "set maxlen"? *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::src	scripting.c	/^    sds *src;   \/* Lua script source code split by line. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::step	scripting.c	/^    int step;   \/* Stop at next line ragardless of breakpoints. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbState::traces	scripting.c	/^    list *traces; \/* Messages about Redis commands executed since last stop.*\/$/;"	m	language:C	struct:ldbState	file:	access:public
ldbTrace	scripting.c	/^void ldbTrace(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
ldt	db.c	/^                unsigned long ldt = val->lru >> 8;$/;"	l	language:C
ldt	evict.c	/^    unsigned long ldt = o->lru >> 8;$/;"	l	language:C
leader	sentinel.c	/^        char *leader = NULL;$/;"	l	language:C
leader	sentinel.c	/^    char *leader;       \/* If this is a master instance, this is the runid of$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
leader	sentinel.c	/^    char *leader;$/;"	l	language:C
leaderVotesDictType	sentinel.c	/^dictType leaderVotesDictType = {$/;"	v	language:C
leader_epoch	sentinel.c	/^        uint64_t leader_epoch = 0;$/;"	l	language:C
leader_epoch	sentinel.c	/^    uint64_t leader_epoch; \/* Epoch of the 'leader' field. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
leader_epoch	sentinel.c	/^    uint64_t leader_epoch;$/;"	l	language:C
left	memtest.c	/^    size_t left = bytes;$/;"	l	language:C
left	module.c	/^    size_t left = b ? b->size - b->used : 0;$/;"	l	language:C
left	replication.c	/^    off_t left;$/;"	l	language:C
leftargs	sort.c	/^        int leftargs = c->argc-j-1;$/;"	l	language:C
len	adlist.c	/^    unsigned long len;$/;"	l	language:C
len	adlist.h	/^    unsigned long len;$/;"	m	language:C	struct:list	access:public
len	aof.c	/^        unsigned long len;$/;"	l	language:C
len	aof.c	/^    int len, j;$/;"	l	language:C
len	bitops.c	/^    unsigned long *len, maxlen = 0; \/* Array of length of src strings,$/;"	l	language:C
len	db.c	/^                int len;$/;"	l	language:C
len	hyperloglog.c	/^                int len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+1);$/;"	l	language:C
len	hyperloglog.c	/^    int len;$/;"	l	language:C
len	intset.c	/^        uint32_t len = intrev32ifbe(is->length);$/;"	l	language:C
len	lazyfree.c	/^    size_t len = sl->length;$/;"	l	language:C
len	lzf_c.c	/^          unsigned int len = 2;$/;"	l	language:C
len	lzf_d.c	/^          unsigned int len = ctrl >> 5;$/;"	l	language:C
len	memtest.c	/^        size_t len = (left > sizeof(backup)) ? sizeof(backup) : left;$/;"	l	language:C
len	module.c	/^            size_t len = va_arg(ap,size_t);$/;"	l	language:C
len	module.c	/^        int len = ll2string(buf,sizeof(buf),reply->val.ll);$/;"	l	language:C
len	module.c	/^    size_t len = ll2string(buf,sizeof(buf),ll);$/;"	l	language:C
len	module.c	/^    size_t len;     \/* Len of strings or num of elements of arrays. *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
len	modules/INTRO.md	/^    size_t len;$/;"	v	language:C
len	modules/hellotype.c	/^    size_t len; \/* Number of elements added. *\/$/;"	m	language:C	struct:HelloTypeObject	file:	access:public
len	modules/helloworld.c	/^        size_t len, j;$/;"	l	language:C
len	modules/helloworld.c	/^    long long len = RedisModule_CallReplyInteger(reply);$/;"	l	language:C
len	modules/helloworld.c	/^    size_t len = RedisModule_ValueLength(srckey);$/;"	l	language:C
len	networking.c	/^            int len;$/;"	l	language:C
len	networking.c	/^        int j, len = sdslen(c->argv[2]->ptr);$/;"	l	language:C
len	networking.c	/^    int len;$/;"	l	language:C
len	networking.c	/^    sds len, next;$/;"	l	language:C
len	networking.c	/^    size_t len;$/;"	l	language:C
len	notify.c	/^    int len = -1;$/;"	l	language:C
len	object.c	/^    int len = ld2string(buf,sizeof(buf),value,humanfriendly);$/;"	l	language:C
len	object.c	/^    size_t len;$/;"	l	language:C
len	quicklist.c	/^    unsigned long len;$/;"	l	language:C
len	quicklist.h	/^    unsigned int len;           \/* number of quicklistNodes *\/$/;"	m	language:C	struct:quicklist	access:public
len	rdb.c	/^            size_t len = sdslen(dec->ptr);$/;"	l	language:C
len	rdb.c	/^            uint64_t *len = msg;$/;"	l	language:C
len	rdb.c	/^        int len = ll2string(buf,sizeof(buf),val);$/;"	l	language:C
len	rdb.c	/^        size_t len;$/;"	l	language:C
len	rdb.c	/^        uint32_t len;$/;"	l	language:C
len	rdb.c	/^        uint64_t len;$/;"	l	language:C
len	rdb.c	/^    int len;$/;"	l	language:C
len	rdb.c	/^    size_t len;$/;"	l	language:C
len	rdb.c	/^    ssize_t len = rdbSaveObject(NULL,o);$/;"	l	language:C
len	rdb.c	/^    uint64_t len, clen;$/;"	l	language:C
len	rdb.c	/^    uint64_t len;$/;"	l	language:C
len	rdb.c	/^    unsigned char len;$/;"	l	language:C
len	redis-benchmark.c	/^        int len = redisFormatCommand(&buf, "AUTH %s", config.auth);$/;"	l	language:C
len	redis-benchmark.c	/^    int len;$/;"	l	language:C
len	redis-check-aof.c	/^    long len;$/;"	l	language:C
len	redis-cli.c	/^        int len = strlen(line);$/;"	l	language:C
len	redis-cli.c	/^    int i, j, len;$/;"	l	language:C
len	redis-cli.c	/^    int i, len, pos = 0;$/;"	l	language:C
len	redis-cli.c	/^    int len;$/;"	l	language:C
len	replication.c	/^    int j, len;$/;"	l	language:C
len	replication.c	/^    long long j, skip, len;$/;"	l	language:C
len	replication.c	/^    size_t len;$/;"	l	language:C
len	scripting.c	/^        size_t len;$/;"	l	language:C
len	scripting.c	/^    size_t len;$/;"	l	language:C
len	sds.c	/^    int len = sdslen(s), j;$/;"	l	language:C
len	sds.c	/^    int len = sdsll2str(buf,value);$/;"	l	language:C
len	sds.c	/^    size_t len = sdslen(s);$/;"	l	language:C
len	sds.c	/^    size_t len, newlen;$/;"	l	language:C
len	sds.c	/^    size_t len;$/;"	l	language:C
len	sds.c	/^    size_t newlen, len = sdslen(s);$/;"	l	language:C
len	sds.h	/^    uint16_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr16	access:public
len	sds.h	/^    uint32_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr32	access:public
len	sds.h	/^    uint64_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr64	access:public
len	sds.h	/^    uint8_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr8	access:public
len	server.c	/^            int len;$/;"	l	language:C
len	setproctitle.c	/^	int len, error;$/;"	l	language:C
len	t_hash.c	/^    int len = ld2string(buf,sizeof(buf),value,1);$/;"	l	language:C
len	t_hash.c	/^    size_t len = 0;$/;"	l	language:C
len	t_list.c	/^        size_t len = sdslen(str);$/;"	l	language:C
len	t_list.c	/^        size_t len = sdslen(value->ptr);$/;"	l	language:C
len	ziplist.c	/^        int i,j,len,where;$/;"	l	language:C
len	ziplist.c	/^        int i,len;$/;"	l	language:C
len	ziplist.c	/^        unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
len	ziplist.c	/^    int len = min+rand()%(max-min+1);$/;"	l	language:C
len	ziplist.c	/^    int len = ziplistLen(zl);$/;"	l	language:C
len	ziplist.c	/^    unsigned char len = 1, buf[5];$/;"	l	language:C
len	ziplist.c	/^    unsigned int len = 0;$/;"	l	language:C
len	ziplist.c	/^    unsigned int lensize, len;$/;"	m	language:C	struct:zlentry	file:	access:public
len	ziplist.c	/^    unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
len	zipmap.c	/^    unsigned int len = *p;$/;"	l	language:C
len	zipmap.c	/^    unsigned int len = 0;$/;"	l	language:C
len	zmalloc.c	/^    size_t len = sizeof(size);$/;"	l	language:C
length	intset.c	/^    int length = intrev32ifbe(is->length);$/;"	l	language:C
length	intset.h	/^    uint32_t length;$/;"	m	language:C	struct:intset	access:public
length	modules/API.md	/^Return a pointer, and a length, to the protocol returned by the command$/;"	v	language:C
length	modules/API.md	/^Return the reply type length, where applicable.$/;"	v	language:C
length	modules/API.md	/^length, since we produce a fixed number of elements, but in the practice$/;"	v	language:C
length	modules/INTRO.md	/^safe C buffers with a pointer and a length, and so forth.$/;"	v	language:C
length	server.h	/^    unsigned long length;$/;"	m	language:C	struct:zskiplist	access:public
length	sparkline.h	/^    int length;$/;"	m	language:C	struct:sequence	access:public
length	t_hash.c	/^    int length, count = 0;$/;"	l	language:C
length	t_hash.c	/^    unsigned long length = ULONG_MAX;$/;"	l	language:C
length	t_zset.c	/^    int length = -1;$/;"	l	language:C
length	util.c	/^    uint32_t const length = digits10(value)+negative;$/;"	l	language:C
lensize	ziplist.c	/^        unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
lensize	ziplist.c	/^    unsigned int lensize, len;$/;"	m	language:C	struct:zlentry	file:	access:public
lensize	ziplist.c	/^    unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
level	aof.c	/^                int level = ((numblocks+1) % 100) == 0 ? LL_WARNING :$/;"	l	language:C
level	module.c	/^    int level;$/;"	l	language:C
level	modules/TYPES.md	/^by calling Redis commands, and at low level, by manipulating the data structures$/;"	v	language:C
level	scripting.c	/^    int level = 0;$/;"	l	language:C
level	scripting.c	/^    int level;$/;"	l	language:C
level	server.h	/^    int level;$/;"	m	language:C	struct:zskiplist	access:public
level	server.h	/^    } level[];$/;"	m	language:C	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistLevel	access:public
level	t_zset.c	/^    int i, level;$/;"	l	language:C
level	t_zset.c	/^    int level = 1;$/;"	l	language:C
lexrange	t_zset.c	/^    zlexrangespec lexrange;$/;"	l	language:C
lfu_decay_time	server.h	/^    unsigned int lfu_decay_time;    \/* LFU counter decay factor. *\/$/;"	m	language:C	struct:redisServer	access:public
lfu_log_factor	server.h	/^    unsigned int lfu_log_factor;    \/* LFU logarithmic counter factor. *\/$/;"	m	language:C	struct:redisServer	access:public
li	aof.c	/^        quicklistIter *li = quicklistGetIterator(list, AL_START_HEAD);$/;"	l	language:C
li	aof.c	/^    listIter li;$/;"	l	language:C
li	blocked.c	/^    listIter li;$/;"	l	language:C
li	cluster.c	/^    listIter li;$/;"	l	language:C
li	debug.c	/^                listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);$/;"	l	language:C
li	evict.c	/^        listIter li;$/;"	l	language:C
li	module.c	/^        listIter li;$/;"	l	language:C
li	module.c	/^    listIter li;$/;"	l	language:C
li	multi.c	/^    listIter li;$/;"	l	language:C
li	networking.c	/^        listIter li;$/;"	l	language:C
li	networking.c	/^    listIter li;$/;"	l	language:C
li	pubsub.c	/^        listIter li;$/;"	l	language:C
li	pubsub.c	/^    listIter li;$/;"	l	language:C
li	rdb.c	/^    listIter li;$/;"	l	language:C
li	replication.c	/^        listIter li;$/;"	l	language:C
li	replication.c	/^    listIter li;$/;"	l	language:C
li	scripting.c	/^    listIter li;$/;"	l	language:C
li	sentinel.c	/^        listIter li;$/;"	l	language:C
li	sentinel.c	/^    listIter li;$/;"	l	language:C
li	server.c	/^            listIter li;$/;"	l	language:C
li	server.h	/^    listTypeIterator *li;$/;"	m	language:C	struct:__anon32	access:public
li	slowlog.c	/^        listIter li;$/;"	l	language:C
li	sort.c	/^            listIter li;$/;"	l	language:C
li	sort.c	/^            listTypeIterator *li;$/;"	l	language:C
li	sort.c	/^        listTypeIterator *li = listTypeInitIterator(sortval,0,LIST_TAIL);$/;"	l	language:C
li	t_list.c	/^    listTypeIterator *li = zmalloc(sizeof(listTypeIterator));$/;"	l	language:C
li1	multi.c	/^    listIter li1, li2;$/;"	l	language:C
li2	multi.c	/^    listIter li1, li2;$/;"	l	language:C
likely	quicklist.c	/^#define likely(/;"	d	language:C	file:
limit	server.c	/^    struct rlimit limit;$/;"	l	language:C
limit	t_zset.c	/^    long offset = 0, limit = -1;$/;"	l	language:C
limit_count	sort.c	/^    long limit_start = 0, limit_count = -1, start, end;$/;"	l	language:C
limit_start	sort.c	/^    long limit_start = 0, limit_count = -1, start, end;$/;"	l	language:C
lindexCommand	server.h	/^void lindexCommand(client *c);$/;"	p	language:C	signature:(client *c)
lindexCommand	t_list.c	/^void lindexCommand(client *c) {$/;"	f	language:C	signature:(client *c)
line	cluster.c	/^    char *line;$/;"	l	language:C
line	config.c	/^        sds line = sdstrim(sdsnew(buf),"\\r\\n\\t ");$/;"	l	language:C
line	config.c	/^        sds line;$/;"	l	language:C
line	config.c	/^    sds line = sdscatprintf(sdsempty(),"%s %lld",option,value);$/;"	l	language:C
line	config.c	/^    sds line = sdscatprintf(sdsempty(),"%s %o",option,value);$/;"	l	language:C
line	config.c	/^    sds line = sdscatprintf(sdsempty(),"%s %s",option,$/;"	l	language:C
line	config.c	/^    sds line, addresses;$/;"	l	language:C
line	config.c	/^    sds line, flags;$/;"	l	language:C
line	config.c	/^    sds line;$/;"	l	language:C
line	debug.c	/^    char line[1024];$/;"	l	language:C
line	redis-cli.c	/^    char *line;$/;"	l	language:C
line	scripting.c	/^            long line;$/;"	l	language:C
line	scripting.c	/^    char *line = ldbGetSourceLine(lnum);$/;"	l	language:C
line	sentinel.c	/^    sds line;$/;"	l	language:C
line	zmalloc.c	/^    char line[1024];$/;"	l	language:C
linenum	config.c	/^            int linenum = (long) ln->value;$/;"	l	language:C
linenum	config.c	/^        int linenum = (long) ln->value;$/;"	l	language:C
linenum	config.c	/^    int linenum = -1;$/;"	l	language:C
linenum	config.c	/^    int linenum = 0, totlines, i;$/;"	l	language:C
lines	config.c	/^    sds *lines;           \/* Current lines as an array of sds strings *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
lines	config.c	/^    sds *lines;$/;"	l	language:C
lines	scripting.c	/^    int lines;  \/* Number of lines in 'src'. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
lines	sentinel.c	/^    sds *lines;$/;"	l	language:C
link	cluster.c	/^            clusterLink *link;$/;"	l	language:C
link	cluster.c	/^    clusterLink *link = (clusterLink*) privdata;$/;"	l	language:C
link	cluster.c	/^    clusterLink *link = zmalloc(sizeof(*link));$/;"	l	language:C
link	cluster.c	/^    clusterLink *link;$/;"	l	language:C
link	cluster.h	/^    clusterLink *link;          \/* TCP\/IP link with this node *\/$/;"	m	language:C	struct:clusterNode	access:public
link	sentinel.c	/^    instanceLink *link = c->data;$/;"	l	language:C
link	sentinel.c	/^    instanceLink *link = zmalloc(sizeof(*link));$/;"	l	language:C
link	sentinel.c	/^    instanceLink *link; \/* Link to the instance, may be shared for Sentinels. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
linsertCommand	server.h	/^void linsertCommand(client *c);$/;"	p	language:C	signature:(client *c)
linsertCommand	t_list.c	/^void linsertCommand(client *c) {$/;"	f	language:C	signature:(client *c)
linuxMemoryWarnings	server.c	/^void linuxMemoryWarnings(void) {$/;"	f	language:C	signature:(void)
linuxOvercommitMemoryValue	server.c	/^int linuxOvercommitMemoryValue(void) {$/;"	f	language:C	signature:(void)
list	adlist.c	/^    struct list *list;$/;"	l	language:C
list	adlist.h	/^typedef struct list {$/;"	s	language:C
list	adlist.h	/^} list;$/;"	t	language:C	typeref:struct:list
list	aof.c	/^        quicklist *list = o->ptr;$/;"	l	language:C
list	modules/API.md	/^Pop an element from the list, and returns it as a module string object$/;"	v	language:C
list	modules/API.md	/^Push an element into a list, on head or tail depending on 'where' argumnet.$/;"	v	language:C
list	pubsub.c	/^        list *list = dictGetVal(de);$/;"	l	language:C
list::dup	adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	language:C	struct:list	access:public
list::free	adlist.h	/^    void (*free)(void *ptr);$/;"	m	language:C	struct:list	access:public
list::head	adlist.h	/^    listNode *head;$/;"	m	language:C	struct:list	access:public
list::len	adlist.h	/^    unsigned long len;$/;"	m	language:C	struct:list	access:public
list::match	adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	language:C	struct:list	access:public
list::tail	adlist.h	/^    listNode *tail;$/;"	m	language:C	struct:list	access:public
listAddNodeHead	adlist.c	/^list *listAddNodeHead(list *list, void *value)$/;"	f	language:C	signature:(list *list, void *value)
listAddNodeHead	adlist.h	/^list *listAddNodeHead(list *list, void *value);$/;"	p	language:C	signature:(list *list, void *value)
listAddNodeTail	adlist.c	/^list *listAddNodeTail(list *list, void *value)$/;"	f	language:C	signature:(list *list, void *value)
listAddNodeTail	adlist.h	/^list *listAddNodeTail(list *list, void *value);$/;"	p	language:C	signature:(list *list, void *value)
listCreate	adlist.c	/^list *listCreate(void)$/;"	f	language:C	signature:(void)
listCreate	adlist.h	/^list *listCreate(void);$/;"	p	language:C	signature:(void)
listDelNode	adlist.c	/^void listDelNode(list *list, listNode *node)$/;"	f	language:C	signature:(list *list, listNode *node)
listDelNode	adlist.h	/^void listDelNode(list *list, listNode *node);$/;"	p	language:C	signature:(list *list, listNode *node)
listDup	adlist.c	/^list *listDup(list *orig)$/;"	f	language:C	signature:(list *orig)
listDup	adlist.h	/^list *listDup(list *orig);$/;"	p	language:C	signature:(list *orig)
listFirst	adlist.h	/^#define listFirst(/;"	d	language:C
listGetDupMethod	adlist.h	/^#define listGetDupMethod(/;"	d	language:C
listGetFree	adlist.h	/^#define listGetFree(/;"	d	language:C
listGetIterator	adlist.c	/^listIter *listGetIterator(list *list, int direction)$/;"	f	language:C	signature:(list *list, int direction)
listGetIterator	adlist.h	/^listIter *listGetIterator(list *list, int direction);$/;"	p	language:C	signature:(list *list, int direction)
listGetMatchMethod	adlist.h	/^#define listGetMatchMethod(/;"	d	language:C
listIndex	adlist.c	/^listNode *listIndex(list *list, long index) {$/;"	f	language:C	signature:(list *list, long index)
listIndex	adlist.h	/^listNode *listIndex(list *list, long index);$/;"	p	language:C	signature:(list *list, long index)
listIndex	tags	/^listIndex	adlist.c	\/^listNode *listIndex(list *list, long index) {$\/;"	f	language:C	signature:(list *list, long index)$/;"	f	language:C	signature:(list *list, long index)
listInsertNode	adlist.c	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after) {$/;"	f	language:C	signature:(list *list, listNode *old_node, void *value, int after)
listInsertNode	adlist.h	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after);$/;"	p	language:C	signature:(list *list, listNode *old_node, void *value, int after)
listInsertNode	tags	/^listInsertNode	adlist.c	\/^list *listInsertNode(list *list, listNode *old_node, void *value, int after) {$\/;"	f	language:C	signature:(list *list, listNode *old_node, void *value, int after)$/;"	f	language:C	signature:(list *list, listNode *old_node, void *value, int after)
listIter	adlist.h	/^typedef struct listIter {$/;"	s	language:C
listIter	adlist.h	/^} listIter;$/;"	t	language:C	typeref:struct:listIter
listIter::direction	adlist.h	/^    int direction;$/;"	m	language:C	struct:listIter	access:public
listIter::next	adlist.h	/^    listNode *next;$/;"	m	language:C	struct:listIter	access:public
listLast	adlist.h	/^#define listLast(/;"	d	language:C
listLength	adlist.h	/^#define listLength(/;"	d	language:C
listLength	replication.c	/^    serverAssert(listLength(server.slaves) == 0);$/;"	p	language:C	file:	signature:(server.slaves)
listLength	sentinel.c	/^        serverAssert(listLength(sentinel.scripts_queue) <=$/;"	p	language:C	file:	signature:(sentinel.scripts_queue)
listMatchObjects	networking.c	/^int listMatchObjects(void *a, void *b) {$/;"	f	language:C	signature:(void *a, void *b)
listMatchPubsubPattern	pubsub.c	/^int listMatchPubsubPattern(void *a, void *b) {$/;"	f	language:C	signature:(void *a, void *b)
listMatchPubsubPattern	server.h	/^int listMatchPubsubPattern(void *a, void *b);$/;"	p	language:C	signature:(void *a, void *b)
listNext	adlist.c	/^listNode *listNext(listIter *iter)$/;"	f	language:C	signature:(listIter *iter)
listNext	adlist.h	/^listNode *listNext(listIter *iter);$/;"	p	language:C	signature:(listIter *iter)
listNextNode	adlist.h	/^#define listNextNode(/;"	d	language:C
listNode	adlist.h	/^typedef struct listNode {$/;"	s	language:C
listNode	adlist.h	/^} listNode;$/;"	t	language:C	typeref:struct:listNode
listNode::next	adlist.h	/^    struct listNode *next;$/;"	m	language:C	struct:listNode	typeref:struct:listNode::listNode	access:public
listNode::prev	adlist.h	/^    struct listNode *prev;$/;"	m	language:C	struct:listNode	typeref:struct:listNode::listNode	access:public
listNode::value	adlist.h	/^    void *value;$/;"	m	language:C	struct:listNode	access:public
listNodeValue	adlist.h	/^#define listNodeValue(/;"	d	language:C
listPopSaver	t_list.c	/^void *listPopSaver(unsigned char *data, unsigned int sz) {$/;"	f	language:C	signature:(unsigned char *data, unsigned int sz)
listPrevNode	adlist.h	/^#define listPrevNode(/;"	d	language:C
listRelease	adlist.c	/^void listRelease(list *list)$/;"	f	language:C	signature:(list *list)
listRelease	adlist.h	/^void listRelease(list *list);$/;"	p	language:C	signature:(list *list)
listReleaseIterator	adlist.c	/^void listReleaseIterator(listIter *iter) {$/;"	f	language:C	signature:(listIter *iter)
listReleaseIterator	adlist.h	/^void listReleaseIterator(listIter *iter);$/;"	p	language:C	signature:(listIter *iter)
listRewind	adlist.c	/^void listRewind(list *list, listIter *li) {$/;"	f	language:C	signature:(list *list, listIter *li)
listRewind	adlist.h	/^void listRewind(list *list, listIter *li);$/;"	p	language:C	signature:(list *list, listIter *li)
listRewind	tags	/^listRewind	adlist.c	\/^void listRewind(list *list, listIter *li) {$\/;"	f	language:C	signature:(list *list, listIter *li)$/;"	f	language:C	signature:(list *list, listIter *li)
listRewindTail	adlist.c	/^void listRewindTail(list *list, listIter *li) {$/;"	f	language:C	signature:(list *list, listIter *li)
listRewindTail	adlist.h	/^void listRewindTail(list *list, listIter *li);$/;"	p	language:C	signature:(list *list, listIter *li)
listRotate	adlist.c	/^void listRotate(list *list) {$/;"	f	language:C	signature:(list *list)
listRotate	adlist.h	/^void listRotate(list *list);$/;"	p	language:C	signature:(list *list)
listRotate	tags	/^listRotate	adlist.c	\/^void listRotate(list *list) {$\/;"	f	language:C	signature:(list *list)$/;"	f	language:C	signature:(list *list)
listSearchKey	adlist.c	/^listNode *listSearchKey(list *list, void *key)$/;"	f	language:C	signature:(list *list, void *key)
listSearchKey	adlist.h	/^listNode *listSearchKey(list *list, void *key);$/;"	p	language:C	signature:(list *list, void *key)
listSetDupMethod	adlist.h	/^#define listSetDupMethod(/;"	d	language:C
listSetFreeMethod	adlist.h	/^#define listSetFreeMethod(/;"	d	language:C
listSetMatchMethod	adlist.h	/^#define listSetMatchMethod(/;"	d	language:C
listTypeConvert	server.h	/^void listTypeConvert(robj *subject, int enc);$/;"	p	language:C	signature:(robj *subject, int enc)
listTypeConvert	t_list.c	/^void listTypeConvert(robj *subject, int enc) {$/;"	f	language:C	signature:(robj *subject, int enc)
listTypeDelete	server.h	/^void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry);$/;"	p	language:C	signature:(listTypeIterator *iter, listTypeEntry *entry)
listTypeDelete	t_list.c	/^void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {$/;"	f	language:C	signature:(listTypeIterator *iter, listTypeEntry *entry)
listTypeEntry	server.h	/^} listTypeEntry;$/;"	t	language:C	typeref:struct:__anon32
listTypeEqual	server.h	/^int listTypeEqual(listTypeEntry *entry, robj *o);$/;"	p	language:C	signature:(listTypeEntry *entry, robj *o)
listTypeEqual	t_list.c	/^int listTypeEqual(listTypeEntry *entry, robj *o) {$/;"	f	language:C	signature:(listTypeEntry *entry, robj *o)
listTypeGet	server.h	/^robj *listTypeGet(listTypeEntry *entry);$/;"	p	language:C	signature:(listTypeEntry *entry)
listTypeGet	t_list.c	/^robj *listTypeGet(listTypeEntry *entry) {$/;"	f	language:C	signature:(listTypeEntry *entry)
listTypeInitIterator	server.h	/^listTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction);$/;"	p	language:C	signature:(robj *subject, long index, unsigned char direction)
listTypeInitIterator	t_list.c	/^listTypeIterator *listTypeInitIterator(robj *subject, long index,$/;"	f	language:C	signature:(robj *subject, long index, unsigned char direction)
listTypeInsert	server.h	/^void listTypeInsert(listTypeEntry *entry, robj *value, int where);$/;"	p	language:C	signature:(listTypeEntry *entry, robj *value, int where)
listTypeInsert	t_list.c	/^void listTypeInsert(listTypeEntry *entry, robj *value, int where) {$/;"	f	language:C	signature:(listTypeEntry *entry, robj *value, int where)
listTypeIterator	server.h	/^} listTypeIterator;$/;"	t	language:C	typeref:struct:__anon31
listTypeLength	server.h	/^unsigned long listTypeLength(const robj *subject);$/;"	p	language:C	signature:(const robj *subject)
listTypeLength	t_list.c	/^unsigned long listTypeLength(const robj *subject) {$/;"	f	language:C	signature:(const robj *subject)
listTypeNext	server.h	/^int listTypeNext(listTypeIterator *li, listTypeEntry *entry);$/;"	p	language:C	signature:(listTypeIterator *li, listTypeEntry *entry)
listTypeNext	t_list.c	/^int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {$/;"	f	language:C	signature:(listTypeIterator *li, listTypeEntry *entry)
listTypePop	server.h	/^robj *listTypePop(robj *subject, int where);$/;"	p	language:C	signature:(robj *subject, int where)
listTypePop	t_list.c	/^robj *listTypePop(robj *subject, int where) {$/;"	f	language:C	signature:(robj *subject, int where)
listTypePush	server.h	/^void listTypePush(robj *subject, robj *value, int where);$/;"	p	language:C	signature:(robj *subject, robj *value, int where)
listTypePush	t_list.c	/^void listTypePush(robj *subject, robj *value, int where) {$/;"	f	language:C	signature:(robj *subject, robj *value, int where)
listTypeReleaseIterator	server.h	/^void listTypeReleaseIterator(listTypeIterator *li);$/;"	p	language:C	signature:(listTypeIterator *li)
listTypeReleaseIterator	t_list.c	/^void listTypeReleaseIterator(listTypeIterator *li) {$/;"	f	language:C	signature:(listTypeIterator *li)
listTypeTryConversion	server.h	/^void listTypeTryConversion(robj *subject, robj *value);$/;"	p	language:C	signature:(robj *subject, robj *value)
list_compress_depth	server.h	/^    int list_compress_depth;$/;"	m	language:C	struct:redisServer	access:public
list_item_size	networking.c	/^    unsigned long list_item_size = sizeof(listNode)+5;$/;"	l	language:C
list_max_ziplist_size	server.h	/^    int list_max_ziplist_size;$/;"	m	language:C	struct:redisServer	access:public
list_sizes	quicklist.c	/^    int list_sizes[] = {250, 251, 500, 999, 1000};$/;"	l	language:C
listele	dict.c	/^    int listlen, listele;$/;"	l	language:C
listenToPort	server.c	/^int listenToPort(int port, int *fds, int *count) {$/;"	f	language:C	signature:(int port, int *fds, int *count)
listenToPort	server.h	/^int listenToPort(int port, int *fds, int *count);$/;"	p	language:C	signature:(int port, int *fds, int *count)
listlen	dict.c	/^    int listlen, listele;$/;"	l	language:C
lists	modules/TYPES.md	/^The 1 byte type identifies strings, lists, sets, and so forth. In the case$/;"	v	language:C
lit	lzf_c.c	/^  int lit;$/;"	l	language:C
liveclients	redis-benchmark.c	/^    int liveclients;$/;"	m	language:C	struct:config	file:	access:public
ll	config.c	/^    long long ll;$/;"	l	language:C
ll	db.c	/^        int64_t ll;$/;"	l	language:C
ll	module.c	/^            long ll = va_arg(ap,long long);$/;"	l	language:C
ll	module.c	/^        long long ll;    \/* Reply value for integer reply. *\/$/;"	m	language:C	union:RedisModuleCallReply::__anon19	file:	access:public
ll	networking.c	/^    long long ll;$/;"	l	language:C
ll	sentinel.c	/^        long long ll;$/;"	l	language:C
ll	t_hash.c	/^    long long ll;$/;"	l	language:C
ll	ziplist.c	/^                    long long ll = zipLoadInteger(q, encoding);$/;"	l	language:C
ll2string	util.c	/^int ll2string(char *dst, size_t dstlen, long long svalue) {$/;"	f	language:C	signature:(char *dst, size_t dstlen, long long svalue)
ll2string	util.h	/^int ll2string(char *s, size_t len, long long value);$/;"	p	language:C	signature:(char *s, size_t len, long long value)
llbits	bitops.c	/^    long long llbits;$/;"	l	language:C
llbuf	bitops.c	/^            char llbuf[LONG_STR_SIZE];$/;"	l	language:C
llbuf	bitops.c	/^    char llbuf[32];$/;"	l	language:C
llbuf	bitops.c	/^    char llbuf[LONG_STR_SIZE];$/;"	l	language:C
llbuf	t_string.c	/^    char *str, llbuf[32];$/;"	l	language:C
llele	t_set.c	/^    int64_t llele;$/;"	l	language:C
llen	rio.c	/^    unsigned int llen;$/;"	l	language:C
llen	t_list.c	/^    long start, end, llen, ltrim, rtrim;$/;"	l	language:C
llen	t_list.c	/^    long start, end, llen, rangelen;$/;"	l	language:C
llen	t_zset.c	/^    int llen;$/;"	l	language:C
llen	t_zset.c	/^    long start, end, llen;$/;"	l	language:C
llen	t_zset.c	/^    unsigned long llen;$/;"	l	language:C
llen	zipmap.c	/^    unsigned int l,llen;$/;"	l	language:C
llenCommand	server.h	/^void llenCommand(client *c);$/;"	p	language:C	signature:(client *c)
llenCommand	t_list.c	/^void llenCommand(client *c) {$/;"	f	language:C	signature:(client *c)
llstr	replication.c	/^    char llstr[LONG_STR_SIZE];$/;"	l	language:C
llval	aof.c	/^        int64_t llval;$/;"	l	language:C
llval	rdb.c	/^            long long llval;$/;"	l	language:C
llval	t_set.c	/^    long long llval;$/;"	l	language:C
llval	util.c	/^    long long llval;$/;"	l	language:C
ln	aof.c	/^    listNode *ln = listLast(server.aof_rewrite_buf_blocks);$/;"	l	language:C
ln	aof.c	/^    listNode *ln;$/;"	l	language:C
ln	bio.c	/^        listNode *ln;$/;"	l	language:C
ln	blocked.c	/^    listNode *ln;$/;"	l	language:C
ln	cluster.c	/^    listNode *ln;$/;"	l	language:C
ln	config.c	/^            listNode *ln = listFirst(l);$/;"	l	language:C
ln	config.c	/^        listNode *ln = listFirst(l);$/;"	l	language:C
ln	evict.c	/^        listNode *ln;$/;"	l	language:C
ln	geo.c	/^        zskiplistNode *ln;$/;"	l	language:C
ln	module.c	/^        listNode *ln;$/;"	l	language:C
ln	module.c	/^        zskiplistNode *ln = key->zcurrent, *next = ln->level[0].forward;$/;"	l	language:C
ln	module.c	/^        zskiplistNode *ln = key->zcurrent, *prev = ln->backward;$/;"	l	language:C
ln	module.c	/^        zskiplistNode *ln = key->zcurrent;$/;"	l	language:C
ln	module.c	/^    listNode *ln;$/;"	l	language:C
ln	multi.c	/^    listNode *ln;$/;"	l	language:C
ln	networking.c	/^        listNode *ln = listFirst(server.clients_to_close);$/;"	l	language:C
ln	networking.c	/^        listNode *ln = listFirst(server.slaves);$/;"	l	language:C
ln	networking.c	/^        listNode *ln = listLast(c->reply);$/;"	l	language:C
ln	networking.c	/^        listNode *ln;$/;"	l	language:C
ln	networking.c	/^    listNode *ln = (listNode*)node;$/;"	l	language:C
ln	networking.c	/^    listNode *ln;$/;"	l	language:C
ln	pubsub.c	/^        listNode *ln;$/;"	l	language:C
ln	pubsub.c	/^    listNode *ln;$/;"	l	language:C
ln	rdb.c	/^    listNode *ln;$/;"	l	language:C
ln	redis-benchmark.c	/^    listNode *ln = config.clients->head, *next;$/;"	l	language:C
ln	redis-benchmark.c	/^    listNode *ln;$/;"	l	language:C
ln	replication.c	/^        listNode *ln = listLast(server.repl_scriptcache_fifo);$/;"	l	language:C
ln	replication.c	/^        listNode *ln;$/;"	l	language:C
ln	replication.c	/^    listNode *ln = listSearchKey(server.clients_waiting_acks,c);$/;"	l	language:C
ln	replication.c	/^    listNode *ln;$/;"	l	language:C
ln	scripting.c	/^        listNode *ln = listFirst(ldb.logs);$/;"	l	language:C
ln	scripting.c	/^    listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);$/;"	l	language:C
ln	scripting.c	/^    listNode *ln;$/;"	l	language:C
ln	sentinel.c	/^        listNode *ln;$/;"	l	language:C
ln	sentinel.c	/^    listNode *ln;$/;"	l	language:C
ln	server.c	/^            listNode *ln;$/;"	l	language:C
ln	slowlog.c	/^        listNode *ln;$/;"	l	language:C
ln	sort.c	/^            listNode *ln;$/;"	l	language:C
ln	sort.c	/^        zskiplistNode *ln;$/;"	l	language:C
ln	t_list.c	/^            listNode *ln = listFirst(l);$/;"	l	language:C
ln	t_zset.c	/^        zskiplistNode *ln;$/;"	l	language:C
load	modules/TYPES.md	/^what version of the data layout to load, if it can support multiple versions.$/;"	v	language:C
loadAppendOnlyFile	aof.c	/^int loadAppendOnlyFile(char *filename) {$/;"	f	language:C	signature:(char *filename)
loadAppendOnlyFile	server.h	/^int loadAppendOnlyFile(char *filename);$/;"	p	language:C	signature:(char *filename)
loadDataFromDisk	server.c	/^void loadDataFromDisk(void) {$/;"	f	language:C	signature:(void)
loadServerConfig	config.c	/^void loadServerConfig(char *filename, char *options) {$/;"	f	language:C	signature:(char *filename, char *options)
loadServerConfig	server.h	/^void loadServerConfig(char *filename, char *options);$/;"	p	language:C	signature:(char *filename, char *options)
loadServerConfigFromString	config.c	/^void loadServerConfigFromString(char *config) {$/;"	f	language:C	signature:(char *config)
loading	modules/TYPES.md	/^* A set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the `DEBUG DIGEST` command.$/;"	v	language:C
loading	server.h	/^    int loading;                \/* We are loading data from disk if true *\/$/;"	m	language:C	struct:redisServer	access:public
loadingProgress	rdb.c	/^void loadingProgress(off_t pos) {$/;"	f	language:C	signature:(off_t pos)
loadingProgress	server.h	/^void loadingProgress(off_t pos);$/;"	p	language:C	signature:(off_t pos)
loading_loaded_bytes	server.h	/^    off_t loading_loaded_bytes;$/;"	m	language:C	struct:redisServer	access:public
loading_process_events_interval_bytes	server.h	/^    off_t loading_process_events_interval_bytes;$/;"	m	language:C	struct:redisServer	access:public
loading_start_time	server.h	/^    time_t loading_start_time;$/;"	m	language:C	struct:redisServer	access:public
loading_total_bytes	server.h	/^    off_t loading_total_bytes;$/;"	m	language:C	struct:redisServer	access:public
loadingerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
loadmod	config.c	/^    struct moduleLoadQueueEntry *loadmod;$/;"	l	language:C
loadmod	module.c	/^        struct moduleLoadQueueEntry *loadmod = ln->value;$/;"	l	language:C
loadmodule_queue	server.h	/^    list *loadmodule_queue;     \/* List of modules to load at startup. *\/$/;"	m	language:C	struct:redisServer	access:public
lobj	t_list.c	/^    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);$/;"	l	language:C
local_slave	cluster.c	/^            int local_slave =$/;"	l	language:C
loffset	bitops.c	/^    long long loffset;$/;"	l	language:C
log	scripting.c	/^    sds log = sdscatprintf(sdsempty(),"<debug> line %d: ", ldb.currentline);$/;"	l	language:C
log	scripting.c	/^    sds log = sdsnew("<reply> ");$/;"	l	language:C
log	scripting.c	/^    sds log;$/;"	l	language:C
logCurrentClient	debug.c	/^void logCurrentClient(void) {$/;"	f	language:C	signature:(void)
logRegisters	debug.c	/^void logRegisters(ucontext_t *uc) {$/;"	f	language:C	signature:(ucontext_t *uc)
logStackContent	debug.c	/^void logStackContent(void **sp) {$/;"	f	language:C	signature:(void **sp)
logStackTrace	debug.c	/^void logStackTrace(ucontext_t *uc) {$/;"	f	language:C	signature:(ucontext_t *uc)
log_to_stdout	debug.c	/^    int log_to_stdout = server.logfile[0] == '\\0';$/;"	l	language:C
log_to_stdout	server.c	/^    int log_to_stdout = server.logfile[0] == '\\0';$/;"	l	language:C
logbuf	debug.c	/^    char logbuf[1024];$/;"	l	language:C
logfile	server.h	/^    char *logfile;                  \/* Path of log file *\/$/;"	m	language:C	struct:redisServer	access:public
logfp	config.c	/^            FILE *logfp;$/;"	l	language:C
logged_time	networking.c	/^    static time_t logged_time;$/;"	l	language:C	file:
loglevel_enum	config.c	/^configEnum loglevel_enum[] = {$/;"	v	language:C
logs	scripting.c	/^    list *logs; \/* List of messages to send to the client. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
lol	networking.c	/^    unsigned long lol = 0, bib = 0;$/;"	l	language:C
lol	server.c	/^    unsigned long lol, bib;$/;"	l	language:C
lon1r	geohash_helper.c	/^    double lat1r, lon1r, lat2r, lon2r, u, v;$/;"	l	language:C
lon2r	geohash_helper.c	/^    double lat1r, lon1r, lat2r, lon2r, u, v;$/;"	l	language:C
longLatFromMember	geo.c	/^int longLatFromMember(robj *zobj, robj *member, double *xy) {$/;"	f	language:C	signature:(robj *zobj, robj *member, double *xy)
long_offset	geohash.c	/^    double long_offset =$/;"	l	language:C
long_range	geohash_helper.c	/^    GeoHashRange long_range, lat_range;$/;"	l	language:C
long_scale	geohash.c	/^    double long_scale = long_range.max - long_range.min;$/;"	l	language:C
longitude	geo.h	/^    double longitude;$/;"	m	language:C	struct:geoPoint	access:public
longitude	geohash.h	/^    GeoHashRange longitude;$/;"	m	language:C	struct:__anon16	access:public
longstr	quicklist.c	/^    char longstr[32] = {0};$/;"	l	language:C
longval	quicklist.c	/^    long long longval;$/;"	l	language:C
longval	quicklist.h	/^    long long longval;$/;"	m	language:C	struct:quicklistEntry	access:public
lonr	geohash_helper.c	/^    double lonr, latr;$/;"	l	language:C
lookupCommand	server.c	/^struct redisCommand *lookupCommand(sds name) {$/;"	f	language:C	signature:(sds name)
lookupCommand	server.h	/^struct redisCommand *lookupCommand(sds name);$/;"	p	language:C	signature:(sds name)
lookupCommandByCString	server.c	/^struct redisCommand *lookupCommandByCString(char *s) {$/;"	f	language:C	signature:(char *s)
lookupCommandByCString	server.h	/^struct redisCommand *lookupCommandByCString(char *s);$/;"	p	language:C	signature:(char *s)
lookupCommandOrOriginal	server.c	/^struct redisCommand *lookupCommandOrOriginal(sds name) {$/;"	f	language:C	signature:(sds name)
lookupCommandOrOriginal	server.h	/^struct redisCommand *lookupCommandOrOriginal(sds name);$/;"	p	language:C	signature:(sds name)
lookupKey	db.c	/^robj *lookupKey(redisDb *db, robj *key, int flags) {$/;"	f	language:C	signature:(redisDb *db, robj *key, int flags)
lookupKey	server.h	/^robj *lookupKey(redisDb *db, robj *key, int flags);$/;"	p	language:C	signature:(redisDb *db, robj *key, int flags)
lookupKeyByPattern	sort.c	/^robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {$/;"	f	language:C	signature:(redisDb *db, robj *pattern, robj *subst)
lookupKeyRead	db.c	/^robj *lookupKeyRead(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
lookupKeyRead	server.h	/^robj *lookupKeyRead(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
lookupKeyReadOrReply	db.c	/^robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {$/;"	f	language:C	signature:(client *c, robj *key, robj *reply)
lookupKeyReadOrReply	server.h	/^robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply);$/;"	p	language:C	signature:(client *c, robj *key, robj *reply)
lookupKeyReadWithFlags	db.c	/^robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {$/;"	f	language:C	signature:(redisDb *db, robj *key, int flags)
lookupKeyReadWithFlags	server.h	/^robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags);$/;"	p	language:C	signature:(redisDb *db, robj *key, int flags)
lookupKeyWrite	db.c	/^robj *lookupKeyWrite(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
lookupKeyWrite	server.h	/^robj *lookupKeyWrite(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
lookupKeyWriteOrReply	db.c	/^robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {$/;"	f	language:C	signature:(client *c, robj *key, robj *reply)
lookupKeyWriteOrReply	server.h	/^robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply);$/;"	p	language:C	signature:(client *c, robj *key, robj *reply)
lookupStringForBitCommand	bitops.c	/^robj *lookupStringForBitCommand(client *c, size_t maxbit) {$/;"	f	language:C	signature:(client *c, size_t maxbit)
loop	redis-benchmark.c	/^    int loop;$/;"	m	language:C	struct:config	file:	access:public
loop	sentinel.c	/^    aeEventLoop *loop = e->loop;$/;"	l	language:C
loop	sentinel.c	/^    aeEventLoop *loop;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
loop	sparkline.c	/^    int loop = 1;$/;"	l	language:C
loop_nwritten	redis-cli.c	/^            ssize_t loop_nwritten = 0;$/;"	l	language:C
loopr	quicklist.c	/^    int loopr = itrprintr(ql, 0);$/;"	l	language:C
loops	aof.c	/^    long loops = 0;$/;"	l	language:C
low_flags	module.c	/^        int low_flags = HASH_SET_COPY;$/;"	l	language:C
low_raw	quicklist.c	/^                    unsigned int low_raw = ql->compress;$/;"	l	language:C
low_raw	quicklist.c	/^        unsigned int low_raw = ql->compress;$/;"	l	language:C
lp	bitops.c	/^            unsigned long *lp[16];$/;"	l	language:C
lpop	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
lpopCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
lpopCommand	server.h	/^void lpopCommand(client *c);$/;"	p	language:C	signature:(client *c)
lpopCommand	t_list.c	/^void lpopCommand(client *c) {$/;"	f	language:C	signature:(client *c)
lpush	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
lpushCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
lpushCommand	server.h	/^void lpushCommand(client *c);$/;"	p	language:C	signature:(client *c)
lpushCommand	t_list.c	/^void lpushCommand(client *c) {$/;"	f	language:C	signature:(client *c)
lpushxCommand	server.h	/^void lpushxCommand(client *c);$/;"	p	language:C	signature:(client *c)
lpushxCommand	t_list.c	/^void lpushxCommand(client *c) {$/;"	f	language:C	signature:(client *c)
lrangeCommand	server.h	/^void lrangeCommand(client *c);$/;"	p	language:C	signature:(client *c)
lrangeCommand	t_list.c	/^void lrangeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
lremCommand	server.h	/^void lremCommand(client *c);$/;"	p	language:C	signature:(client *c)
lremCommand	t_list.c	/^void lremCommand(client *c) {$/;"	f	language:C	signature:(client *c)
lres	bitops.c	/^            unsigned long *lres = (unsigned long*) res;$/;"	l	language:C
lru	server.h	/^    unsigned lru:LRU_BITS; \/* LRU time (relative to server.lruclock) or$/;"	m	language:C	struct:redisObject	access:public
lru_test_mode	redis-cli.c	/^    int lru_test_mode;$/;"	m	language:C	struct:config	file:	access:public
lru_test_sample_size	redis-cli.c	/^    long long lru_test_sample_size;$/;"	m	language:C	struct:config	file:	access:public
lruclock	evict.c	/^    unsigned long long lruclock = LRU_CLOCK();$/;"	l	language:C
lruclock	server.h	/^    unsigned lruclock:LRU_BITS; \/* Clock for LRU eviction *\/$/;"	m	language:C	struct:redisServer	access:public
ls	latency.c	/^        struct latencyStats ls;$/;"	l	language:C
lsetCommand	server.h	/^void lsetCommand(client *c);$/;"	p	language:C	signature:(client *c)
lsetCommand	t_list.c	/^void lsetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
ltrim	t_list.c	/^    long start, end, llen, ltrim, rtrim;$/;"	l	language:C
ltrimCommand	server.h	/^void ltrimCommand(client *c);$/;"	p	language:C	signature:(client *c)
ltrimCommand	t_list.c	/^void ltrimCommand(client *c) {$/;"	f	language:C	signature:(client *c)
lua	scripting.c	/^    lua_State *lua = lua_open();$/;"	l	language:C
lua	scripting.c	/^    lua_State *lua = server.lua;$/;"	l	language:C
lua	server.h	/^    lua_State *lua; \/* The Lua interpreter. We use just one for all clients *\/$/;"	m	language:C	struct:redisServer	access:public
luaCreateFunction	scripting.c	/^int luaCreateFunction(client *c, lua_State *lua, char *funcname, robj *body) {$/;"	f	language:C	signature:(client *c, lua_State *lua, char *funcname, robj *body)
luaLdbLineHook	scripting.c	/^void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {$/;"	f	language:C	signature:(lua_State *lua, lua_Debug *ar)
luaLdbLineHook	scripting.c	/^void luaLdbLineHook(lua_State *lua, lua_Debug *ar);$/;"	p	language:C	file:	signature:(lua_State *lua, lua_Debug *ar)
luaLoadLib	scripting.c	/^void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {$/;"	f	language:C	signature:(lua_State *lua, const char *libname, lua_CFunction luafunc)
luaLoadLibraries	scripting.c	/^void luaLoadLibraries(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaLogCommand	scripting.c	/^int luaLogCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaMaskCountHook	scripting.c	/^void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {$/;"	f	language:C	signature:(lua_State *lua, lua_Debug *ar)
luaPushError	scripting.c	/^void luaPushError(lua_State *lua, char *error) {$/;"	f	language:C	signature:(lua_State *lua, char *error)
luaRaiseError	scripting.c	/^int luaRaiseError(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisBreakpointCommand	scripting.c	/^int luaRedisBreakpointCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisCallCommand	scripting.c	/^int luaRedisCallCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisDebugCommand	scripting.c	/^int luaRedisDebugCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisErrorReplyCommand	scripting.c	/^int luaRedisErrorReplyCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisGenericCommand	scripting.c	/^int luaRedisGenericCommand(lua_State *lua, int raise_error) {$/;"	f	language:C	signature:(lua_State *lua, int raise_error)
luaRedisPCallCommand	scripting.c	/^int luaRedisPCallCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisReplicateCommandsCommand	scripting.c	/^int luaRedisReplicateCommandsCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisReturnSingleFieldTable	scripting.c	/^int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {$/;"	f	language:C	signature:(lua_State *lua, char *field)
luaRedisSetReplCommand	scripting.c	/^int luaRedisSetReplCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisSha1hexCommand	scripting.c	/^int luaRedisSha1hexCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRedisStatusReplyCommand	scripting.c	/^int luaRedisStatusReplyCommand(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaRemoveUnsupportedFunctions	scripting.c	/^void luaRemoveUnsupportedFunctions(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
luaReplyToRedisReply	scripting.c	/^void luaReplyToRedisReply(client *c, lua_State *lua) {$/;"	f	language:C	signature:(client *c, lua_State *lua)
luaSetGlobalArray	scripting.c	/^void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {$/;"	f	language:C	signature:(lua_State *lua, char *var, robj **elev, int elec)
luaSortArray	scripting.c	/^void luaSortArray(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
lua_always_replicate_commands	server.h	/^    int lua_always_replicate_commands; \/* Default replication type. *\/$/;"	m	language:C	struct:redisServer	access:public
lua_caller	server.h	/^    client *lua_caller;   \/* The client running EVAL right now, or NULL *\/$/;"	m	language:C	struct:redisServer	access:public
lua_client	server.h	/^    client *lua_client;   \/* The "fake client" to query Redis from Lua *\/$/;"	m	language:C	struct:redisServer	access:public
lua_kill	server.h	/^    int lua_kill;         \/* Kill the script if true. *\/$/;"	m	language:C	struct:redisServer	access:public
lua_multi_emitted	server.h	/^    int lua_multi_emitted;\/* True if we already proagated MULTI. *\/$/;"	m	language:C	struct:redisServer	access:public
lua_random_dirty	server.h	/^    int lua_random_dirty; \/* True if a random command was called during the$/;"	m	language:C	struct:redisServer	access:public
lua_repl	server.h	/^    int lua_repl;         \/* Script replication flags for redis.set_repl(). *\/$/;"	m	language:C	struct:redisServer	access:public
lua_replicate_commands	server.h	/^    int lua_replicate_commands; \/* True if we are doing single commands repl. *\/$/;"	m	language:C	struct:redisServer	access:public
lua_scripts	server.h	/^    dict *lua_scripts;         \/* A dictionary of SHA1 -> Lua scripts *\/$/;"	m	language:C	struct:redisServer	access:public
lua_time_limit	server.h	/^    mstime_t lua_time_limit;  \/* Script timeout in milliseconds *\/$/;"	m	language:C	struct:redisServer	access:public
lua_time_start	server.h	/^    mstime_t lua_time_start;  \/* Start time of script, milliseconds time *\/$/;"	m	language:C	struct:redisServer	access:public
lua_timedout	server.h	/^    int lua_timedout;     \/* True if we reached the time limit for script$/;"	m	language:C	struct:redisServer	access:public
lua_write_dirty	server.h	/^    int lua_write_dirty;  \/* True if a write command was called during the$/;"	m	language:C	struct:redisServer	access:public
luabp	scripting.c	/^    int luabp;  \/* Stop at next line because redis.breakpoint() was called. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
luaopen_bit	scripting.c	/^LUALIB_API int (luaopen_bit) (lua_State *L);$/;"	p	language:C	file:	signature:(lua_State *L)
luaopen_cjson	scripting.c	/^LUALIB_API int (luaopen_cjson) (lua_State *L);$/;"	p	language:C	file:	signature:(lua_State *L)
luaopen_cmsgpack	scripting.c	/^LUALIB_API int (luaopen_cmsgpack) (lua_State *L);$/;"	p	language:C	file:	signature:(lua_State *L)
luaopen_struct	scripting.c	/^LUALIB_API int (luaopen_struct) (lua_State *L);$/;"	p	language:C	file:	signature:(lua_State *L)
lv	quicklist.c	/^                long long lv;$/;"	l	language:C
lv	quicklist.c	/^            long long lv;$/;"	l	language:C
lzf	quicklist.c	/^            quicklistLZF *lzf = (quicklistLZF *)node->zl;$/;"	l	language:C
lzf	quicklist.c	/^    quicklistLZF *lzf = (quicklistLZF *)node->zl;$/;"	l	language:C
lzf_compress	lzf.h	/^lzf_compress (const void *const in_data,  unsigned int in_len,$/;"	p	language:C	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
lzf_compress	lzf_c.c	/^lzf_compress (const void *const in_data, unsigned int in_len,$/;"	f	language:C	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len , LZF_STATE htab )
lzf_decompress	lzf.h	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	p	language:C	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
lzf_decompress	lzf_d.c	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	f	language:C	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
lzf_movsb	lzf_d.c	/^# define lzf_movsb(/;"	d	language:C	file:
lzf_sz	quicklist.c	/^            size_t lzf_sz = sizeof(*lzf) + lzf->sz;$/;"	l	language:C
m	dict.c	/^    const uint32_t m = 0x5bd1e995;$/;"	l	language:C
m	hyperloglog.c	/^    const uint64_t m = 0xc6a4a7935bd1e995;$/;"	l	language:C
m	hyperloglog.c	/^    double m = HLL_REGISTERS;$/;"	l	language:C
m	memtest.c	/^    unsigned long *m = malloc(bytes);$/;"	l	language:C
m0	dict.c	/^    unsigned long m0, m1;$/;"	l	language:C
m1	dict.c	/^    unsigned long m0, m1;$/;"	l	language:C
mad	latency.h	/^    uint32_t mad;           \/* Mean absolute deviation. *\/$/;"	m	language:C	struct:latencyStats	access:public
magic	hyperloglog.c	/^    char magic[4];      \/* "HYLL" *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
magic	rdb.c	/^    char magic[10];$/;"	l	language:C
magic	redis-cli.c	/^    char magic[20]; \/* Special reply we recognize. *\/$/;"	l	language:C
main	redis-benchmark.c	/^int main(int argc, const char **argv) {$/;"	f	language:C	signature:(int argc, const char **argv)
main	redis-check-aof.c	/^int main(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
main	redis-cli.c	/^int main(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
main	sds.c	/^int main(void) {$/;"	f	language:C	signature:(void)
main	server.c	/^int main(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
makeObjectShared	object.c	/^robj *makeObjectShared(robj *o) {$/;"	f	language:C	signature:(robj *o)
makeObjectShared	server.h	/^robj *makeObjectShared(robj *o);$/;"	p	language:C	signature:(robj *o)
malloc	modules/TYPES.md	/^    #define malloc /;"	d	language:C	file:
malloc	server.h	/^void *malloc(size_t size) __attribute__ ((deprecated));$/;"	p	language:C	signature:(size_t size)
malloc	zmalloc.c	/^#define malloc(/;"	d	language:C	file:
management	modules/INTRO.md	/^management, covered later in this document, can be a good alternative, by$/;"	v	language:C
manualFailoverCheckTimeout	cluster.c	/^void manualFailoverCheckTimeout(void) {$/;"	f	language:C	signature:(void)
manual_failover	cluster.c	/^    int manual_failover = server.cluster->mf_end != 0 &&$/;"	l	language:C
margc	cluster.c	/^        int margc, *keyindex, numkeys, j;$/;"	l	language:C
margv	cluster.c	/^        robj **margv;$/;"	l	language:C
markNodeAsFailingIfNeeded	cluster.c	/^void markNodeAsFailingIfNeeded(clusterNode *node) {$/;"	f	language:C	signature:(clusterNode *node)
mask	ae.c	/^            int mask = eventLoop->fired[j].mask;$/;"	l	language:C
mask	ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	language:C	struct:aeFileEvent	access:public
mask	ae.h	/^    int mask;$/;"	m	language:C	struct:aeFiredEvent	access:public
mask	ae_epoll.c	/^            int mask = 0;$/;"	l	language:C
mask	ae_epoll.c	/^    int mask = eventLoop->events[fd].mask & (~delmask);$/;"	l	language:C
mask	ae_evport.c	/^    int mask, i;$/;"	l	language:C
mask	ae_kqueue.c	/^            int mask = 0;$/;"	l	language:C
mask	ae_select.c	/^            int mask = 0;$/;"	l	language:C
mask	bitops.c	/^        uint64_t mask = ((uint64_t)-1) << bits;$/;"	l	language:C
mask	dict.c	/^    unsigned long mask = ~0;$/;"	l	language:C
mask	intset.c	/^    uint64_t mask = (1<<bits)-1;$/;"	l	language:C
mask	redis-cli.c	/^        int mask = AE_READABLE;$/;"	l	language:C
mask	redis-cli.c	/^    int mask;$/;"	l	language:C
master	cluster.c	/^                clusterNode *master = clusterLookupNode(hdr->slaveof);$/;"	l	language:C
master	cluster.c	/^        clusterNode *n, *master;$/;"	l	language:C
master	cluster.c	/^    clusterNode *master = node->slaveof;$/;"	l	language:C
master	cluster.c	/^    clusterNode *master;$/;"	l	language:C
master	sentinel.c	/^        sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ?$/;"	l	language:C
master	sentinel.c	/^        sentinelRedisInstance *master = dictGetVal(de), *match;$/;"	l	language:C
master	sentinel.c	/^        sentinelRedisInstance *master, *ri;$/;"	l	language:C
master	sentinel.c	/^    sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ? ri : ri->master;$/;"	l	language:C
master	sentinel.c	/^    sentinelRedisInstance *si, *master;$/;"	l	language:C
master	sentinel.c	/^    struct sentinelRedisInstance *master; \/* Master instance if it's slave. *\/$/;"	m	language:C	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
master	server.h	/^    client *master;     \/* Client that is master for this slave *\/$/;"	m	language:C	struct:redisServer	access:public
masterTryPartialResynchronization	replication.c	/^int masterTryPartialResynchronization(client *c) {$/;"	f	language:C	signature:(client *c)
master_addr	sentinel.c	/^        sentinelAddr *master_addr;$/;"	l	language:C
master_addr	sentinel.c	/^    sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);$/;"	l	language:C
master_config_epoch	sentinel.c	/^    uint64_t current_epoch, master_config_epoch;$/;"	l	language:C
master_id	sentinel.c	/^        int master_id = 0;$/;"	l	language:C
master_link_down_time	sentinel.c	/^    mstime_t master_link_down_time; \/* Slave replication link down time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
master_port	sentinel.c	/^    int numtokens, port, removed, master_port;$/;"	l	language:C
master_repl_offset	server.h	/^    long long master_repl_offset;   \/* Global replication offset *\/$/;"	m	language:C	struct:redisServer	access:public
master_runid	replication.c	/^            char *master_runid = c->argv[1]->ptr;$/;"	l	language:C
master_runid	replication.c	/^    char *master_runid = c->argv[1]->ptr;$/;"	l	language:C
masterauth	server.h	/^    char *masterauth;               \/* AUTH with this password with master *\/$/;"	m	language:C	struct:redisServer	access:public
masterdownerr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
masterhost	server.h	/^    char *masterhost;               \/* Hostname of master *\/$/;"	m	language:C	struct:redisServer	access:public
masterport	server.h	/^    int masterport;                 \/* Port of master *\/$/;"	m	language:C	struct:redisServer	access:public
masters	sentinel.c	/^    dict *masters;      \/* Dictionary of master sentinelRedisInstances.$/;"	m	language:C	struct:sentinelState	file:	access:public
masters_local	sentinel.c	/^        dict *masters_local = sentinel.masters;$/;"	l	language:C
match	adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	language:C	struct:list	access:public
match	sentinel.c	/^        sentinelRedisInstance *master = dictGetVal(de), *match;$/;"	l	language:C
match	util.c	/^            int not, match;$/;"	l	language:C
matches	config.c	/^    int matches = 0;$/;"	l	language:C
matchlen	redis-cli.c	/^    size_t matchlen;$/;"	l	language:C
max	bitops.c	/^    int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);$/;"	l	language:C
max	bitops.c	/^    uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);$/;"	l	language:C
max	cluster.c	/^    int max = MAX_CLUSTER_ACCEPTS_PER_CALL;$/;"	l	language:C
max	cluster.c	/^    uint64_t max = 0;$/;"	l	language:C
max	geo.c	/^    GeoHashFix52Bits min, max;$/;"	l	language:C
max	geohash.h	/^    double max;$/;"	m	language:C	struct:__anon15	access:public
max	hyperloglog.c	/^        uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;$/;"	l	language:C
max	hyperloglog.c	/^    uint8_t max[HLL_REGISTERS];$/;"	l	language:C
max	intset.c	/^    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;$/;"	l	language:C
max	latency.c	/^    uint32_t min = 0, max = 0;$/;"	l	language:C
max	latency.h	/^    uint32_t max;           \/* Max of current samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
max	latency.h	/^    uint32_t max; \/* Max latency observed for this event. *\/$/;"	m	language:C	struct:latencyTimeSeries	access:public
max	networking.c	/^    int cfd, max = MAX_ACCEPTS_PER_CALL;$/;"	l	language:C
max	networking.c	/^    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;$/;"	l	language:C
max	rdb.c	/^        double max = 4503599627370496; \/* -(2^52) *\/$/;"	l	language:C
max	redis-cli.c	/^    long long max;   \/* Max latency to fit into this interval (usec). *\/$/;"	m	language:C	struct:distsamples	file:	access:public
max	redis-cli.c	/^    long long start, latency, min = 0, max = 0, tot = 0, count = 0;$/;"	l	language:C
max	server.h	/^    double min, max;$/;"	m	language:C	struct:__anon35	access:public
max	server.h	/^    sds min, max;     \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	language:C	struct:__anon36	access:public
max	sparkline.h	/^    double min, max;$/;"	m	language:C	struct:sequence	access:public
max	util.c	/^        double max = 4503599627370496; \/* -(2^52) *\/$/;"	l	language:C
maxEpoch	cluster.c	/^    uint64_t maxEpoch = clusterGetMaxEpoch();$/;"	l	language:C
maxId	ae.c	/^    long long maxId;$/;"	l	language:C
max_idle	replication.c	/^        time_t idle, max_idle = 0;$/;"	l	language:C
max_lat	geohash_helper.c	/^    double min_lon, max_lon, min_lat, max_lat;$/;"	l	language:C
max_latency	redis-cli.c	/^    long long test_end, run_time, max_latency = 0, runs = 0;$/;"	l	language:C
max_latitude	geohash_helper.c	/^    double max_latitude = latr + distance;$/;"	l	language:C
max_lon	geohash_helper.c	/^    double min_lon, max_lon, min_lat, max_lat;$/;"	l	language:C
max_longitude	geohash_helper.c	/^    double min_longitude, max_longitude;$/;"	l	language:C
max_master_down_time	sentinel.c	/^    mstime_t max_master_down_time = 0;$/;"	l	language:C
max_processing_chunk	rio.h	/^    size_t max_processing_chunk;$/;"	m	language:C	struct:_rio	access:public
max_slaves	cluster.c	/^    int max_slaves; \/* Max number of ok slaves for a single master. *\/$/;"	l	language:C
max_votes	sentinel.c	/^    uint64_t max_votes = 0;$/;"	l	language:C
maxchainlen	dict.c	/^    unsigned long i, slots = 0, chainlen, maxchainlen = 0;$/;"	l	language:C
maxclients	server.h	/^    unsigned int maxclients;            \/* Max number of simultaneous clients *\/$/;"	m	language:C	struct:redisServer	access:public
maxelelen	geo.c	/^        size_t maxelelen = 0;$/;"	l	language:C
maxelelen	rdb.c	/^        size_t maxelelen = 0;$/;"	l	language:C
maxelelen	t_zset.c	/^    unsigned int maxelelen = 0;$/;"	l	language:C
maxerr	hyperloglog.c	/^            uint64_t maxerr = ceil(relerr*6*checkpoint);$/;"	l	language:C
maxex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon35	access:public
maxex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon36	access:public
maxfd	ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	language:C	struct:aeEventLoop	access:public
maxfiles	server.c	/^    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;$/;"	l	language:C
maxidletime	server.h	/^    int maxidletime;                \/* Client timeout in seconds *\/$/;"	m	language:C	struct:redisServer	access:public
maxidx	t_zset.c	/^    int minidx, maxidx;$/;"	l	language:C
maxincr	bitops.c	/^    int64_t maxincr = max-value;$/;"	l	language:C
maxiterations	cluster.c	/^    int maxiterations = wanted*3;$/;"	l	language:C
maxiterations	db.c	/^        long maxiterations = count*10;$/;"	l	language:C
maxkeys	cluster.c	/^        long long maxkeys, slot;$/;"	l	language:C
maxkeys	redis-cli.c	/^    sds maxkeys[5] = {0};$/;"	l	language:C
maxlen	bitops.c	/^    unsigned long *len, maxlen = 0; \/* Array of length of src strings,$/;"	l	language:C
maxlen	lzf_c.c	/^          unsigned int maxlen = in_end - ip - len;$/;"	l	language:C
maxlen	rdb.c	/^                    unsigned int maxlen = 0;$/;"	l	language:C
maxlen	scripting.c	/^    size_t maxlen;  \/* Max var dump \/ reply length. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
maxlen_hint_sent	scripting.c	/^    int maxlen_hint_sent; \/* Did we already hint about "set maxlen"? *\/$/;"	m	language:C	struct:ldbState	file:	access:public
maxline	cluster.c	/^    int maxline, j;$/;"	l	language:C
maxmemory	server.h	/^    unsigned long long maxmemory;   \/* Max number of memory bytes to use *\/$/;"	m	language:C	struct:redisServer	access:public
maxmemory_hmem	server.c	/^        char maxmemory_hmem[64];$/;"	l	language:C
maxmemory_policy	server.h	/^    int maxmemory_policy;           \/* Policy for key eviction *\/$/;"	m	language:C	struct:redisServer	access:public
maxmemory_policy_enum	config.c	/^configEnum maxmemory_policy_enum[] = {$/;"	v	language:C
maxmemory_samples	server.h	/^    int maxmemory_samples;          \/* Pricision of random sampling *\/$/;"	m	language:C	struct:redisServer	access:public
maxsizemask	dict.c	/^    unsigned long stored = 0, maxsizemask;$/;"	l	language:C
maxsteps	dict.c	/^    unsigned long maxsteps;$/;"	l	language:C
maxstring	server.h	/^    sds minstring, maxstring;$/;"	m	language:C	struct:sharedObjectsStruct	access:public
maxtime	cluster.c	/^    mstime_t maxtime = server.cluster_node_timeout *$/;"	l	language:C
maxtries	replication.c	/^    int dfd, maxtries = 5;$/;"	l	language:C
maxval	ziplist.c	/^    int minval, maxval;$/;"	l	language:C
may_retry	cluster.c	/^    int may_retry = 1;$/;"	l	language:C
mb	config.c	/^    int mb = 1024*1024;$/;"	l	language:C
mb_delim	redis-cli.c	/^    sds mb_delim;$/;"	m	language:C	struct:config	file:	access:public
mbcount	replication.c	/^        void *mbcount;$/;"	l	language:C
mbl	sentinel.c	/^    void *mbl;$/;"	l	language:C
mblen	pubsub.c	/^        long mblen = 0;$/;"	l	language:C
mbulkhdr	server.h	/^    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], \/* "*<value>\\r\\n" *\/$/;"	m	language:C	struct:sharedObjectsStruct	access:public
mbulklen	scripting.c	/^            int j = 1, mbulklen = 0;$/;"	l	language:C
mbulklen	scripting.c	/^    long long mbulklen;$/;"	l	language:C
mc	cluster.c	/^    multiCmd mc;$/;"	l	language:C
mc	multi.c	/^        multiCmd *mc = c->mstate.commands+j;$/;"	l	language:C
mc	multi.c	/^    multiCmd *mc;$/;"	l	language:C
mcmd	cluster.c	/^        struct redisCommand *mcmd;$/;"	l	language:C
med3	pqsort.c	/^med3(char *a, char *b, char *c,$/;"	f	language:C	file:	signature:(char *a, char *b, char *c, int (*cmp) (const void *, const void *))
med3	pqsort.c	/^static inline char	*med3 (char *, char *, char *,$/;"	p	language:C	file:	signature:(char *, char *, char *, int (*)(const void *, const void *))
mem_freed	evict.c	/^    size_t mem_reported, mem_used, mem_tofree, mem_freed;$/;"	l	language:C
mem_reported	evict.c	/^    size_t mem_reported, mem_used, mem_tofree, mem_freed;$/;"	l	language:C
mem_tofree	evict.c	/^    size_t mem_reported, mem_used, mem_tofree, mem_freed;$/;"	l	language:C
mem_used	evict.c	/^    size_t mem_reported, mem_used, mem_tofree, mem_freed;$/;"	l	language:C
member	geo.c	/^        robj *member = c->argv[2];$/;"	l	language:C
member	geo.c	/^    sds member;$/;"	l	language:C
member	geo.h	/^    char *member;$/;"	m	language:C	struct:geoPoint	access:public
membersOfAllNeighbors	geo.c	/^int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, double lon, double lat, double radius, geoArray *ga) {$/;"	f	language:C	signature:(robj *zobj, GeoHashRadius n, double lon, double lat, double radius, geoArray *ga)
membersOfGeoHashBox	geo.c	/^int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, double lon, double lat, double radius) {$/;"	f	language:C	signature:(robj *zobj, GeoHashBits hash, geoArray *ga, double lon, double lat, double radius)
memcmp	ziplist.c	/^                assert(memcmp(buf,listNodeValue(refnode),buflen) == 0);$/;"	p	language:C	file:	signature:(buf,listNodeValue(refnode),buflen)
memory	module.c	/^    char memory[];$/;"	m	language:C	struct:RedisModulePoolAllocBlock	file:	access:public
memory	modules/API.md	/^Redis INFO memory, used for keys eviction according to maxmemory settings$/;"	v	language:C
memory_lua	server.c	/^        long long memory_lua = (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024;$/;"	l	language:C
memrev16	endianconv.c	/^void memrev16(void *p) {$/;"	f	language:C	signature:(void *p)
memrev16	endianconv.h	/^void memrev16(void *p);$/;"	p	language:C	signature:(void *p)
memrev16ifbe	endianconv.h	/^#define memrev16ifbe(/;"	d	language:C
memrev32	endianconv.c	/^void memrev32(void *p) {$/;"	f	language:C	signature:(void *p)
memrev32	endianconv.h	/^void memrev32(void *p);$/;"	p	language:C	signature:(void *p)
memrev32ifbe	endianconv.h	/^#define memrev32ifbe(/;"	d	language:C
memrev64	endianconv.c	/^void memrev64(void *p) {$/;"	f	language:C	signature:(void *p)
memrev64	endianconv.h	/^void memrev64(void *p);$/;"	p	language:C	signature:(void *p)
memrev64ifbe	endianconv.h	/^#define memrev64ifbe(/;"	d	language:C
memtest	memtest.c	/^void memtest(size_t megabytes, int passes) {$/;"	f	language:C	signature:(size_t megabytes, int passes)
memtest	server.c	/^void memtest(size_t megabytes, int passes);$/;"	p	language:C	file:	signature:(size_t megabytes, int passes)
memtest_addressing	memtest.c	/^int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {$/;"	f	language:C	signature:(unsigned long *l, size_t bytes, int interactive)
memtest_alloc_and_test	memtest.c	/^void memtest_alloc_and_test(size_t megabytes, int passes) {$/;"	f	language:C	signature:(size_t megabytes, int passes)
memtest_compare	memtest.c	/^int memtest_compare(unsigned long *l, size_t bytes, int interactive) {$/;"	f	language:C	signature:(unsigned long *l, size_t bytes, int interactive)
memtest_compare_times	memtest.c	/^int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,$/;"	f	language:C	signature:(unsigned long *m, size_t bytes, int pass, int times, int interactive)
memtest_fill_random	memtest.c	/^void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {$/;"	f	language:C	signature:(unsigned long *l, size_t bytes, int interactive)
memtest_fill_value	memtest.c	/^void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,$/;"	f	language:C	signature:(unsigned long *l, size_t bytes, unsigned long v1, unsigned long v2, char sym, int interactive)
memtest_preserving_test	memtest.c	/^int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {$/;"	f	language:C	signature:(unsigned long *m, size_t bytes, int passes)
memtest_preserving_test	server.h	/^int memtest_preserving_test(unsigned long *m, size_t bytes, int passes);$/;"	p	language:C	signature:(unsigned long *m, size_t bytes, int passes)
memtest_progress_end	memtest.c	/^void memtest_progress_end(void) {$/;"	f	language:C	signature:(void)
memtest_progress_start	memtest.c	/^void memtest_progress_start(char *title, int pass) {$/;"	f	language:C	signature:(char *title, int pass)
memtest_progress_step	memtest.c	/^void memtest_progress_step(size_t curr, size_t size, char c) {$/;"	f	language:C	signature:(size_t curr, size_t size, char c)
memtest_test	memtest.c	/^int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {$/;"	f	language:C	signature:(unsigned long *m, size_t bytes, int passes, int interactive)
memtest_test_linux_anonymous_maps	debug.c	/^int memtest_test_linux_anonymous_maps(void) {$/;"	f	language:C	signature:(void)
memtoll	util.c	/^long long memtoll(const char *p, int *err) {$/;"	f	language:C	signature:(const char *p, int *err)
memtoll	util.h	/^long long memtoll(const char *p, int *err);$/;"	p	language:C	signature:(const char *p, int *err)
merge_sz	quicklist.c	/^    unsigned int merge_sz = a->sz + b->sz - 11;$/;"	l	language:C
message	cluster.c	/^        robj *channel, *message;$/;"	l	language:C
message_len	cluster.c	/^        uint32_t channel_len, message_len;$/;"	l	language:C
message_len	cluster.c	/^    uint32_t channel_len, message_len;$/;"	l	language:C
message_len	cluster.h	/^    uint32_t message_len;$/;"	m	language:C	struct:__anon4	access:public
messagebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
mf_can_start	cluster.h	/^    int mf_can_start;           \/* If non-zero signal that the manual failover$/;"	m	language:C	struct:clusterState	access:public
mf_end	cluster.h	/^    mstime_t mf_end;            \/* Manual failover time limit (ms unixtime).$/;"	m	language:C	struct:clusterState	access:public
mf_master_offset	cluster.h	/^    long long mf_master_offset; \/* Master offset the slave needs to start MF$/;"	m	language:C	struct:clusterState	access:public
mf_slave	cluster.h	/^    clusterNode *mf_slave;      \/* Slave performing the manual failover. *\/$/;"	m	language:C	struct:clusterState	access:public
mflags	cluster.h	/^    unsigned char mflags[3]; \/* Message flags: CLUSTERMSG_FLAG[012]_... *\/$/;"	m	language:C	struct:__anon10	access:public
mgetCommand	server.h	/^void mgetCommand(client *c);$/;"	p	language:C	signature:(client *c)
mgetCommand	t_string.c	/^void mgetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
mib	zmalloc.c	/^    int mib[2];$/;"	l	language:C
microseconds	server.h	/^    long long microseconds, calls;$/;"	m	language:C	struct:redisCommand	access:public
mid	intset.c	/^    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;$/;"	l	language:C
migrateCacheDictType	server.c	/^dictType migrateCacheDictType = {$/;"	v	language:C
migrateCachedSocket	cluster.c	/^typedef struct migrateCachedSocket {$/;"	s	language:C	file:
migrateCachedSocket	cluster.c	/^} migrateCachedSocket;$/;"	t	language:C	typeref:struct:migrateCachedSocket	file:
migrateCachedSocket::fd	cluster.c	/^    int fd;$/;"	m	language:C	struct:migrateCachedSocket	file:	access:public
migrateCachedSocket::last_dbid	cluster.c	/^    long last_dbid;$/;"	m	language:C	struct:migrateCachedSocket	file:	access:public
migrateCachedSocket::last_use_time	cluster.c	/^    time_t last_use_time;$/;"	m	language:C	struct:migrateCachedSocket	file:	access:public
migrateCloseSocket	cluster.c	/^void migrateCloseSocket(robj *host, robj *port) {$/;"	f	language:C	signature:(robj *host, robj *port)
migrateCloseTimedoutSockets	cluster.c	/^void migrateCloseTimedoutSockets(void) {$/;"	f	language:C	signature:(void)
migrateCloseTimedoutSockets	server.h	/^void migrateCloseTimedoutSockets(void);$/;"	p	language:C	signature:(void)
migrateCommand	cluster.c	/^void migrateCommand(client *c) {$/;"	f	language:C	signature:(client *c)
migrateCommand	server.h	/^void migrateCommand(client *c);$/;"	p	language:C	signature:(client *c)
migrateGetKeys	db.c	/^int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
migrateGetKeys	server.h	/^int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
migrateGetSocket	cluster.c	/^migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long timeout) {$/;"	f	language:C	signature:(client *c, robj *host, robj *port, long timeout)
migrate_cached_sockets	server.h	/^    dict *migrate_cached_sockets;\/* MIGRATE cached sockets *\/$/;"	m	language:C	struct:redisServer	access:public
migrating_slot	cluster.c	/^    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;$/;"	l	language:C
migrating_slots_to	cluster.h	/^    clusterNode *migrating_slots_to[CLUSTER_SLOTS];$/;"	m	language:C	struct:clusterState	access:public
milliseconds	t_string.c	/^    long long milliseconds = 0; \/* initialized to avoid any harmness warning *\/$/;"	l	language:C
min	bitops.c	/^    int64_t min = (-max)-1;$/;"	l	language:C
min	geo.c	/^    GeoHashFix52Bits min, max;$/;"	l	language:C
min	geohash.h	/^    double min;$/;"	m	language:C	struct:__anon15	access:public
min	intset.c	/^    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;$/;"	l	language:C
min	latency.c	/^    uint32_t min = 0, max = 0;$/;"	l	language:C
min	latency.h	/^    uint32_t min;           \/* Min of current samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
min	pqsort.c	/^#define min(/;"	d	language:C	file:
min	rdb.c	/^        double min = -4503599627370495; \/* (2^52)-1 *\/$/;"	l	language:C
min	redis-cli.c	/^    long long start, latency, min = 0, max = 0, tot = 0, count = 0;$/;"	l	language:C
min	server.h	/^    double min, max;$/;"	m	language:C	struct:__anon35	access:public
min	server.h	/^    sds min, max;     \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	language:C	struct:__anon36	access:public
min	sparkline.h	/^    double min, max;$/;"	m	language:C	struct:sequence	access:public
min	util.c	/^        double min = -4503599627370495; \/* (2^52)-1 *\/$/;"	l	language:C
min_lat	geohash_helper.c	/^    double min_lon, max_lon, min_lat, max_lat;$/;"	l	language:C
min_latitude	geohash_helper.c	/^    double min_latitude = latr - distance;$/;"	l	language:C
min_lon	geohash_helper.c	/^    double min_lon, max_lon, min_lat, max_lat;$/;"	l	language:C
min_longitude	geohash_helper.c	/^    double min_longitude, max_longitude;$/;"	l	language:C
min_period	debug.c	/^    int min_period;$/;"	l	language:C
min_pong	cluster.c	/^    mstime_t min_pong = 0, now = mstime();$/;"	l	language:C
min_pong_node	cluster.c	/^    clusterNode *min_pong_node = NULL;$/;"	l	language:C
mincapa	replication.c	/^        int mincapa = -1;$/;"	l	language:C
mincapa	replication.c	/^    int mincapa = -1;$/;"	l	language:C
minex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon35	access:public
minex	server.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	language:C	struct:__anon36	access:public
minidx	t_zset.c	/^    int minidx, maxidx;$/;"	l	language:C
minimal	dict.c	/^    int minimal;$/;"	l	language:C
minincr	bitops.c	/^    int64_t minincr = -value;$/;"	l	language:C
minincr	bitops.c	/^    int64_t minincr = min-value;$/;"	l	language:C
minlen	bitops.c	/^    unsigned long minlen = 0;    \/* Min len among the input keys. *\/$/;"	l	language:C
minlen	object.c	/^    size_t alen, blen, minlen;$/;"	l	language:C
minlen	sds.c	/^    size_t l1, l2, minlen;$/;"	l	language:C
minlen	t_zset.c	/^    int minlen, cmp;$/;"	l	language:C
minreplicas	server.h	/^    int minreplicas;        \/* MINREPLICAS for synchronous replication *\/$/;"	m	language:C	struct:multiState	access:public
minreplicas_timeout	server.h	/^    time_t minreplicas_timeout; \/* MINREPLICAS timeout as unixtime. *\/$/;"	m	language:C	struct:multiState	access:public
minstring	server.h	/^    sds minstring, maxstring;$/;"	m	language:C	struct:sharedObjectsStruct	access:public
minval	ziplist.c	/^    int minval, maxval;$/;"	l	language:C
misses	redis-cli.c	/^        long long hits = 0, misses = 0;$/;"	l	language:C
missing_keys	cluster.c	/^    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;$/;"	l	language:C
mixDigest	debug.c	/^void mixDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f	language:C	signature:(unsigned char *digest, void *ptr, size_t len)
mixObjectDigest	debug.c	/^void mixObjectDigest(unsigned char *digest, robj *o) {$/;"	f	language:C	signature:(unsigned char *digest, robj *o)
mode	module.c	/^    int mode;       \/* Opening mode. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
mode	server.c	/^        char *mode;$/;"	l	language:C
mode	server.c	/^    char *mode;$/;"	l	language:C
module	module.c	/^            struct RedisModule *module = dictGetVal(de);$/;"	l	language:C
module	module.c	/^        struct RedisModule *module = dictGetVal(de);$/;"	l	language:C
module	module.c	/^    RedisModule *module;$/;"	l	language:C
module	module.c	/^    struct RedisModule *module = dictFetchValue(modules,name);$/;"	l	language:C
module	module.c	/^    struct RedisModule *module;     \/* Module reference. *\/$/;"	m	language:C	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::RedisModule	file:	access:public
module	module.c	/^    struct RedisModule *module;$/;"	m	language:C	struct:RedisModuleCommandProxy	typeref:struct:RedisModuleCommandProxy::RedisModule	file:	access:public
module	modules/TYPES.md	/^This is not just useful in order for Redis to be able to account for the memory used by the module, but there are also more advantages:$/;"	v	language:C
module	modules/TYPES.md	/^of the author of the module, to create a 9 character unique name.$/;"	v	language:C
module	server.h	/^    struct RedisModule *module;$/;"	m	language:C	struct:RedisModuleType	typeref:struct:RedisModuleType::RedisModule	access:public
moduleAPIDictType	module.c	/^dictType moduleAPIDictType = {$/;"	v	language:C
moduleAssertUnsharedString	module.c	/^RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {$/;"	f	language:C	signature:(RedisModuleString *str)
moduleCommand	module.c	/^void moduleCommand(client *c) {$/;"	f	language:C	signature:(client *c)
moduleCommand	server.h	/^void moduleCommand(client *c);$/;"	p	language:C	signature:(client *c)
moduleCreateArgvFromUserFormat	module.c	/^robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {$/;"	f	language:C	signature:(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap)
moduleCreateArgvFromUserFormat	module.c	/^robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap);$/;"	p	language:C	file:	signature:(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap)
moduleCreateCallReplyFromProto	module.c	/^RedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, sds proto)
moduleCreateEmptyKey	module.c	/^int moduleCreateEmptyKey(RedisModuleKey *key, int type) {$/;"	f	language:C	signature:(RedisModuleKey *key, int type)
moduleDelKeyIfEmpty	module.c	/^int moduleDelKeyIfEmpty(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
moduleFreeContext	module.c	/^void moduleFreeContext(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
moduleFreeModuleStructure	module.c	/^void moduleFreeModuleStructure(struct RedisModule *module) {$/;"	f	language:C	signature:(struct RedisModule *module)
moduleGetCommandKeysViaAPI	module.c	/^int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
moduleGetCommandKeysViaAPI	server.h	/^int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
moduleInitIOContext	server.h	/^#define moduleInitIOContext(/;"	d	language:C
moduleInitModulesSystem	module.c	/^void moduleInitModulesSystem(void) {$/;"	f	language:C	signature:(void)
moduleInitModulesSystem	server.h	/^void moduleInitModulesSystem(void);$/;"	p	language:C	signature:(void)
moduleLoad	module.c	/^int moduleLoad(const char *path, void **module_argv, int module_argc) {$/;"	f	language:C	signature:(const char *path, void **module_argv, int module_argc)
moduleLoad	server.h	/^int moduleLoad(const char *path, void **argv, int argc);$/;"	p	language:C	signature:(const char *path, void **argv, int argc)
moduleLoadFromQueue	module.c	/^void moduleLoadFromQueue(void) {$/;"	f	language:C	signature:(void)
moduleLoadFromQueue	server.h	/^void moduleLoadFromQueue(void);$/;"	p	language:C	signature:(void)
moduleLoadQueueEntry	server.h	/^struct moduleLoadQueueEntry {$/;"	s	language:C
moduleLoadQueueEntry::argc	server.h	/^    int argc;$/;"	m	language:C	struct:moduleLoadQueueEntry	access:public
moduleLoadQueueEntry::argv	server.h	/^    robj **argv;$/;"	m	language:C	struct:moduleLoadQueueEntry	access:public
moduleLoadQueueEntry::path	server.h	/^    sds path;$/;"	m	language:C	struct:moduleLoadQueueEntry	access:public
moduleLoadString	module.c	/^void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {$/;"	f	language:C	signature:(RedisModuleIO *io, int plain, size_t *lenptr)
moduleParseCallReply	module.c	/^void moduleParseCallReply(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_Array	module.c	/^void moduleParseCallReply_Array(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_Array	module.c	/^void moduleParseCallReply_Array(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_BulkString	module.c	/^void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_BulkString	module.c	/^void moduleParseCallReply_BulkString(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_Int	module.c	/^void moduleParseCallReply_Int(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_Int	module.c	/^void moduleParseCallReply_Int(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_SimpleString	module.c	/^void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {$/;"	f	language:C	signature:(RedisModuleCallReply *reply)
moduleParseCallReply_SimpleString	module.c	/^void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);$/;"	p	language:C	file:	signature:(RedisModuleCallReply *reply)
moduleRDBLoadError	module.c	/^void moduleRDBLoadError(RedisModuleIO *io) {$/;"	f	language:C	signature:(RedisModuleIO *io)
moduleRegisterApi	module.c	/^int moduleRegisterApi(const char *funcname, void *funcptr) {$/;"	f	language:C	signature:(const char *funcname, void *funcptr)
moduleRegisterCoreAPI	module.c	/^void moduleRegisterCoreAPI(void) {$/;"	f	language:C	signature:(void)
moduleRegisterCoreAPI	module.c	/^void moduleRegisterCoreAPI(void);$/;"	p	language:C	file:	signature:(void)
moduleReplicateMultiIfNeeded	module.c	/^void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
moduleReplicateMultiIfNeeded	module.c	/^void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx)
moduleType	server.h	/^} moduleType;$/;"	t	language:C	typeref:struct:RedisModuleType
moduleTypeDigestFunc	server.h	/^typedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);$/;"	t	language:C
moduleTypeEncodeId	module.c	/^uint64_t moduleTypeEncodeId(const char *name, int encver) {$/;"	f	language:C	signature:(const char *name, int encver)
moduleTypeFreeFunc	server.h	/^typedef void (*moduleTypeFreeFunc)(void *value);$/;"	t	language:C
moduleTypeLoadFunc	server.h	/^typedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);$/;"	t	language:C
moduleTypeLookupModuleByID	module.c	/^moduleType *moduleTypeLookupModuleByID(uint64_t id) {$/;"	f	language:C	signature:(uint64_t id)
moduleTypeLookupModuleByID	server.h	/^moduleType *moduleTypeLookupModuleByID(uint64_t id);$/;"	p	language:C	signature:(uint64_t id)
moduleTypeLookupModuleByName	module.c	/^moduleType *moduleTypeLookupModuleByName(const char *name) {$/;"	f	language:C	signature:(const char *name)
moduleTypeNameByID	module.c	/^void moduleTypeNameByID(char *name, uint64_t moduleid) {$/;"	f	language:C	signature:(char *name, uint64_t moduleid)
moduleTypeNameByID	server.h	/^void moduleTypeNameByID(char *name, uint64_t moduleid);$/;"	p	language:C	signature:(char *name, uint64_t moduleid)
moduleTypeRewriteFunc	server.h	/^typedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);$/;"	t	language:C
moduleTypeSaveFunc	server.h	/^typedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);$/;"	t	language:C
moduleUnload	module.c	/^int moduleUnload(sds name) {$/;"	f	language:C	signature:(sds name)
moduleValue	server.h	/^typedef struct moduleValue {$/;"	s	language:C
moduleValue	server.h	/^} moduleValue;$/;"	t	language:C	typeref:struct:moduleValue
moduleValue::type	server.h	/^    moduleType *type;$/;"	m	language:C	struct:moduleValue	access:public
moduleValue::value	server.h	/^    void *value;$/;"	m	language:C	struct:moduleValue	access:public
moduleapi	server.h	/^    dict *moduleapi;            \/* Exported APIs dictionary for modules. *\/$/;"	m	language:C	struct:redisServer	access:public
moduleid	rdb.c	/^        uint64_t moduleid = rdbLoadLen(rdb,NULL);$/;"	l	language:C
modules	module.c	/^static dict *modules; \/* Hash table of modules. SDS -> RedisModule ptr.*\/$/;"	v	language:C	file:
modules	modules/INTRO.md	/^Most Redis modules, in order to be useful, have to interact with the Redis$/;"	v	language:C
modules	modules/INTRO.md	/^`RedisModule_CreateCommand` will fail in one of the modules, so the module$/;"	v	language:C
modules	modules/TYPES.md	/^Native types in Redis modules$/;"	v	language:C
modulesDictType	server.c	/^dictType modulesDictType = {$/;"	v	language:C
modulesDictType	server.h	/^extern dictType modulesDictType;$/;"	x	language:C
monitor	replication.c	/^        client *monitor = ln->value;$/;"	l	language:C
monitorCommand	server.c	/^void monitorCommand(client *c) {$/;"	f	language:C	signature:(client *c)
monitorCommand	server.h	/^void monitorCommand(client *c);$/;"	p	language:C	signature:(client *c)
monitor_mode	redis-cli.c	/^    int monitor_mode;$/;"	m	language:C	struct:config	file:	access:public
monitors	server.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	language:C	struct:redisServer	access:public
moreargs	networking.c	/^                int moreargs = c->argc > i+1;$/;"	l	language:C
most_recent	sentinel.c	/^    mstime_t most_recent;$/;"	l	language:C
moveCommand	db.c	/^void moveCommand(client *c) {$/;"	f	language:C	signature:(client *c)
moveCommand	server.h	/^void moveCommand(client *c);$/;"	p	language:C	signature:(client *c)
ms	ae.c	/^            long long ms =$/;"	l	language:C
ms	cluster.c	/^    multiState *ms, _ms;$/;"	l	language:C
msb	bitops.c	/^        uint64_t msb = (uint64_t)1 << (bits-1);$/;"	l	language:C
msetCommand	server.h	/^void msetCommand(client *c);$/;"	p	language:C	signature:(client *c)
msetCommand	t_string.c	/^void msetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
msetGenericCommand	t_string.c	/^void msetGenericCommand(client *c, int nx) {$/;"	f	language:C	signature:(client *c, int nx)
msetnxCommand	server.h	/^void msetnxCommand(client *c);$/;"	p	language:C	signature:(client *c)
msetnxCommand	t_string.c	/^void msetnxCommand(client *c) {$/;"	f	language:C	signature:(client *c)
msg	cluster.c	/^    char *msg;$/;"	l	language:C
msg	cluster.h	/^        clusterMsgDataPublish msg;$/;"	m	language:C	struct:clusterMsgData::__anon8	access:public
msg	module.c	/^    char msg[LOG_MAX_LEN];$/;"	l	language:C
msg	rdb.c	/^            void *msg = zmalloc(sizeof(uint64_t)*(1+2*numfds));$/;"	l	language:C
msg	rdb.c	/^    char msg[1024];$/;"	l	language:C
msg	redis-check-rdb.c	/^    char msg[1024];$/;"	l	language:C
msg	scripting.c	/^        sds msg = sdscatprintf(sdsempty(), "%s: %d: %s",$/;"	l	language:C
msg	sentinel.c	/^    char msg[LOG_MAX_LEN];$/;"	l	language:C
msg	server.c	/^    char *msg;$/;"	l	language:C
msg	server.c	/^    char msg[LOG_MAX_LEN];$/;"	l	language:C
msg1	debug.c	/^        char *msg1 = "EIP:\\n";$/;"	l	language:C
msg2	debug.c	/^        char *msg2 = "\\nBacktrace:\\n";$/;"	l	language:C
msglen	rdb.c	/^            int j, msglen;$/;"	l	language:C
mst	redis-benchmark.c	/^    long long mst;$/;"	l	language:C
mstate	server.h	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	language:C	struct:client	access:public
mstime	cluster.c	/^        pauseClients(mstime()+(CLUSTER_MF_TIMEOUT*2));$/;"	p	language:C	file:
mstime	quicklist.c	/^static long long mstime(void) { return ustime() \/ 1000; }$/;"	f	language:C	file:	signature:(void)
mstime	redis-benchmark.c	/^static long long mstime(void) {$/;"	f	language:C	file:	signature:(void)
mstime	redis-cli.c	/^static long long mstime(void) {$/;"	f	language:C	file:	signature:(void)
mstime	server.c	/^mstime_t mstime(void) {$/;"	f	language:C	signature:(void)
mstime	server.h	/^    long long mstime;   \/* Like 'unixtime' but with milliseconds resolution. *\/$/;"	m	language:C	struct:redisServer	access:public
mstime	server.h	/^long long mstime(void);$/;"	p	language:C	signature:(void)
mstime_t	redismodule.h	/^typedef long long mstime_t;$/;"	t	language:C
mstime_t	server.h	/^typedef long long mstime_t; \/* millisecond time type. *\/$/;"	t	language:C
mt	aof.c	/^    moduleType *mt = mv->type;$/;"	l	language:C
mt	module.c	/^            moduleType *mt = ln->value;$/;"	l	language:C
mt	module.c	/^        moduleType *mt;$/;"	m	language:C	struct:__anon20	file:	access:public
mt	rdb.c	/^        moduleType *mt = moduleTypeLookupModuleByID(moduleid);$/;"	l	language:C
mt	rdb.c	/^        moduleType *mt = mv->type;$/;"	l	language:C
mul	util.c	/^    long mul; \/* unit multiplier *\/$/;"	l	language:C
multi	redis-check-aof.c	/^    int i, multi = 0;$/;"	l	language:C
multiCmd	server.h	/^typedef struct multiCmd {$/;"	s	language:C
multiCmd	server.h	/^} multiCmd;$/;"	t	language:C	typeref:struct:multiCmd
multiCmd::argc	server.h	/^    int argc;$/;"	m	language:C	struct:multiCmd	access:public
multiCmd::argv	server.h	/^    robj **argv;$/;"	m	language:C	struct:multiCmd	access:public
multiCmd::cmd	server.h	/^    struct redisCommand *cmd;$/;"	m	language:C	struct:multiCmd	typeref:struct:multiCmd::redisCommand	access:public
multiCommand	multi.c	/^void multiCommand(client *c) {$/;"	f	language:C	signature:(client *c)
multiCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
multiCommand	server.h	/^void multiCommand(client *c);$/;"	p	language:C	signature:(client *c)
multiState	server.h	/^typedef struct multiState {$/;"	s	language:C
multiState	server.h	/^} multiState;$/;"	t	language:C	typeref:struct:multiState
multiState::commands	server.h	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	language:C	struct:multiState	access:public
multiState::count	server.h	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	language:C	struct:multiState	access:public
multiState::minreplicas	server.h	/^    int minreplicas;        \/* MINREPLICAS for synchronous replication *\/$/;"	m	language:C	struct:multiState	access:public
multiState::minreplicas_timeout	server.h	/^    time_t minreplicas_timeout; \/* MINREPLICAS timeout as unixtime. *\/$/;"	m	language:C	struct:multiState	access:public
multibulklen	server.h	/^    int multibulklen;       \/* Number of multi bulk arguments left to read. *\/$/;"	m	language:C	struct:client	access:public
multiple_keys	cluster.c	/^    int multiple_keys = 0;$/;"	l	language:C
multiplier	t_hash.c	/^    int multiplier = 0;$/;"	l	language:C
multistring	multi.c	/^    robj *multistring = createStringObject("MULTI",5);$/;"	l	language:C
must_propagate	multi.c	/^    int must_propagate = 0; \/* Need to propagate MULTI\/EXEC to AOF \/ slaves? *\/$/;"	l	language:C
mv	aof.c	/^    moduleValue *mv = o->ptr;$/;"	l	language:C
mv	db.c	/^            moduleValue *mv = o->ptr;$/;"	l	language:C
mv	object.c	/^    moduleValue *mv = o->ptr;$/;"	l	language:C
mv	object.c	/^    moduleValue *mv = zmalloc(sizeof(*mv));$/;"	l	language:C
mv	rdb.c	/^        moduleValue *mv = o->ptr;$/;"	l	language:C
myarea	geohash_helper.c	/^        GeoHashArea myarea = {{0}};$/;"	l	language:C
mycommand	modules/INTRO.md	/^    int mycommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);$/;"	p	language:C	file:	signature:(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
myepoch	cluster.c	/^        uint64_t myepoch;$/;"	l	language:C
myid	sentinel.c	/^    char myid[CONFIG_RUN_ID_SIZE+1]; \/* This sentinel ID. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
myip	cluster.h	/^    char myip[NET_IP_STR_LEN];    \/* Sender IP, if not all zeroed. *\/$/;"	m	language:C	struct:__anon10	access:public
mymaster	cluster.c	/^    clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;$/;"	l	language:C
myoffset	cluster.c	/^    long long myoffset;$/;"	l	language:C
myself	cluster.c	/^clusterNode *myself = NULL;$/;"	v	language:C
myself	cluster.h	/^    clusterNode *myself;  \/* This node *\/$/;"	m	language:C	struct:clusterState	access:public
myslots	cluster.h	/^    unsigned char myslots[CLUSTER_SLOTS\/8];$/;"	m	language:C	struct:__anon10	access:public
mystr	modules/INTRO.md	/^    RedisModuleString *mystr = RedisModule_CreateStringFromCallReply(myreply);$/;"	v	language:C
mystr	modules/INTRO.md	/^    RedisModuleString *mystr = RedisModule_CreateStringFromLongLong(ctx,10);$/;"	v	language:C
mystr	modules/testmodule.c	/^    RedisModuleString *mystr = RedisModule_CreateString(ctx,"foo",3);$/;"	l	language:C
mystr	modules/testmodule.c	/^    RedisModuleString *mystr, *expected;$/;"	l	language:C
mystr	modules/testmodule.c	/^    RedisModuleString *mystr;$/;"	l	language:C
mystr_ptr	modules/testmodule.c	/^        const char *mystr_ptr = RedisModule_StringPtrLen(mystr,NULL);$/;"	l	language:C
myval	modules/INTRO.md	/^        long long myval = RedisModule_CallReplyInteger(reply);$/;"	v	language:C
myval	modules/INTRO.md	/^    long long myval;$/;"	v	language:C
myvote	sentinel.c	/^    char *myvote;$/;"	l	language:C
n	adlist.c	/^    listNode *n;$/;"	l	language:C
n	cluster.c	/^            clusterNode *n = clusterLookupNode(c->argv[4]->ptr);$/;"	l	language:C
n	cluster.c	/^            clusterNode *n = server.cluster->slots[j];$/;"	l	language:C
n	cluster.c	/^        clusterNode *n = clusterLookupNode(c->argv[2]->ptr);$/;"	l	language:C
n	cluster.c	/^        clusterNode *n, *master;$/;"	l	language:C
n	cluster.c	/^        clusterNode *n; \/* The node the update is about. *\/$/;"	l	language:C
n	cluster.c	/^        clusterNode *n;$/;"	l	language:C
n	cluster.c	/^    clusterNode *n = NULL;$/;"	l	language:C
n	cluster.c	/^    clusterNode *n = server.cluster->slots[slot];$/;"	l	language:C
n	cluster.c	/^    clusterNode *n;$/;"	l	language:C
n	db.c	/^    zskiplistNode *n;$/;"	l	language:C
n	dict.c	/^    dictht n; \/* the new hash table *\/$/;"	l	language:C
n	hyperloglog.c	/^    uint8_t seq[5], *n = seq;$/;"	l	language:C
n	networking.c	/^        long n = (long)obj->ptr;$/;"	l	language:C
n	quicklist.c	/^    quicklistNode *n;$/;"	l	language:C
n	rdb.c	/^    ssize_t n = 0, nwritten = 0;$/;"	l	language:C
n	rdb.c	/^    ssize_t n, nwritten = 0;$/;"	l	language:C
n	redis-benchmark.c	/^    int n = 0;$/;"	l	language:C
n	server.c	/^        clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,$/;"	l	language:C
n1	redis-cli.c	/^    char *n1, *n2;$/;"	l	language:C
n2	redis-cli.c	/^    char *n1, *n2;$/;"	l	language:C
name	cluster.c	/^    char *name;$/;"	m	language:C	struct:redisNodeFlags	file:	access:public
name	cluster.c	/^    sds name = sdsempty();$/;"	l	language:C
name	cluster.h	/^    char name[CLUSTER_NAMELEN]; \/* Node name, hex string, sha1-size *\/$/;"	m	language:C	struct:clusterNode	access:public
name	config.c	/^    const char *name = NULL, *option = "syslog-facility";$/;"	l	language:C
name	config.c	/^    const char *name = configEnumGetName(ce,val);$/;"	l	language:C
name	config.c	/^    const char *name = configEnumGetNameOrUnknown(ce,value);$/;"	l	language:C
name	config.c	/^    const char *name;$/;"	m	language:C	struct:configEnum	file:	access:public
name	db.c	/^        char *name;$/;"	m	language:C	struct:__anon11	file:	access:public
name	help.h	/^  char *name;$/;"	m	language:C	struct:commandHelp	access:public
name	module.c	/^            sds name = dictGetKey(de);$/;"	l	language:C
name	module.c	/^    char *name;     \/* Module name. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
name	modules/INTRO.md	/^name of the module followed by a dot, and finally the command name,$/;"	v	language:C
name	modules/INTRO.md	/^name, its version (that is reported by `MODULE LIST`), and that is willing$/;"	v	language:C
name	modules/TYPES.md	/^we can convert back the 64 bit value into a 9 characters name, and print$/;"	v	language:C
name	rdb.c	/^        char name[10];$/;"	l	language:C
name	scripting.c	/^        const char *name;$/;"	l	language:C
name	sentinel.c	/^    char *name;     \/* Master name from the point of view of this sentinel. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
name	sentinel.c	/^    char name[64];$/;"	l	language:C
name	server.c	/^        static struct utsname name;$/;"	l	language:C	file:
name	server.c	/^    sds name = sdsnew(s);$/;"	l	language:C
name	server.h	/^    char *name;$/;"	m	language:C	struct:redisCommand	access:public
name	server.h	/^    char *name;$/;"	m	language:C	struct:redisFunctionSym	access:public
name	server.h	/^    char name[10]; \/* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- *\/$/;"	m	language:C	struct:RedisModuleType	access:public
name	server.h	/^    robj *name;             \/* As set by CLIENT SETNAME. *\/$/;"	m	language:C	struct:client	access:public
name_len	module.c	/^    size_t name_len;$/;"	l	language:C
nanerr	t_zset.c	/^    static char *nanerr = "resulting score is not a number (NaN)";$/;"	l	language:C	file:
narenas	debug.c	/^            unsigned narenas = 0;$/;"	l	language:C
nearest	ae.c	/^    aeTimeEvent *nearest = NULL;$/;"	l	language:C
needed_quorum	cluster.c	/^        int needed_quorum = (server.cluster->size \/ 2) + 1;$/;"	l	language:C
needed_quorum	cluster.c	/^    int needed_quorum = (server.cluster->size \/ 2) + 1;$/;"	l	language:C
negative	util.c	/^    int negative = 0;$/;"	l	language:C
negative	util.c	/^    int negative;$/;"	l	language:C
neighbors	geo.c	/^    GeoHashBits neighbors[9];$/;"	l	language:C
neighbors	geohash_helper.c	/^    GeoHashNeighbors neighbors;$/;"	l	language:C
neighbors	geohash_helper.h	/^    GeoHashNeighbors neighbors;$/;"	m	language:C	struct:__anon18	access:public
nested_elements	cluster.c	/^                int nested_elements = 3; \/* slots (2) + master addr (1). *\/$/;"	l	language:C
nested_replylen	cluster.c	/^                void *nested_replylen = addDeferredMultiBulkLength(c);$/;"	l	language:C
neterr	server.h	/^    char neterr[ANET_ERR_LEN];   \/* Error buffer for anet.c *\/$/;"	m	language:C	struct:redisServer	access:public
nevents	ae_evport.c	/^    uint_t nevents;$/;"	l	language:C
new	redis-cli.c	/^        helpEntry *new = helpEntries+(helpEntriesLen-1);$/;"	l	language:C
new	t_hash.c	/^    sds new;$/;"	l	language:C
new	t_string.c	/^    robj *o, *new, *aux;$/;"	l	language:C
new	t_string.c	/^    robj *o, *new;$/;"	l	language:C
new_extent	quicklist.c	/^    int new_extent = after ? offset + 1 : -1;$/;"	l	language:C
new_node	quicklist.c	/^    quicklistNode *new_node = NULL;$/;"	l	language:C
new_node	quicklist.c	/^    quicklistNode *new_node = quicklistCreateNode();$/;"	l	language:C
new_start	quicklist.c	/^    int new_start = after ? 0 : offset;$/;"	l	language:C
new_state	cluster.c	/^    int j, new_state;$/;"	l	language:C
new_sz	quicklist.c	/^    unsigned int new_sz = node->sz + sz + ziplist_overhead;$/;"	l	language:C
newaddr	sentinel.c	/^    sentinelAddr *oldaddr, *newaddr;$/;"	l	language:C
newargv	cluster.c	/^    robj **newargv = NULL; \/* Used to rewrite the command as DEL ... keys ... *\/$/;"	l	language:C
newcontent	config.c	/^    sds newcontent;$/;"	l	language:C
newele	modules/helloworld.c	/^        RedisModuleString *newele = RedisModule_CreateStringFromLongLong(ctx,val);$/;"	l	language:C
newenc	intset.c	/^    uint8_t newenc = _intsetValueEncoding(value);$/;"	l	language:C
newfd	aof.c	/^        int newfd, oldfd;$/;"	l	language:C
newhint	redis-cli.c	/^                sds newhint = sdsnewlen(" ",1);$/;"	l	language:C
newlen	modules/helloworld.c	/^    size_t newlen = RedisModule_ValueLength(key);$/;"	l	language:C
newlen	sds.c	/^    size_t len, newlen;$/;"	l	language:C
newlen	sds.c	/^    size_t newlen, len = sdslen(s);$/;"	l	language:C
newlen	sds.h	/^                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;$/;"	l	language:C
newline	networking.c	/^    char *newline = NULL;$/;"	l	language:C
newline	networking.c	/^    char *newline;$/;"	l	language:C
newline_sent	replication.c	/^    static time_t newline_sent;$/;"	l	language:C	file:
newmaster	cluster.c	/^    clusterNode *curmaster, *newmaster = NULL;$/;"	l	language:C
newnode	modules/hellotype.c	/^    struct HelloTypeNode *next = o->head, *newnode, *prev = NULL;$/;"	l	language:C
newobj	t_hash.c	/^    robj *aux, *newobj;$/;"	l	language:C
newptr	zmalloc.c	/^    void *newptr;$/;"	l	language:C
newrank	cluster.c	/^        int newrank = clusterGetSlaveRank();$/;"	l	language:C
newscore	t_zset.c	/^        double newscore;$/;"	l	language:C
newset	t_set.c	/^        robj *newset = NULL;$/;"	l	language:C
newsh	sds.c	/^    void *sh, *newsh;$/;"	l	language:C
newtokens	sds.c	/^            sds *newtokens;$/;"	l	language:C
newval	bitops.c	/^                int64_t oldval, newval, wrapped, retval;$/;"	l	language:C
newval	bitops.c	/^                uint64_t oldval, newval, wrapped, retval;$/;"	l	language:C
newval	scripting.c	/^        int newval = atoi(argv[1]);$/;"	l	language:C
next	adlist.c	/^    listNode *current, *next;$/;"	l	language:C
next	adlist.h	/^    listNode *next;$/;"	m	language:C	struct:listIter	access:public
next	adlist.h	/^    struct listNode *next;$/;"	m	language:C	struct:listNode	typeref:struct:listNode::listNode	access:public
next	ae.c	/^            aeTimeEvent *next = te->next;$/;"	l	language:C
next	ae.h	/^    struct aeTimeEvent *next;$/;"	m	language:C	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent	access:public
next	dict.c	/^    const dictEntry *de, *next;$/;"	l	language:C
next	dict.h	/^    struct dictEntry *next;$/;"	m	language:C	struct:dictEntry	typeref:struct:dictEntry::dictEntry	access:public
next	hyperloglog.c	/^    uint8_t oldcount, count, *sparse, *end, *p, *prev, *next;$/;"	l	language:C
next	module.c	/^        unsigned char *next;$/;"	l	language:C
next	module.c	/^        zskiplistNode *ln = key->zcurrent, *next = ln->level[0].forward;$/;"	l	language:C
next	module.c	/^    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;$/;"	l	language:C
next	module.c	/^    struct RedisModulePoolAllocBlock *next;$/;"	m	language:C	struct:RedisModulePoolAllocBlock	typeref:struct:RedisModulePoolAllocBlock::RedisModulePoolAllocBlock	file:	access:public
next	modules/hellotype.c	/^    struct HelloTypeNode *cur, *next;$/;"	l	language:C
next	modules/hellotype.c	/^    struct HelloTypeNode *next = o->head, *newnode, *prev = NULL;$/;"	l	language:C
next	modules/hellotype.c	/^    struct HelloTypeNode *next;$/;"	m	language:C	struct:HelloTypeNode	typeref:struct:HelloTypeNode::HelloTypeNode	file:	access:public
next	networking.c	/^    sds len, next;$/;"	l	language:C
next	quicklist.c	/^        quicklistNode *next = node->next;$/;"	l	language:C
next	quicklist.c	/^        unsigned char *next = ziplistNext(node->zl, entry->zi);$/;"	l	language:C
next	quicklist.c	/^    quicklistNode *current, *next;$/;"	l	language:C
next	quicklist.c	/^    quicklistNode *next = entry->node->next;$/;"	l	language:C
next	quicklist.c	/^    quicklistNode *prev, *prev_prev, *next, *next_next, *target;$/;"	l	language:C
next	quicklist.h	/^    struct quicklistNode *next;$/;"	m	language:C	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode	access:public
next	rand.c	/^static void next(void) {$/;"	f	language:C	file:	signature:(void)
next	rand.c	/^static void next(void);$/;"	p	language:C	file:	signature:(void)
next	redis-benchmark.c	/^    listNode *ln = config.clients->head, *next;$/;"	l	language:C
next	sds.c	/^        char next, *str;$/;"	l	language:C
next	t_string.c	/^        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];$/;"	l	language:C
next	t_zset.c	/^        zskiplistNode *next = x->level[0].forward;$/;"	l	language:C
next	t_zset.c	/^    zskiplistNode *node = zsl->header->level[0].forward, *next;$/;"	l	language:C
next	t_zset.c	/^    zskiplistNode *node, *next;$/;"	l	language:C
next	tags	/^current	adlist.c	\/^    listNode *current, *next;$\/;"	l	language:C$/;"	v	language:C
next	ziplist.c	/^    zlentry cur, next;$/;"	l	language:C
nextEntry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	language:C	struct:dictIterator	access:public
nextHe	dict.c	/^        dictEntry *he, *nextHe;$/;"	l	language:C
next_client_id	server.h	/^    uint64_t next_client_id;    \/* Next client unique ID. Incremental. *\/$/;"	m	language:C	struct:redisServer	access:public
next_db	evict.c	/^        static int next_db = 0;$/;"	l	language:C	file:
next_next	quicklist.c	/^    quicklistNode *prev, *prev_prev, *next, *next_next, *target;$/;"	l	language:C
nextde	dict.c	/^        dictEntry *de, *nextde;$/;"	l	language:C
nextdiff	ziplist.c	/^    int nextdiff = 0;$/;"	l	language:C
nextnode	db.c	/^    listNode *node, *nextnode;$/;"	l	language:C
nextra	debug.c	/^            char *nextra = extra;$/;"	l	language:C
ni	cluster.c	/^            sds ni = clusterGenNodeDescription(n->slaves[j]);$/;"	l	language:C
ni	cluster.c	/^    sds ci = sdsempty(), ni;$/;"	l	language:C
noautherr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
nodata	aof.c	/^    int nodata = 0;$/;"	l	language:C
node	adlist.c	/^    listNode *node;$/;"	l	language:C
node	cluster.c	/^            clusterNode *node = dictGetVal(de);$/;"	l	language:C
node	cluster.c	/^            clusterNode *node = server.cluster->slots[slot];$/;"	l	language:C
node	cluster.c	/^            clusterNode *node;$/;"	l	language:C
node	cluster.c	/^        clusterNode *node = dictGetVal(de);$/;"	l	language:C
node	cluster.c	/^        clusterNode *node;$/;"	l	language:C
node	cluster.c	/^    clusterNode *node = zmalloc(sizeof(*node));$/;"	l	language:C
node	cluster.h	/^    struct clusterNode *node;   \/* Node related to this link if any, or NULL *\/$/;"	m	language:C	struct:clusterLink	typeref:struct:clusterLink::clusterNode	access:public
node	cluster.h	/^    struct clusterNode *node;  \/* Node reporting the failure condition. *\/$/;"	m	language:C	struct:clusterNodeFailReport	typeref:struct:clusterNodeFailReport::clusterNode	access:public
node	db.c	/^    listNode *node, *nextnode;$/;"	l	language:C
node	modules/hellotype.c	/^    struct HelloTypeNode *node = hto ? hto->head : NULL;$/;"	l	language:C
node	modules/hellotype.c	/^    struct HelloTypeNode *node = hto->head;$/;"	l	language:C
node	networking.c	/^            sds node = sdsnewlen(s,len);$/;"	l	language:C
node	networking.c	/^        sds node = sdsnewlen(s,len);$/;"	l	language:C
node	quicklist.c	/^                    quicklistNode *node = ql->head;$/;"	l	language:C
node	quicklist.c	/^        quicklistNode *node = ql->head;$/;"	l	language:C
node	quicklist.c	/^        quicklistNode *node = quicklistCreateNode();$/;"	l	language:C
node	quicklist.c	/^    quicklistNode *node = entry->node;$/;"	l	language:C
node	quicklist.c	/^    quicklistNode *node = entry.node;$/;"	l	language:C
node	quicklist.c	/^    quicklistNode *node = quicklistCreateNode();$/;"	l	language:C
node	quicklist.c	/^    quicklistNode *node;$/;"	l	language:C
node	quicklist.h	/^    quicklistNode *node;$/;"	m	language:C	struct:quicklistEntry	access:public
node	rdb.c	/^            quicklistNode *node = ql->head;$/;"	l	language:C
node	t_zset.c	/^                zskiplistNode *node;$/;"	l	language:C
node	t_zset.c	/^                zskiplistNode *node;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon45	file:	access:public
node	t_zset.c	/^    zskiplistNode *node = zsl->header->level[0].forward, *next;$/;"	l	language:C
node	t_zset.c	/^    zskiplistNode *node, *next;$/;"	l	language:C
nodeFailed	cluster.c	/^    serverAssert(nodeFailed(node));$/;"	p	language:C	file:
nodeFailed	cluster.h	/^#define nodeFailed(/;"	d	language:C
nodeHasAddr	cluster.h	/^#define nodeHasAddr(/;"	d	language:C
nodeInHandshake	cluster.h	/^#define nodeInHandshake(/;"	d	language:C
nodeIp2String	cluster.c	/^void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {$/;"	f	language:C	signature:(char *buf, clusterLink *link, char *announced_ip)
nodeIsMaster	cluster.h	/^#define nodeIsMaster(/;"	d	language:C
nodeIsSlave	cluster.c	/^    serverAssert(nodeIsSlave(myself));$/;"	p	language:C	file:
nodeIsSlave	cluster.h	/^#define nodeIsSlave(/;"	d	language:C
nodeTimedOut	cluster.h	/^#define nodeTimedOut(/;"	d	language:C
nodeUpdateAddressIfNeeded	cluster.c	/^int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,$/;"	f	language:C	signature:(clusterNode *node, clusterLink *link, clusterMsg *hdr)
nodeWithoutAddr	cluster.h	/^#define nodeWithoutAddr(/;"	d	language:C
nodecfg	cluster.h	/^        clusterMsgDataUpdate nodecfg;$/;"	m	language:C	struct:clusterMsgData::__anon9	access:public
nodeflag	cluster.c	/^            struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;$/;"	l	language:C
nodename	cluster.c	/^    sds nodename;$/;"	l	language:C
nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN]; \/* Name of the slots owner. *\/$/;"	m	language:C	struct:__anon5	access:public
nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN];$/;"	m	language:C	struct:__anon2	access:public
nodename	cluster.h	/^    char nodename[CLUSTER_NAMELEN];$/;"	m	language:C	struct:__anon3	access:public
nodes	cluster.h	/^    dict *nodes;          \/* Hash table of name -> clusterNode structures *\/$/;"	m	language:C	struct:clusterState	access:public
nodes_black_list	cluster.h	/^    dict *nodes_black_list; \/* Nodes we don't re-add for a few seconds. *\/$/;"	m	language:C	struct:clusterState	access:public
nodes_with_keys_in_slot	redis-trib.rb	/^    def nodes_with_keys_in_slot(slot)$/;"	p	language:C	file:
noffset	ziplist.c	/^    size_t offset, noffset, extra;$/;"	l	language:C
nokeep	quicklist.c	/^        quicklistNode *keep = NULL, *nokeep = NULL;$/;"	l	language:C
nokeyerr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
nolog_fail_time	cluster.c	/^    mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;$/;"	l	language:C
noninteractive	redis-cli.c	/^static int noninteractive(int argc, char **argv) {$/;"	f	language:C	file:	signature:(int argc, char **argv)
noreplicaserr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
norm_ip	cluster.c	/^    char norm_ip[NET_IP_STR_LEN];$/;"	l	language:C
north	geohash.h	/^    GeoHashBits north;$/;"	m	language:C	struct:__anon17	access:public
north	geohash_helper.c	/^        GeoHashArea north, south, east, west;$/;"	l	language:C
north_east	geohash.h	/^    GeoHashBits north_east;$/;"	m	language:C	struct:__anon17	access:public
north_west	geohash.h	/^    GeoHashBits north_west;$/;"	m	language:C	struct:__anon17	access:public
nosave	server.c	/^    int nosave = flags & SHUTDOWN_NOSAVE;$/;"	l	language:C
noscripterr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
not	util.c	/^            int not, match;$/;"	l	language:C
not_reconfigured	sentinel.c	/^    int not_reconfigured = 0, timeout = 0;$/;"	l	language:C
notification_script	sentinel.c	/^    char *notification_script;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
notifyKeyspaceEvent	notify.c	/^void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {$/;"	f	language:C	signature:(int type, char *event, robj *key, int dbid)
notifyKeyspaceEvent	server.h	/^void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);$/;"	p	language:C	signature:(int type, char *event, robj *key, int dbid)
notify_keyspace_events	server.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	language:C	struct:redisServer	access:public
notify_socket	server.c	/^        const char *notify_socket = getenv("NOTIFY_SOCKET");$/;"	l	language:C
notify_socket	server.c	/^    const char *notify_socket = getenv("NOTIFY_SOCKET");$/;"	l	language:C
notused	hyperloglog.c	/^    uint8_t notused[3]; \/* Reserved for future use, must be zero. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
notused1	cluster.h	/^    char notused1[34];  \/* 34 bytes reserved for future usage. *\/$/;"	m	language:C	struct:__anon10	access:public
notused1	cluster.h	/^    uint32_t notused1;$/;"	m	language:C	struct:__anon2	access:public
now	ae.c	/^    time_t now = time(NULL);$/;"	l	language:C
now	aof.c	/^        long long now = ustime();$/;"	l	language:C
now	aof.c	/^    long long now = mstime();$/;"	l	language:C
now	cluster.c	/^    mstime_t min_pong = 0, now = mstime();$/;"	l	language:C
now	cluster.c	/^    mstime_t now = mstime();$/;"	l	language:C
now	db.c	/^    mstime_t now;$/;"	l	language:C
now	evict.c	/^    unsigned long now = LFUGetTimeInMinutes();$/;"	l	language:C
now	expire.c	/^            long long now, ttl_sum;$/;"	l	language:C
now	latency.c	/^    time_t now = time(NULL);$/;"	l	language:C
now	networking.c	/^    time_t now = time(NULL);$/;"	l	language:C
now	rdb.c	/^    long long expiretime, now = mstime();$/;"	l	language:C
now	rdb.c	/^    long long now = mstime();$/;"	l	language:C
now	redis-benchmark.c	/^                    time_t now = time(NULL);$/;"	l	language:C
now	redis-check-rdb.c	/^    long long expiretime, now = mstime();$/;"	l	language:C
now	sentinel.c	/^    mstime_t now = mstime();$/;"	l	language:C
now	server.c	/^    mstime_t now = mstime();$/;"	l	language:C
now	server.c	/^    time_t now = now_ms\/1000;$/;"	l	language:C
now_ms	ae.c	/^            long now_sec, now_ms;$/;"	l	language:C
now_ms	ae.c	/^        long now_sec, now_ms;$/;"	l	language:C
now_sec	ae.c	/^            long now_sec, now_ms;$/;"	l	language:C
now_sec	ae.c	/^        long now_sec, now_ms;$/;"	l	language:C
np	ziplist.c	/^    unsigned char *np;$/;"	l	language:C
npending	ae_evport.c	/^    int     npending;                           \/* # of pending fds *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
nread	anet.c	/^    ssize_t nread, totlen = 0;$/;"	l	language:C
nread	aof.c	/^    ssize_t nread, total = 0;$/;"	l	language:C
nread	cluster.c	/^    ssize_t nread;$/;"	l	language:C
nread	networking.c	/^    int nread, readlen;$/;"	l	language:C
nread	redis-cli.c	/^                    ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));$/;"	l	language:C
nread	redis-cli.c	/^            ssize_t nread;$/;"	l	language:C
nread	redis-cli.c	/^        int nread = read(fileno(stdin),buf,1024);$/;"	l	language:C
nread	redis-cli.c	/^        ssize_t nread, nwritten;$/;"	l	language:C
nread	redis-cli.c	/^        ssize_t nread;$/;"	l	language:C
nread	redis-cli.c	/^    size_t nread;$/;"	l	language:C
nread	redis-cli.c	/^    ssize_t nread;$/;"	l	language:C
nread	replication.c	/^    ssize_t nread, readlen;$/;"	l	language:C
nread	scripting.c	/^            int nread = read(ldb.fd,buf,sizeof(buf));$/;"	l	language:C
nread	syncio.c	/^    ssize_t nread = 0;$/;"	l	language:C
nread	syncio.c	/^    ssize_t nread, totread = 0;$/;"	l	language:C
ntohu64	endianconv.h	/^#define ntohu64(/;"	d	language:C
nul	setproctitle.c	/^	char *base, *end, *nul, *tmp;$/;"	l	language:C
nul	setproctitle.c	/^	char *nul;$/;"	l	language:C
nul	setproctitle.c	/^	char *nul;$/;"	m	language:C	struct:__anon37	file:	access:public
nullbulk	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
nullmultibulk	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
num	db.c	/^    int i, j, num, *keys, found_store = 0;$/;"	l	language:C
num	db.c	/^    int i, num, *keys;$/;"	l	language:C
num	db.c	/^    int i, num, first, *keys;$/;"	l	language:C
num	expire.c	/^            unsigned long num, slots;$/;"	l	language:C
num	intset.c	/^        long num = 100000, size = 10000;$/;"	l	language:C
num	quicklist.c	/^                char num[32];$/;"	l	language:C
num	quicklist.c	/^                char num[64];$/;"	l	language:C
num	quicklist.c	/^            char num[32];$/;"	l	language:C
num	scripting.c	/^                int num = atoi(argv[1]);$/;"	l	language:C
num	scripting.c	/^            lua_Number num = lua_tonumber(lua,j+1);$/;"	l	language:C
num	sds.c	/^        long long num;$/;"	l	language:C
num	t_zset.c	/^    unsigned int num = (end-start)+1;$/;"	l	language:C
num	t_zset.c	/^    unsigned long num = 0;$/;"	l	language:C
num_keys	cluster.c	/^    int num_keys = 1;  \/* By default only migrate the 'key' argument. *\/$/;"	l	language:C
num_masters	cluster.c	/^    int num_masters = 0;$/;"	l	language:C
numblocks	aof.c	/^            int numblocks;$/;"	l	language:C
numclients	redis-benchmark.c	/^    int numclients;$/;"	m	language:C	struct:config	file:	access:public
numclients	server.c	/^    int numclients = listLength(server.clients);$/;"	l	language:C
numclients	t_list.c	/^                    int numclients = listLength(clients);$/;"	l	language:C
numcommands	server.c	/^    int j, numcommands;$/;"	l	language:C
numcommands	server.c	/^    int numcommands = sizeof(redisCommandTable)\/sizeof(struct redisCommand);$/;"	l	language:C
numdel	db.c	/^    int numdel = 0, j;$/;"	l	language:C
numevents	ae.c	/^    int processed = 0, numevents;$/;"	l	language:C
numevents	ae_epoll.c	/^    int retval, numevents = 0;$/;"	l	language:C
numevents	ae_kqueue.c	/^    int retval, numevents = 0;$/;"	l	language:C
numevents	ae_select.c	/^    int retval, j, numevents = 0;$/;"	l	language:C
numfds	rdb.c	/^    int numfds;$/;"	l	language:C
numfds	rio.h	/^            int numfds;$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
numkeys	bitops.c	/^    unsigned long op, j, numkeys;$/;"	l	language:C
numkeys	cluster.c	/^        int margc, *keyindex, numkeys, j;$/;"	l	language:C
numkeys	cluster.c	/^        unsigned int numkeys, j;$/;"	l	language:C
numkeys	db.c	/^    unsigned long numkeys = 0;$/;"	l	language:C
numkeys	lazyfree.c	/^    size_t numkeys = dictSize(ht1);$/;"	l	language:C
numkeys	scripting.c	/^    long long numkeys;$/;"	l	language:C
numkeys	server.c	/^        int *keys, numkeys, j;$/;"	l	language:C
numlines	config.c	/^    int numlines;         \/* Number of lines in current config *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
numlines	sentinel.c	/^    int numlines, j;$/;"	l	language:C
numops	bitops.c	/^    int j, numops = 0, changes = 0;$/;"	l	language:C
numops	server.h	/^    int numops;$/;"	m	language:C	struct:redisOpArray	access:public
numreplicas	replication.c	/^            int numreplicas = replicationCountAcksByOffset(c->bpop.reploffset);$/;"	l	language:C
numreplicas	replication.c	/^    long numreplicas, ackreplicas;$/;"	l	language:C
numreplicas	server.h	/^    int numreplicas;        \/* Number of replicas we are waiting for ACK. *\/$/;"	m	language:C	struct:blockingState	access:public
nums	quicklist.c	/^                long long nums[5000];$/;"	l	language:C
nums	quicklist.c	/^                long long nums[64];$/;"	l	language:C
nums	quicklist.c	/^            long long nums[5000];$/;"	l	language:C
numslaves	cluster.h	/^    int numslaves;  \/* Number of slave nodes, if this is a master *\/$/;"	m	language:C	struct:clusterNode	access:public
numslaves	sentinel.c	/^    int numslaves = 0, j;$/;"	l	language:C
numslots	cluster.h	/^    int numslots;   \/* Number of slots handled by this node *\/$/;"	m	language:C	struct:clusterNode	access:public
numtokens	sentinel.c	/^    int numtokens, port, removed, master_port;$/;"	l	language:C
nwritten	anet.c	/^    ssize_t nwritten, totlen = 0;$/;"	l	language:C
nwritten	aof.c	/^        ssize_t nwritten;$/;"	l	language:C
nwritten	aof.c	/^    ssize_t nwritten;$/;"	l	language:C
nwritten	cluster.c	/^        int nwritten = 0;$/;"	l	language:C
nwritten	cluster.c	/^    ssize_t nwritten;$/;"	l	language:C
nwritten	networking.c	/^    ssize_t nwritten = 0, totwritten = 0;$/;"	l	language:C
nwritten	rdb.c	/^    size_t nwritten;$/;"	l	language:C
nwritten	rdb.c	/^    ssize_t n = 0, nwritten = 0;$/;"	l	language:C
nwritten	rdb.c	/^    ssize_t n, nwritten = 0;$/;"	l	language:C
nwritten	rdb.c	/^    ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);$/;"	l	language:C
nwritten	redis-benchmark.c	/^        ssize_t nwritten = write(c->context->fd,ptr,sdslen(c->obuf)-c->written);$/;"	l	language:C
nwritten	redis-cli.c	/^                    ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);$/;"	l	language:C
nwritten	redis-cli.c	/^        ssize_t nread, nwritten;$/;"	l	language:C
nwritten	replication.c	/^    ssize_t nwritten, buflen;$/;"	l	language:C
nwritten	rio.c	/^            size_t nwritten = 0;$/;"	l	language:C
nwritten	rio.c	/^    size_t nwritten;$/;"	l	language:C
nwritten	syncio.c	/^    ssize_t nwritten, ret = size;$/;"	l	language:C
nx	t_zset.c	/^    int nx = (*flags & ZADD_NX) != 0;$/;"	l	language:C
nx	t_zset.c	/^    int nx = (flags & ZADD_NX) != 0;$/;"	l	language:C
o	aof.c	/^            robj key, *o;$/;"	l	language:C
o	aof.c	/^    robj *o;$/;"	l	language:C
o	bitops.c	/^    robj *o = lookupKeyWrite(c->db,c->argv[1]);$/;"	l	language:C
o	bitops.c	/^    robj *o, *targetkey = c->argv[2];$/;"	l	language:C
o	bitops.c	/^    robj *o;$/;"	l	language:C
o	cluster.c	/^        robj *o;$/;"	l	language:C
o	cluster.c	/^    robj *o, *dumpobj;$/;"	l	language:C
o	config.c	/^    robj *o = c->argv[2];$/;"	l	language:C
o	config.c	/^    robj *o;$/;"	l	language:C
o	config.c	/^    sds o = sdsnew(option);$/;"	l	language:C
o	db.c	/^    robj *o = lookupKeyRead(c->db, key);$/;"	l	language:C
o	db.c	/^    robj *o = lookupKeyWrite(c->db, key);$/;"	l	language:C
o	db.c	/^    robj *o = pd[1];$/;"	l	language:C
o	db.c	/^    robj *o;$/;"	l	language:C
o	debug.c	/^            robj *keyobj, *o;$/;"	l	language:C
o	evict.c	/^        robj *o;$/;"	l	language:C
o	hyperloglog.c	/^            robj *o = lookupKeyRead(c->db,c->argv[j]);$/;"	l	language:C
o	hyperloglog.c	/^        robj *o = lookupKeyRead(c->db,c->argv[j]);$/;"	l	language:C
o	hyperloglog.c	/^    robj *o = NULL;$/;"	l	language:C
o	hyperloglog.c	/^    robj *o = lookupKeyWrite(c->db,c->argv[1]);$/;"	l	language:C
o	hyperloglog.c	/^    robj *o;$/;"	l	language:C
o	module.c	/^        robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));$/;"	l	language:C
o	module.c	/^        sds o = listNodeValue(listFirst(c->reply));$/;"	l	language:C
o	module.c	/^    RedisModuleString *o = createStringObject(ptr,len);$/;"	l	language:C
o	module.c	/^    RedisModuleString *o = dupStringObject(str);$/;"	l	language:C
o	module.c	/^    robj *o = createModuleObject(mt,value);$/;"	l	language:C
o	module.c	/^    robj *o = key->value;$/;"	l	language:C
o	modules/hellotype.c	/^    struct HelloTypeObject *o;$/;"	l	language:C
o	networking.c	/^        sds o = getAllClientsInfoString();$/;"	l	language:C
o	networking.c	/^    robj *o = createStringObjectFromLongDouble(d,1);$/;"	l	language:C
o	networking.c	/^    sds o = sdsnewlen(NULL,200*listLength(server.clients));$/;"	l	language:C
o	networking.c	/^    sds o;$/;"	l	language:C
o	object.c	/^    robj *o = createObject(OBJ_HASH, zl);$/;"	l	language:C
o	object.c	/^    robj *o = createObject(OBJ_LIST,l);$/;"	l	language:C
o	object.c	/^    robj *o = createObject(OBJ_LIST,zl);$/;"	l	language:C
o	object.c	/^    robj *o = createObject(OBJ_SET,d);$/;"	l	language:C
o	object.c	/^    robj *o = createObject(OBJ_SET,is);$/;"	l	language:C
o	object.c	/^    robj *o = createObject(OBJ_ZSET,zl);$/;"	l	language:C
o	object.c	/^    robj *o = objectCommandLookup(c,key);$/;"	l	language:C
o	object.c	/^    robj *o = zmalloc(sizeof(*o));$/;"	l	language:C
o	object.c	/^    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);$/;"	l	language:C
o	object.c	/^    robj *o;$/;"	l	language:C
o	rdb.c	/^            robj key, *o = dictGetVal(de);$/;"	l	language:C
o	rdb.c	/^        robj *o = encode ? createStringObject(NULL,len) :$/;"	l	language:C
o	rdb.c	/^    robj *o = NULL, *ele, *dec;$/;"	l	language:C
o	scripting.c	/^            sds o = listNodeValue(listFirst(c->reply));$/;"	l	language:C
o	scripting.c	/^        robj *o = c->argv[j];$/;"	l	language:C
o	sentinel.c	/^        robj *o = c->argv[j+1];$/;"	l	language:C
o	server.c	/^    const robj *o = key;$/;"	l	language:C
o	server.c	/^    robj *o = (robj*) key;$/;"	l	language:C
o	sort.c	/^    robj *keyobj, *fieldobj = NULL, *o;$/;"	l	language:C
o	t_hash.c	/^    robj *o = lookupKeyWrite(c->db,key);$/;"	l	language:C
o	t_hash.c	/^    robj *o;$/;"	l	language:C
o	t_list.c	/^            robj *o = lookupKeyWrite(rl->db,rl->key);$/;"	l	language:C
o	t_list.c	/^    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);$/;"	l	language:C
o	t_list.c	/^    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk);$/;"	l	language:C
o	t_list.c	/^    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);$/;"	l	language:C
o	t_list.c	/^    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk);$/;"	l	language:C
o	t_list.c	/^    robj *o;$/;"	l	language:C
o	t_set.c	/^    robj *o;$/;"	l	language:C
o	t_string.c	/^        robj *o = lookupKeyRead(c->db,c->argv[j]);$/;"	l	language:C
o	t_string.c	/^    robj *o, *append;$/;"	l	language:C
o	t_string.c	/^    robj *o, *new, *aux;$/;"	l	language:C
o	t_string.c	/^    robj *o, *new;$/;"	l	language:C
o	t_string.c	/^    robj *o;$/;"	l	language:C
o	t_zset.c	/^    robj *o;$/;"	l	language:C
o1	server.c	/^    const robj *o1 = key1, *o2 = key2;$/;"	l	language:C
o1	server.c	/^    robj *o1 = (robj*) key1, *o2 = (robj*) key2;$/;"	l	language:C
o1	t_set.c	/^    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;$/;"	l	language:C
o2	server.c	/^    const robj *o1 = key1, *o2 = key2;$/;"	l	language:C
o2	server.c	/^    robj *o1 = (robj*) key1, *o2 = (robj*) key2;$/;"	l	language:C
o2	t_set.c	/^    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;$/;"	l	language:C
o_down_since_time	sentinel.c	/^    mstime_t o_down_since_time; \/* Objectively down since time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
obj	cluster.c	/^    robj *obj;$/;"	l	language:C
obj	module.c	/^            robj *obj = va_arg(ap,void*);$/;"	l	language:C
obj	module.c	/^    robj *obj;$/;"	l	language:C
obj	server.h	/^    robj *obj;$/;"	m	language:C	struct:_redisSortObject	access:public
obj	t_list.c	/^    robj *subject, *obj;$/;"	l	language:C
obj	t_zset.c	/^        robj *obj = lookupKeyWrite(c->db,c->argv[j]);$/;"	l	language:C
obj_len	scripting.c	/^        size_t obj_len;$/;"	l	language:C
obj_s	scripting.c	/^        char *obj_s;$/;"	l	language:C
objectCommand	object.c	/^void objectCommand(client *c) {$/;"	f	language:C	signature:(client *c)
objectCommand	server.h	/^void objectCommand(client *c);$/;"	p	language:C	signature:(client *c)
objectCommandLookup	object.c	/^robj *objectCommandLookup(client *c, robj *key) {$/;"	f	language:C	signature:(client *c, robj *key)
objectCommandLookupOrReply	object.c	/^robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {$/;"	f	language:C	signature:(client *c, robj *key, robj *reply)
objectKeyPointerValueDictType	server.c	/^dictType objectKeyPointerValueDictType = {$/;"	v	language:C
objectKeyPointerValueDictType	server.h	/^extern dictType objectKeyPointerValueDictType;$/;"	x	language:C
objects	bitops.c	/^    robj **objects;      \/* Array of source objects. *\/$/;"	l	language:C
objects	modules/API.md	/^If the data structure does not store strings as RedisModuleString objects,$/;"	v	language:C
objele	t_set.c	/^        robj *objele;$/;"	l	language:C
objele	t_set.c	/^    robj *objele;$/;"	l	language:C
objlen	networking.c	/^    size_t objlen;$/;"	l	language:C
objlen	replication.c	/^            long objlen = stringObjectLen(argv[j]);$/;"	l	language:C
obuf	redis-benchmark.c	/^    sds obuf;$/;"	m	language:C	struct:_client	file:	access:public
obuf	redis-cli.c	/^    char ibuf[1024*16], obuf[1024*16]; \/* Input and output buffers *\/$/;"	l	language:C
obuf_bytes	evict.c	/^            unsigned long obuf_bytes = getClientOutputBufferMemoryUsage(slave);$/;"	l	language:C
obuf_len	redis-cli.c	/^    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;$/;"	l	language:C
obuf_pos	redis-cli.c	/^    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;$/;"	l	language:C
obuf_soft_limit_reached_time	server.h	/^    time_t obuf_soft_limit_reached_time;$/;"	m	language:C	struct:client	access:public
odown	sentinel.c	/^    unsigned int quorum = 0, odown = 0;$/;"	l	language:C
off	lzf_c.c	/^  unsigned _int64 off; \/* workaround for missing POSIX compliance *\/$/;"	l	language:C
off	lzf_c.c	/^  unsigned long off;$/;"	l	language:C
off	memtest.c	/^    unsigned long off, w, *l1, *l2, v;$/;"	l	language:C
off	memtest.c	/^    unsigned long off, w, *l1, *l2;$/;"	l	language:C
off	server.c	/^        int off;$/;"	l	language:C
offset	bitops.c	/^    uint64_t offset;    \/* Bitfield offset. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
offset	cluster.c	/^    uint64_t offset;$/;"	l	language:C
offset	cluster.h	/^    uint64_t offset;    \/* Master replication offset if node is a master or$/;"	m	language:C	struct:__anon10	access:public
offset	quicklist.h	/^    int offset;$/;"	m	language:C	struct:quicklistEntry	access:public
offset	quicklist.h	/^    long offset; \/* offset in current ziplist *\/$/;"	m	language:C	struct:quicklistIter	access:public
offset	replication.c	/^            long long offset;$/;"	l	language:C
offset	replication.c	/^        char *runid = NULL, *offset = NULL;$/;"	l	language:C
offset	replication.c	/^    long long offset = 0;$/;"	l	language:C
offset	replication.c	/^    long long offset = c->woff;$/;"	l	language:C
offset	t_string.c	/^    long offset;$/;"	l	language:C
offset	t_zset.c	/^    long offset = 0, limit = -1;$/;"	l	language:C
offset	t_zset.c	/^    size_t offset;$/;"	l	language:C
offset	ziplist.c	/^    size_t offset = *p-zl;$/;"	l	language:C
offset	ziplist.c	/^    size_t offset, noffset, extra;$/;"	l	language:C
offset	ziplist.c	/^    size_t offset;$/;"	l	language:C
offset	zipmap.c	/^    unsigned int zmlen, offset;$/;"	l	language:C
offset_update	quicklist.c	/^    int offset_update = 0;$/;"	l	language:C
oi	cluster.c	/^    int oi = 0;$/;"	l	language:C
ok	intset.c	/^static void ok(void) {$/;"	f	language:C	file:	signature:(void)
ok	networking.c	/^    int pos = 0, ok;$/;"	l	language:C
ok	quicklist.c	/^                int ok = 1;$/;"	l	language:C
ok	scripting.c	/^            sds ok = sdsnew(lua_tostring(lua,-1));$/;"	l	language:C
ok	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
ok_slaves	rdb.c	/^    uint64_t *ok_slaves;$/;"	l	language:C
okslaves	cluster.c	/^            int okslaves = clusterCountNonFailingSlaves(node);$/;"	l	language:C
okslaves	cluster.c	/^        int okslaves = 0, is_orphaned = 1;$/;"	l	language:C
okslaves	cluster.c	/^    int j, okslaves = 0;$/;"	l	language:C
old	cluster.c	/^    int old = bitmapTestBit(n->slots,slot);$/;"	l	language:C
old	db.c	/^        robj *old = dictGetVal(de);$/;"	l	language:C
old_addr	sentinel.c	/^                sentinelAddr *old_addr;$/;"	l	language:C
old_aof_state	aof.c	/^    int old_aof_state = server.aof_state;$/;"	l	language:C
old_maxclients	server.c	/^                int old_maxclients = server.maxclients;$/;"	l	language:C
old_ping_sent	cluster.c	/^            mstime_t old_ping_sent;$/;"	l	language:C
oldaddr	sentinel.c	/^    sentinelAddr *oldaddr, *newaddr;$/;"	l	language:C
oldcount	hyperloglog.c	/^    uint8_t oldcount, count, *sparse, *end, *p, *prev, *next;$/;"	l	language:C
oldcount	hyperloglog.c	/^    uint8_t oldcount, count;$/;"	l	language:C
oldest	replication.c	/^        sds oldest = listNodeValue(ln);$/;"	l	language:C
oldfd	aof.c	/^        int newfd, oldfd;$/;"	l	language:C
oldfree	sds.c	/^            unsigned int oldfree;$/;"	l	language:C
oldhdr	hyperloglog.c	/^    struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;$/;"	l	language:C
oldht1	lazyfree.c	/^    dict *oldht1 = db->dict, *oldht2 = db->expires;$/;"	l	language:C
oldht2	lazyfree.c	/^    dict *oldht1 = db->dict, *oldht2 = db->expires;$/;"	l	language:C
oldlen	hyperloglog.c	/^     int oldlen = is_xzero ? 2 : 1;$/;"	l	language:C
oldlen	sds.c	/^                int oldlen = sdslen(x);$/;"	l	language:C
oldlen	sds.c	/^            unsigned char oldlen = SDS_TYPE_5_LEN(flags);$/;"	l	language:C
oldlimit	server.c	/^        rlim_t oldlimit = limit.rlim_cur;$/;"	l	language:C
oldmaster	cluster.c	/^    clusterNode *oldmaster = myself->slaveof;$/;"	l	language:C
oldname	cluster.c	/^        sds oldname;$/;"	l	language:C
oldsize	zmalloc.c	/^    size_t oldsize;$/;"	l	language:C
oldsl	lazyfree.c	/^    zskiplist *oldsl = server.cluster->slots_to_keys;$/;"	l	language:C
oldtype	sds.c	/^    char type, oldtype = s[-1] & SDS_TYPE_MASK;$/;"	l	language:C
oldval	bitops.c	/^                int64_t oldval, newval, wrapped, retval;$/;"	l	language:C
oldval	bitops.c	/^                uint64_t oldval, newval, wrapped, retval;$/;"	l	language:C
oldval	modules/helloworld.c	/^    RedisModuleString *oldval;$/;"	l	language:C
oldval	networking.c	/^    robj *oldval;$/;"	l	language:C
oldval	sentinel.c	/^    uint64_t oldval;$/;"	l	language:C
oldvalue	t_hash.c	/^    long long value, incr, oldvalue;$/;"	l	language:C
oldvalue	t_string.c	/^    long long value, oldvalue;$/;"	l	language:C
olen	t_string.c	/^        size_t olen;$/;"	l	language:C
on	bitops.c	/^    long on;$/;"	l	language:C
one	bitops.c	/^    unsigned long skipval, word = 0, one;$/;"	l	language:C
oomerr	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
op	ae_epoll.c	/^    int op = eventLoop->events[fd].mask == AE_NONE ?$/;"	l	language:C
op	bitops.c	/^    unsigned long op, j, numkeys;$/;"	l	language:C
op	lzf_c.c	/^        u8 *op = (u8 *)out_data;$/;"	l	language:C
op	lzf_d.c	/^  u8       *op = (u8 *)out_data;$/;"	l	language:C
op	server.c	/^        redisOp *op;$/;"	l	language:C
op	server.c	/^    redisOp *op;$/;"	l	language:C
opcode	bitops.c	/^        int opcode; \/* Current operation code. *\/$/;"	l	language:C
opcode	bitops.c	/^    int opcode;         \/* Operation id. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
openDirectLogFiledes	debug.c	/^int openDirectLogFiledes(void) {$/;"	f	language:C	signature:(void)
operations	sort.c	/^    list *operations;$/;"	l	language:C
oplen	hyperloglog.c	/^        long oplen;$/;"	l	language:C
opname	bitops.c	/^    char *opname = c->argv[1]->ptr;$/;"	l	language:C
ops	bitops.c	/^    struct bitfieldOp *ops = NULL; \/* Array of ops to execute at end. *\/$/;"	l	language:C
ops	server.c	/^    long long ops = current_reading -$/;"	l	language:C
ops	server.h	/^    redisOp *ops;$/;"	m	language:C	struct:redisOpArray	access:public
ops_sec	server.c	/^    long long ops_sec;$/;"	l	language:C
opt	config.c	/^    sds opt = sdsnew(option);$/;"	l	language:C
opt	t_zset.c	/^        char *opt = c->argv[scoreidx]->ptr;$/;"	l	language:C
opt_fill	sparkline.c	/^    int opt_fill = flags & SPARKLINE_FILL;$/;"	l	language:C
opt_log	sparkline.c	/^    int opt_log = flags & SPARKLINE_LOG_SCALE;$/;"	l	language:C
optimization_level	quicklist.c	/^static const size_t optimization_level[] = {4096, 8192, 16384, 32768, 65536};$/;"	v	language:C	file:
optimize_start	quicklist.c	/^    int optimize_start =$/;"	l	language:C
option	config.c	/^        sds option = dictGetKey(de);$/;"	l	language:C
option	config.c	/^    char *option = "bind";$/;"	l	language:C
option	config.c	/^    char *option = "client-output-buffer-limit";$/;"	l	language:C
option	config.c	/^    char *option = "notify-keyspace-events";$/;"	l	language:C
option	config.c	/^    char *option = "slaveof";$/;"	l	language:C
option	config.c	/^    const char *name = NULL, *option = "syslog-facility";$/;"	l	language:C
option	sentinel.c	/^    char *option, *value;$/;"	l	language:C
optionSetDictType	config.c	/^dictType optionSetDictType = {$/;"	l	language:C
optionToLineDictType	config.c	/^dictType optionToLineDictType = {$/;"	l	language:C
option_count	quicklist.c	/^    size_t option_count = sizeof(options) \/ sizeof(*options);$/;"	l	language:C
option_length	geo.c	/^    long option_length = 0;$/;"	l	language:C
option_to_line	config.c	/^    dict *option_to_line; \/* Option -> list of config file lines map *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
options	quicklist.c	/^    int options[] = {0, 1, 2, 3, 4, 5, 6, 10};$/;"	l	language:C
options	server.c	/^        sds options = sdsempty();$/;"	l	language:C
org	redis-cli.c	/^    struct commandHelp *org;$/;"	m	language:C	struct:__anon24	typeref:struct:__anon24::commandHelp	file:	access:public
orig_argc	multi.c	/^    int orig_argc;$/;"	l	language:C
orig_argv	multi.c	/^    robj **orig_argv;$/;"	l	language:C
orig_buf	dict.c	/^    char *orig_buf = buf;$/;"	l	language:C
orig_bufsize	dict.c	/^    size_t orig_bufsize = bufsize;$/;"	l	language:C
orig_cmd	multi.c	/^    struct redisCommand *orig_cmd;$/;"	l	language:C
orig_commands	server.h	/^    dict *orig_commands;        \/* Command table before command renaming. *\/$/;"	m	language:C	struct:redisServer	access:public
orig_extent	quicklist.c	/^    int orig_extent = after ? -1 : offset;$/;"	l	language:C
orig_head	quicklist.c	/^    quicklistNode *orig_head = quicklist->head;$/;"	l	language:C
orig_start	quicklist.c	/^    int orig_start = after ? offset + 1 : 0;$/;"	l	language:C
orig_tail	quicklist.c	/^    quicklistNode *orig_tail = quicklist->tail;$/;"	l	language:C
orig_value	config.c	/^        int orig_value = server.maxclients;$/;"	l	language:C
orighe	dict.c	/^    dictEntry *he, *orighe;$/;"	l	language:C
original_output	redis-cli.c	/^    int original_output = config.output;$/;"	l	language:C
origincount	geo.c	/^    size_t origincount = ga->used;$/;"	l	language:C
orphaned_masters	cluster.c	/^    int orphaned_masters; \/* How many masters there are without ok slaves. *\/$/;"	l	language:C
orphaned_time	cluster.h	/^    mstime_t orphaned_time;     \/* Starting time of orphaned master condition *\/$/;"	m	language:C	struct:clusterNode	access:public
other	sentinel.c	/^                sentinelRedisInstance *other =$/;"	l	language:C
out	rdb.c	/^    void *out;$/;"	l	language:C
out	redis-cli.c	/^    sds out = NULL;$/;"	l	language:C
out	redis-cli.c	/^    sds out = sdsempty(), tmp;$/;"	l	language:C
out	redis-cli.c	/^    sds out = sdsempty();$/;"	l	language:C
out_end	lzf_c.c	/^        u8 *out_end = op + out_len;$/;"	l	language:C
out_end	lzf_d.c	/^  u8       *const out_end = op + out_len;$/;"	l	language:C
outlen	rdb.c	/^    size_t comprlen, outlen;$/;"	l	language:C
outofrangeerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
output	bitops.c	/^        unsigned char output, byte;$/;"	l	language:C
output	redis-cli.c	/^    int output = 1;$/;"	l	language:C
output	redis-cli.c	/^    int output; \/* output mode, see OUTPUT_* defines *\/$/;"	m	language:C	struct:config	file:	access:public
output	redis-cli.c	/^    unsigned long output = 0;$/;"	l	language:C
output_raw	redis-cli.c	/^    int j, output_raw;$/;"	l	language:C
outputlen	sort.c	/^    unsigned int outputlen = 0;$/;"	l	language:C
outputs	redis-cli.c	/^    int j, outputs = 0;$/;"	l	language:C
ov	cluster.c	/^    robj **ov = NULL; \/* Objects to migrate. *\/$/;"	l	language:C
overflow	bitops.c	/^                int overflow;$/;"	l	language:C
owner	redis-trib.rb	/^            owner = get_node_with_most_keys_in_slot(@nodes,slot)$/;"	v	language:C
owtype	bitops.c	/^    int owtype = BFOVERFLOW_WRAP; \/* Overflow type. *\/$/;"	l	language:C
owtype	bitops.c	/^    int owtype;         \/* Overflow type to use. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
owtypename	bitops.c	/^            char *owtypename = c->argv[j+1]->ptr;$/;"	l	language:C
p	anet.c	/^    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;$/;"	l	language:C
p	anet.c	/^    struct addrinfo hints, *servinfo, *p;$/;"	l	language:C
p	bitops.c	/^    char *p = o->ptr;$/;"	l	language:C
p	bitops.c	/^    unsigned char *p = NULL;$/;"	l	language:C
p	bitops.c	/^    unsigned char *p = s;$/;"	l	language:C
p	bitops.c	/^    unsigned char *p;$/;"	l	language:C
p	cluster.c	/^        char *p, *s;$/;"	l	language:C
p	db.c	/^        unsigned char *p = ziplistIndex(o->ptr,0);$/;"	l	language:C
p	debug.c	/^        char *start, *end, *p = line;$/;"	l	language:C
p	evict.c	/^    double p = 1.0\/(baseval*server.lfu_log_factor+1);$/;"	l	language:C
p	hyperloglog.c	/^        uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);$/;"	l	language:C
p	hyperloglog.c	/^    uint8_t *end = sparse+sparselen, *p = sparse;$/;"	l	language:C
p	hyperloglog.c	/^    uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);$/;"	l	language:C
p	hyperloglog.c	/^    uint8_t *p;$/;"	l	language:C
p	hyperloglog.c	/^    uint8_t oldcount, count, *sparse, *end, *p, *prev, *next;$/;"	l	language:C
p	memtest.c	/^    unsigned long *p = m;$/;"	l	language:C
p	memtest.c	/^    unsigned long j, *p;$/;"	l	language:C
p	module.c	/^        char *p = strchr(cset,name[j]);$/;"	l	language:C
p	module.c	/^    char *p = name+8;$/;"	l	language:C
p	module.c	/^    char *p = strchr(proto+1,'\\r');$/;"	l	language:C
p	module.c	/^    const char *p = fmt;$/;"	l	language:C
p	networking.c	/^        char *p = c->argv[2]->ptr;$/;"	l	language:C
p	networking.c	/^    char flags[16], events[3], *p;$/;"	l	language:C
p	notify.c	/^    char *p = classes;$/;"	l	language:C
p	quicklist.c	/^    int p = 0;$/;"	l	language:C
p	quicklist.c	/^    unsigned char *p = ziplistIndex(quicklist->tail->zl, -1);$/;"	l	language:C
p	quicklist.c	/^    unsigned char *p = ziplistIndex(zl, 0);$/;"	l	language:C
p	quicklist.c	/^    unsigned char *p;$/;"	l	language:C
p	rand.c	/^    uint32_t p[2], q[2], r[2], carry0, carry1;$/;"	l	language:C
p	rdb.c	/^        char buf[LONG_STR_SIZE], *p;$/;"	l	language:C
p	redis-benchmark.c	/^            char *p = c->obuf;$/;"	l	language:C
p	redis-benchmark.c	/^        char *p = c->randptr[i]+11;$/;"	l	language:C
p	redis-cli.c	/^        char *p = reply->str, *s;$/;"	l	language:C
p	redis-cli.c	/^    char *p = strstr(info,field);$/;"	l	language:C
p	redis-cli.c	/^    char buf[4096], *p;$/;"	l	language:C
p	replication.c	/^    unsigned char *p = ptr;$/;"	l	language:C
p	replication.c	/^    void *p;$/;"	l	language:C
p	rio.c	/^    unsigned char *p = (unsigned char*) buf;$/;"	l	language:C
p	scripting.c	/^        const void *p = lua_topointer(lua,idx);$/;"	l	language:C
p	scripting.c	/^    char *p = copy;$/;"	l	language:C
p	scripting.c	/^    char *p = reply;$/;"	l	language:C
p	scripting.c	/^    char *p = strchr(reply+1,'\\r');$/;"	l	language:C
p	sds.c	/^            char *p;$/;"	l	language:C
p	sds.c	/^    char *p, aux;$/;"	l	language:C
p	sds.c	/^    const char *p = line;$/;"	l	language:C
p	sort.c	/^    char *p, *f, *k;$/;"	l	language:C
p	t_zset.c	/^    unsigned char *p = eptr;$/;"	l	language:C
p	t_zset.c	/^    unsigned char *p;$/;"	l	language:C
p	util.c	/^            char *p = abspath + sdslen(abspath)-2;$/;"	l	language:C
p	util.c	/^            char *p = buf+l-1;$/;"	l	language:C
p	util.c	/^    const char *p = s;$/;"	l	language:C
p	ziplist.c	/^        unsigned char *p = e[1].p;$/;"	l	language:C
p	ziplist.c	/^        unsigned char *p = zl+ZIPLIST_HEADER_SIZE;$/;"	l	language:C
p	ziplist.c	/^        unsigned char *p;$/;"	l	language:C
p	ziplist.c	/^    int p = 0;$/;"	l	language:C
p	ziplist.c	/^    unsigned char *p = ziplistIndex(zl,index);$/;"	l	language:C
p	ziplist.c	/^    unsigned char *p, *vstr;$/;"	l	language:C
p	ziplist.c	/^    unsigned char *p;$/;"	l	language:C
p	ziplist.c	/^    unsigned char *p;$/;"	m	language:C	struct:zlentry	file:	access:public
p	ziplist.c	/^    unsigned char *zl, *p;$/;"	l	language:C
p	zipmap.c	/^        unsigned char *p = zipmapRewind(zm);$/;"	l	language:C
p	zipmap.c	/^    unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen);$/;"	l	language:C
p	zipmap.c	/^    unsigned char *p = zm+1, *k = NULL;$/;"	l	language:C
p	zipmap.c	/^    unsigned char *p;$/;"	l	language:C
p	zmalloc.c	/^            char *p = strchr(line,'k');$/;"	l	language:C
p	zmalloc.c	/^    char *p = zmalloc(l);$/;"	l	language:C
p	zmalloc.c	/^    char *p, *x;$/;"	l	language:C
p4	bitops.c	/^    uint32_t *p4;$/;"	l	language:C
pa	pqsort.c	/^	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;$/;"	l	language:C
pa	pubsub.c	/^    pubsubPattern *pa = a, *pb = b;$/;"	l	language:C
pa_head	module.c	/^    struct RedisModulePoolAllocBlock *pa_head;$/;"	m	language:C	struct:RedisModuleCtx	typeref:struct:RedisModuleCtx::RedisModulePoolAllocBlock	file:	access:public
padding	config.c	/^    int content_size = sdslen(content), padding = 0;$/;"	l	language:C
padlen	modules/helloworld.c	/^    long long padlen;$/;"	l	language:C
page	zmalloc.c	/^    int page = sysconf(_SC_PAGESIZE);$/;"	l	language:C
parallel_syncs	sentinel.c	/^    int parallel_syncs; \/* How many slaves to reconfigure at same time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
param	expire.c	/^    robj *key = c->argv[1], *param = c->argv[2];$/;"	l	language:C
params	help.h	/^  char *params;$/;"	m	language:C	struct:commandHelp	access:public
parseOptions	redis-benchmark.c	/^int parseOptions(int argc, const char **argv) {$/;"	f	language:C	signature:(int argc, const char **argv)
parseOptions	redis-cli.c	/^static int parseOptions(int argc, char **argv) {$/;"	f	language:C	file:	signature:(int argc, char **argv)
parseScanCursorOrReply	db.c	/^int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {$/;"	f	language:C	signature:(client *c, robj *o, unsigned long *cursor)
parseScanCursorOrReply	server.h	/^int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor);$/;"	p	language:C	signature:(client *c, robj *o, unsigned long *cursor)
pass	memtest.c	/^        int pass = 0;$/;"	l	language:C
pass	memtest.c	/^    int pass = 0;$/;"	l	language:C
passed	modules/API.md	/^so a set of format specifiers must be passed, followed by arguments$/;"	v	language:C
passed	modules/API.md	/^the parameters are passed, but it does not return anything as the error$/;"	v	language:C
pat	db.c	/^    sds pat = NULL;$/;"	l	language:C
pat	pubsub.c	/^            pubsubPattern *pat = ln->value;$/;"	l	language:C
pat	pubsub.c	/^        pubsubPattern *pat;$/;"	l	language:C
pat	pubsub.c	/^        sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;$/;"	l	language:C
pat	pubsub.c	/^    pubsubPattern *pat = p;$/;"	l	language:C
pat	pubsub.c	/^    pubsubPattern pat;$/;"	l	language:C
path	redis-cli.c	/^    char *path = NULL;$/;"	l	language:C
path	server.h	/^    sds path;$/;"	m	language:C	struct:moduleLoadQueueEntry	access:public
pathIsBaseName	util.c	/^int pathIsBaseName(char *path) {$/;"	f	language:C	signature:(char *path)
pathIsBaseName	util.h	/^int pathIsBaseName(char *path);$/;"	p	language:C	signature:(char *path)
patlen	db.c	/^    int patlen = 0, use_pattern = 0;$/;"	l	language:C
pattern	config.c	/^    char *pattern = o->ptr;$/;"	l	language:C
pattern	db.c	/^    sds pattern = c->argv[1]->ptr;$/;"	l	language:C
pattern	pubsub.c	/^        robj *pattern = ln->value;$/;"	l	language:C
pattern	redis-cli.c	/^    char *pattern;$/;"	m	language:C	struct:config	file:	access:public
pattern	server.h	/^    robj *pattern;$/;"	m	language:C	struct:_redisSortOperation	access:public
pattern	server.h	/^    robj *pattern;$/;"	m	language:C	struct:pubsubPattern	access:public
pauseClients	networking.c	/^void pauseClients(mstime_t end) {$/;"	f	language:C	signature:(mstime_t end)
pauseClients	server.h	/^void pauseClients(mstime_t duration);$/;"	p	language:C	signature:(mstime_t duration)
payload	cluster.c	/^    rio cmd, payload;$/;"	l	language:C
payload	cluster.c	/^    rio payload;$/;"	l	language:C
payload	cluster.c	/^    unsigned char buf[sizeof(clusterMsg)], *payload;$/;"	l	language:C
payload	redis-cli.c	/^    unsigned long long payload = sendSync(fd);$/;"	l	language:C
payload	redis-cli.c	/^    unsigned long long payload = sendSync(s);$/;"	l	language:C
payload	sentinel.c	/^    char payload[NET_IP_STR_LEN+1024];$/;"	l	language:C
payload	sentinel.c	/^    robj *channel, *payload;$/;"	l	language:C
pb	pqsort.c	/^	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;$/;"	l	language:C
pb	pubsub.c	/^    pubsubPattern *pa = a, *pb = b;$/;"	l	language:C
pc	pqsort.c	/^	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;$/;"	l	language:C
pc	sentinel.c	/^    redisAsyncContext *pc; \/* Hiredis context for Pub \/ Sub. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
pc_conn_time	sentinel.c	/^    mstime_t pc_conn_time; \/* pc connection time. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
pc_last_activity	sentinel.c	/^    mstime_t pc_last_activity; \/* Last time we received any message. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
pct	redis-cli.c	/^    double pct;$/;"	l	language:C
pd	db.c	/^    void **pd = (void**) privdata;$/;"	l	language:C
pd	pqsort.c	/^	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;$/;"	l	language:C
peak_hmem	server.c	/^        char peak_hmem[64];$/;"	l	language:C
peerid	networking.c	/^    char peerid[NET_PEER_ID_LEN];$/;"	l	language:C
peerid	server.h	/^    sds peerid;             \/* Cached peer ID. *\/$/;"	m	language:C	struct:client	access:public
pending	redis-benchmark.c	/^    int pending;            \/* Number of pending requests (replies to consume) *\/$/;"	m	language:C	struct:_client	file:	access:public
pending_commands	sentinel.c	/^    int pending_commands;  \/* Number of commands sent waiting for a reply. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
pending_fds	ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
pending_masks	ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
perc	redis-benchmark.c	/^    float perc, reqpersec;$/;"	l	language:C
perc	server.c	/^            double perc;$/;"	l	language:C
period	latency.h	/^    time_t period;          \/* Number of seconds since first event and now. *\/$/;"	m	language:C	struct:latencyStats	access:public
persistCommand	expire.c	/^void persistCommand(client *c) {$/;"	f	language:C	signature:(client *c)
persistCommand	server.h	/^void persistCommand(client *c);$/;"	p	language:C	signature:(client *c)
pexpireCommand	expire.c	/^void pexpireCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pexpireCommand	server.h	/^void pexpireCommand(client *c);$/;"	p	language:C	signature:(client *c)
pexpireatCommand	expire.c	/^void pexpireatCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pexpireatCommand	server.h	/^void pexpireatCommand(client *c);$/;"	p	language:C	signature:(client *c)
pfaddCommand	hyperloglog.c	/^void pfaddCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pfaddCommand	server.h	/^void pfaddCommand(client *c);$/;"	p	language:C	signature:(client *c)
pfcountCommand	hyperloglog.c	/^void pfcountCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pfcountCommand	server.h	/^void pfcountCommand(client *c);$/;"	p	language:C	signature:(client *c)
pfd	ae.c	/^    struct pollfd pfd;$/;"	l	language:C
pfd	ae_evport.c	/^    int fullmask, pfd;$/;"	l	language:C
pfdebugCommand	hyperloglog.c	/^void pfdebugCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pfdebugCommand	server.h	/^void pfdebugCommand(client *c);$/;"	p	language:C	signature:(client *c)
pfmergeCommand	hyperloglog.c	/^void pfmergeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pfmergeCommand	server.h	/^void pfmergeCommand(client *c);$/;"	p	language:C	signature:(client *c)
pfselftestCommand	hyperloglog.c	/^void pfselftestCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pfselftestCommand	server.h	/^void pfselftestCommand(client *c);$/;"	p	language:C	signature:(client *c)
pid	scripting.c	/^        pid_t pid = (unsigned long) ln->value;$/;"	l	language:C
pid	sentinel.c	/^        pid_t pid;$/;"	l	language:C
pid	sentinel.c	/^    pid_t pid;              \/* Script execution pid. *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
pid	sentinel.c	/^    pid_t pid;$/;"	l	language:C
pid	server.c	/^        pid_t pid = getpid();$/;"	l	language:C
pid	server.c	/^        pid_t pid;$/;"	l	language:C
pid	server.h	/^    pid_t pid;                  \/* Main process pid. *\/$/;"	m	language:C	struct:redisServer	access:public
pid	util.c	/^        pid_t pid = getpid();$/;"	l	language:C
pidfile	server.h	/^    char *pidfile;              \/* PID file path *\/$/;"	m	language:C	struct:redisServer	access:public
ping	cluster.h	/^    } ping;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon6	access:public
pingCommand	server.c	/^void pingCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pingCommand	server.h	/^void pingCommand(client *c);$/;"	p	language:C	signature:(client *c)
ping_argv	replication.c	/^    robj *ping_argv[1];$/;"	l	language:C
ping_period	sentinel.c	/^    mstime_t info_period, ping_period;$/;"	l	language:C
ping_sent	cluster.h	/^    mstime_t ping_sent;      \/* Unix time we sent latest ping *\/$/;"	m	language:C	struct:clusterNode	access:public
ping_sent	cluster.h	/^    uint32_t ping_sent;$/;"	m	language:C	struct:__anon2	access:public
pipeMode	redis-cli.c	/^static void pipeMode(void) {$/;"	f	language:C	file:	signature:(void)
pipe_mode	redis-cli.c	/^    int pipe_mode;$/;"	m	language:C	struct:config	file:	access:public
pipe_timeout	redis-cli.c	/^    int pipe_timeout;$/;"	m	language:C	struct:config	file:	access:public
pipefds	rdb.c	/^    int pipefds[2];$/;"	l	language:C
pipeline	redis-benchmark.c	/^    int pipeline;$/;"	m	language:C	struct:config	file:	access:public
pl	pqsort.c	/^	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;$/;"	l	language:C
pl	redis-cli.c	/^    double pl, r;$/;"	l	language:C
plain	rdb.c	/^    int plain = flags & RDB_LOAD_PLAIN;$/;"	l	language:C
plen	bitops.c	/^    size_t plen = sdslen(p);$/;"	l	language:C
plen	db.c	/^    int plen = sdslen(pattern), allkeys;$/;"	l	language:C
plen	scripting.c	/^    char *plen = p+1; \/* Multi bulk len pointer. *\/$/;"	l	language:C
plen	util.c	/^    size_t plen = 0;$/;"	l	language:C
plus	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
pm	pqsort.c	/^	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;$/;"	l	language:C
pmessagebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
pn	pqsort.c	/^	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;$/;"	l	language:C
pointer	modules/API.md	/^Return a pointer, and a length, to the protocol returned by the command$/;"	v	language:C
pointer	modules/API.md	/^pointer) with a pointer to a StringRedisModule pointer, that is set to the$/;"	v	language:C
pointer	server.h	/^    unsigned long pointer;$/;"	m	language:C	struct:redisFunctionSym	access:public
pointers	modules/INTRO.md	/^of RedisModuleString object pointers, and a C string representing the$/;"	v	language:C
pong	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
pong_received	cluster.h	/^    mstime_t pong_received;  \/* Unix time we received the pong *\/$/;"	m	language:C	struct:clusterNode	access:public
pong_received	cluster.h	/^    uint32_t pong_received;$/;"	m	language:C	struct:__anon2	access:public
pool	evict.c	/^            struct evictionPoolEntry *pool = EvictionPoolLRU;$/;"	l	language:C
poolAllocRelease	module.c	/^void poolAllocRelease(RedisModuleCtx *ctx) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx)
pop	ziplist.c	/^static unsigned char *pop(unsigned char *zl, int where) {$/;"	f	language:C	file:	signature:(unsigned char *zl, int where)
popGenericCommand	server.h	/^void popGenericCommand(client *c, int where);$/;"	p	language:C	signature:(client *c, int where)
popGenericCommand	t_list.c	/^void popGenericCommand(client *c, int where) {$/;"	f	language:C	signature:(client *c, int where)
populate	quicklist.c	/^            char *populate = genstr("hello", 331);$/;"	l	language:C
populateCommandTable	server.c	/^void populateCommandTable(void) {$/;"	f	language:C	signature:(void)
populateCommandTable	server.h	/^void populateCommandTable(void);$/;"	p	language:C	signature:(void)
port	anet.c	/^    int port;$/;"	l	language:C
port	cluster.c	/^        char *port = p+1;$/;"	l	language:C
port	cluster.c	/^        long long port, cport;$/;"	l	language:C
port	cluster.c	/^    int port = ntohs(hdr->port);$/;"	l	language:C
port	cluster.h	/^    int port;                   \/* Latest known clients port of this node *\/$/;"	m	language:C	struct:clusterNode	access:public
port	cluster.h	/^    uint16_t port;              \/* base port last time it was seen *\/$/;"	m	language:C	struct:__anon2	access:public
port	cluster.h	/^    uint16_t port;      \/* TCP base port number. *\/$/;"	m	language:C	struct:__anon10	access:public
port	replication.c	/^            long port;$/;"	l	language:C
port	replication.c	/^        long port;$/;"	l	language:C
port	replication.c	/^        sds port = sdsfromlonglong(server.slave_announce_port ?$/;"	l	language:C
port	sentinel.c	/^            char *ip, *port, *end;$/;"	l	language:C
port	sentinel.c	/^        char port[32];$/;"	l	language:C
port	sentinel.c	/^        long port;$/;"	l	language:C
port	sentinel.c	/^        long quorum, port;$/;"	l	language:C
port	sentinel.c	/^    int numtokens, port, removed, master_port;$/;"	l	language:C
port	sentinel.c	/^    int port;$/;"	m	language:C	struct:sentinelAddr	file:	access:public
port	server.c	/^                int port;$/;"	l	language:C
port	server.h	/^    int port;                   \/* TCP listening port *\/$/;"	m	language:C	struct:redisServer	access:public
portfd	ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	language:C	struct:aeApiState	file:	access:public
portstr	anet.c	/^    char portstr[6];  \/* strlen("65535") + 1; *\/$/;"	l	language:C
portstr	sentinel.c	/^    char portstr[32];$/;"	l	language:C
pos	bitops.c	/^        long pos = redisBitpos(p+start,bytes,bit);$/;"	l	language:C
pos	bitops.c	/^    long pos = 0; \/* Position of bit, to return to the caller. *\/$/;"	l	language:C
pos	cluster.c	/^        size_t pos = 0, towrite;$/;"	l	language:C
pos	db.c	/^        int pos = 0;$/;"	l	language:C
pos	intset.c	/^    uint32_t pos;$/;"	l	language:C
pos	module.c	/^        unsigned long pos = p-cset;$/;"	l	language:C
pos	networking.c	/^    int pos = 0, ok;$/;"	l	language:C
pos	quicklist.c	/^    int pos = (where == QUICKLIST_HEAD) ? 0 : -1;$/;"	l	language:C
pos	redis-check-aof.c	/^    off_t pos = 0;$/;"	l	language:C
pos	redis-check-aof.c	/^    off_t pos = process(fp);$/;"	l	language:C
pos	redis-cli.c	/^    int i, len, pos = 0;$/;"	l	language:C
pos	rio.h	/^            off_t pos;$/;"	m	language:C	struct:_rio::__anon25::__anon26	access:public
pos	rio.h	/^            off_t pos;$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
pos	t_list.c	/^        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;$/;"	l	language:C
pos	t_zset.c	/^        int pos = 4;$/;"	l	language:C
posstr	ziplist.c	/^    char posstr[2][5] = { "HEAD", "TAIL" };$/;"	l	language:C
postfixlen	sort.c	/^    int prefixlen, sublen, postfixlen, fieldlen;$/;"	l	language:C
postponed_arrays	module.c	/^    void **postponed_arrays;        \/* To set with RM_ReplySetArrayLength(). *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
postponed_arrays_count	module.c	/^    int postponed_arrays_count;     \/* Number of entries in postponed_arrays. *\/$/;"	m	language:C	struct:RedisModuleCtx	file:	access:public
powerLawRand	redis-cli.c	/^long long powerLawRand(long long min, long long max, double alpha) {$/;"	f	language:C	signature:(long long min, long long max, double alpha)
pqsort	pqsort.c	/^pqsort(void *a, size_t n, size_t es,$/;"	f	language:C	signature:(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
pqsort	pqsort.h	/^pqsort(void *a, size_t n, size_t es,$/;"	p	language:C	signature:(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
pref	redis-cli.c	/^static struct pref {$/;"	s	language:C	file:
pref	redis-cli.c	/^} pref;$/;"	v	language:C	typeref:struct:pref	file:
pref::hints	redis-cli.c	/^    int hints;$/;"	m	language:C	struct:pref	file:	access:public
prefix	scripting.c	/^                sds prefix = sdscatprintf(sdsempty(),"<value> %s = ",name);$/;"	l	language:C
prefix	scripting.c	/^    char *prefix;$/;"	l	language:C
prefix_pending	redis-benchmark.c	/^    int prefix_pending;     \/* If non-zero, number of pending prefix commands. Commands$/;"	m	language:C	struct:_client	file:	access:public
prefixlen	redis-benchmark.c	/^    int prefixlen;          \/* Size in bytes of the pending prefix commands *\/$/;"	m	language:C	struct:_client	file:	access:public
prefixlen	sort.c	/^    int prefixlen, sublen, postfixlen, fieldlen;$/;"	l	language:C
prepareClientToWrite	networking.c	/^int prepareClientToWrite(client *c) {$/;"	f	language:C	signature:(client *c)
prepareForShutdown	server.c	/^int prepareForShutdown(int flags) {$/;"	f	language:C	signature:(int flags)
prepareForShutdown	server.h	/^int prepareForShutdown();$/;"	p	language:C
prepend	intset.c	/^    int prepend = value < 0 ? 1 : 0;$/;"	l	language:C
prev	adlist.h	/^    struct listNode *prev;$/;"	m	language:C	struct:listNode	typeref:struct:listNode::listNode	access:public
prev	ae.c	/^    aeTimeEvent *te, *prev;$/;"	l	language:C
prev	hyperloglog.c	/^    uint8_t oldcount, count, *sparse, *end, *p, *prev, *next;$/;"	l	language:C
prev	latency.c	/^    int prev;$/;"	l	language:C
prev	module.c	/^        unsigned char *prev;$/;"	l	language:C
prev	module.c	/^        zskiplistNode *ln = key->zcurrent, *prev = ln->backward;$/;"	l	language:C
prev	modules/hellotype.c	/^    struct HelloTypeNode *next = o->head, *newnode, *prev = NULL;$/;"	l	language:C
prev	quicklist.c	/^    quicklistNode *prev = NULL;$/;"	l	language:C
prev	quicklist.c	/^    quicklistNode *prev = entry->node->prev;$/;"	l	language:C
prev	quicklist.c	/^    quicklistNode *prev, *prev_prev, *next, *next_next, *target;$/;"	l	language:C
prev	quicklist.h	/^    struct quicklistNode *prev;$/;"	m	language:C	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode	access:public
prevHe	dict.c	/^    dictEntry *he, *prevHe;$/;"	l	language:C
prev_also_propagate	server.c	/^    redisOpArray prev_also_propagate = server.also_propagate;$/;"	l	language:C
prev_ip	cluster.c	/^        static char *prev_ip = NULL;$/;"	l	language:C	file:
prev_prev	quicklist.c	/^    quicklistNode *prev, *prev_prev, *next, *next_next, *target;$/;"	l	language:C
prevcmd	networking.c	/^    redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;$/;"	l	language:C
preventCommandAOF	server.c	/^void preventCommandAOF(client *c) {$/;"	f	language:C	signature:(client *c)
preventCommandAOF	server.h	/^void preventCommandAOF(client *c);$/;"	p	language:C	signature:(client *c)
preventCommandPropagation	server.c	/^void preventCommandPropagation(client *c) {$/;"	f	language:C	signature:(client *c)
preventCommandPropagation	server.h	/^void preventCommandPropagation(client *c);$/;"	p	language:C	signature:(client *c)
preventCommandReplication	server.c	/^void preventCommandReplication(client *c) {$/;"	f	language:C	signature:(client *c)
preventCommandReplication	server.h	/^void preventCommandReplication(client *c);$/;"	p	language:C	signature:(client *c)
previous_time	sentinel.c	/^    mstime_t previous_time;         \/* Last time we ran the time handler. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
prevlen	ziplist.c	/^    unsigned int prevlensize, prevlen = 0;$/;"	l	language:C
prevlensize	ziplist.c	/^        unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
prevlensize	ziplist.c	/^    unsigned int prevlensize, encoding, lensize, len;$/;"	l	language:C
prevlensize	ziplist.c	/^    unsigned int prevlensize, prevlen = 0;$/;"	l	language:C
prevlensize	ziplist.c	/^    unsigned int prevlensize;$/;"	l	language:C
prevrawlen	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	language:C	struct:zlentry	file:	access:public
prevrawlensize	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	language:C	struct:zlentry	file:	access:public
printBits	bitops.c	/^void printBits(unsigned char *p, unsigned long count) {$/;"	f	language:C	signature:(unsigned char *p, unsigned long count)
private_dirty	aof.c	/^            size_t private_dirty = zmalloc_get_private_dirty();$/;"	l	language:C
private_dirty	rdb.c	/^            size_t private_dirty = zmalloc_get_private_dirty();$/;"	l	language:C
privdata	db.c	/^        void *privdata[2];$/;"	l	language:C
privdata	dict.h	/^    void *privdata;$/;"	m	language:C	struct:dict	access:public
problems	modules/TYPES.md	/^problems, this is not enough, and the implementation of new data structures$/;"	v	language:C
proc	aof.c	/^        cmd->proc(fakeClient);$/;"	p	language:C	file:
proc	server.c	/^    c->cmd->proc(c);$/;"	p	language:C	file:
proc	server.h	/^    redisCommandProc *proc;$/;"	m	language:C	struct:redisCommand	access:public
process	redis-check-aof.c	/^off_t process(FILE *fp) {$/;"	f	language:C	signature:(FILE *fp)
processClientsWaitingReplicas	replication.c	/^void processClientsWaitingReplicas(void) {$/;"	f	language:C	signature:(void)
processClientsWaitingReplicas	server.h	/^void processClientsWaitingReplicas(void);$/;"	p	language:C	signature:(void)
processCommand	server.c	/^int processCommand(client *c) {$/;"	f	language:C	signature:(client *c)
processCommand	server.h	/^int processCommand(client *c);$/;"	p	language:C	signature:(client *c)
processEventsWhileBlocked	networking.c	/^int processEventsWhileBlocked(void) {$/;"	f	language:C	signature:(void)
processEventsWhileBlocked	server.h	/^int processEventsWhileBlocked(void);$/;"	p	language:C	signature:(void)
processInlineBuffer	networking.c	/^int processInlineBuffer(client *c) {$/;"	f	language:C	signature:(client *c)
processInputBuffer	networking.c	/^void processInputBuffer(client *c) {$/;"	f	language:C	signature:(client *c)
processInputBuffer	server.h	/^void processInputBuffer(client *c);$/;"	p	language:C	signature:(client *c)
processMultibulkBuffer	networking.c	/^int processMultibulkBuffer(client *c) {$/;"	f	language:C	signature:(client *c)
processTimeEvents	ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	language:C	file:	signature:(aeEventLoop *eventLoop)
processUnblockedClients	blocked.c	/^void processUnblockedClients(void) {$/;"	f	language:C	signature:(void)
processUnblockedClients	server.h	/^void processUnblockedClients(void);$/;"	p	language:C	signature:(void)
processed	ae.c	/^    int processed = 0, numevents;$/;"	l	language:C
processed	ae.c	/^    int processed = 0;$/;"	l	language:C
processed	aof.c	/^    size_t processed = 0;$/;"	l	language:C
processed	networking.c	/^    int processed = listLength(server.clients_pending_write);$/;"	l	language:C
processed	t_zset.c	/^    int processed = 0;  \/* Number of elements processed, may remain zero with$/;"	l	language:C
processed_bytes	rio.h	/^    size_t processed_bytes;$/;"	m	language:C	struct:_rio	access:public
progress_full	memtest.c	/^size_t progress_full; \/* How many chars to write to fill the progress bar. *\/$/;"	v	language:C
progress_printed	memtest.c	/^size_t progress_printed; \/* Printed chars in screen-wide progress bar. *\/$/;"	v	language:C
promoted_slave	sentinel.c	/^    struct sentinelRedisInstance *promoted_slave; \/* Promoted slave instance. *\/$/;"	m	language:C	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
prompt	redis-cli.c	/^    char prompt[128];$/;"	m	language:C	struct:config	file:	access:public
propagate	server.c	/^void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f	language:C	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags)
propagate	server.h	/^void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags);$/;"	p	language:C	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags)
propagateExpire	db.c	/^void propagateExpire(redisDb *db, robj *key, int lazy) {$/;"	f	language:C	signature:(redisDb *db, robj *key, int lazy)
propagateExpire	server.h	/^void propagateExpire(redisDb *db, robj *key, int lazy);$/;"	p	language:C	signature:(redisDb *db, robj *key, int lazy)
propagate_flags	server.c	/^        int propagate_flags = PROPAGATE_NONE;$/;"	l	language:C
propargv	module.c	/^        robj *propargv[1];$/;"	l	language:C
propargv	scripting.c	/^            robj *propargv[1];$/;"	l	language:C
propargv	t_set.c	/^    robj *propargv[3];$/;"	l	language:C
protected_mode	server.h	/^    int protected_mode;         \/* Don't accept external connections. *\/$/;"	m	language:C	struct:redisServer	access:public
proto	module.c	/^    char *proto = reply->proto;$/;"	l	language:C
proto	module.c	/^    char *proto;    \/* Raw reply protocol. An SDS string at top-level object. *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
proto	module.c	/^    sds proto = sdsnewlen(c->buf,c->bufpos);$/;"	l	language:C
proto	module.c	/^    sds proto = sdsnewlen(reply->proto, reply->protolen);$/;"	l	language:C
proto	scripting.c	/^    sds proto = sdsempty();$/;"	l	language:C
protolen	module.c	/^    size_t protolen;\/* Length of protocol. *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
psetexCommand	server.h	/^void psetexCommand(client *c);$/;"	p	language:C	signature:(client *c)
psetexCommand	t_string.c	/^void psetexCommand(client *c) {$/;"	f	language:C	signature:(client *c)
psubscribeCommand	pubsub.c	/^void psubscribeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
psubscribeCommand	server.h	/^void psubscribeCommand(client *c);$/;"	p	language:C	signature:(client *c)
psubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
psync_initial_offset	server.h	/^    long long psync_initial_offset; \/* FULLRESYNC reply offset other slaves$/;"	m	language:C	struct:client	access:public
psync_len	replication.c	/^    long long psync_offset, psync_len;$/;"	l	language:C
psync_offset	replication.c	/^    char psync_offset[32];$/;"	l	language:C
psync_offset	replication.c	/^    long long psync_offset = server.master_repl_offset;$/;"	l	language:C
psync_offset	replication.c	/^    long long psync_offset, psync_len;$/;"	l	language:C
psync_result	replication.c	/^    int sockerr = 0, psync_result;$/;"	l	language:C
psync_runid	replication.c	/^    char *psync_runid;$/;"	l	language:C
ptail	ziplist.c	/^        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);$/;"	l	language:C
ptr	debug.c	/^        void *ptr = zmalloc(ULONG_MAX); \/* Should trigger an out of memory. *\/$/;"	l	language:C
ptr	module.c	/^        void *ptr = ctx->amqueue[j].ptr;$/;"	l	language:C
ptr	module.c	/^    void *ptr;$/;"	m	language:C	struct:AutoMemEntry	file:	access:public
ptr	modules/INTRO.md	/^    char *ptr = RedisModule_CallReplyStringPtr(reply,&len);$/;"	v	language:C
ptr	modules/testmodule.c	/^    const char *ptr = RedisModule_StringPtrLen(mystr,NULL);$/;"	l	language:C
ptr	rdb.c	/^        void *ptr = mt->rdb_load(&io,moduleid&1023);$/;"	l	language:C
ptr	redis-benchmark.c	/^        void *ptr = c->obuf+c->written;$/;"	l	language:C
ptr	rio.h	/^            sds ptr;$/;"	m	language:C	struct:_rio::__anon25::__anon26	access:public
ptr	server.h	/^    void *ptr;$/;"	m	language:C	struct:redisObject	access:public
ptr	zmalloc.c	/^    void *ptr = calloc(1, size+PREFIX_SIZE);$/;"	l	language:C
ptr	zmalloc.c	/^    void *ptr = malloc(size+PREFIX_SIZE);$/;"	l	language:C
pttlCommand	expire.c	/^void pttlCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pttlCommand	server.h	/^void pttlCommand(client *c);$/;"	p	language:C	signature:(client *c)
publish	cluster.h	/^    } publish;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon8	access:public
publishCommand	pubsub.c	/^void publishCommand(client *c) {$/;"	f	language:C	signature:(client *c)
publishCommand	server.h	/^void publishCommand(client *c);$/;"	p	language:C	signature:(client *c)
pubsub	sentinel.c	/^    int pubsub;$/;"	l	language:C
pubsubCommand	pubsub.c	/^void pubsubCommand(client *c) {$/;"	f	language:C	signature:(client *c)
pubsubCommand	server.h	/^void pubsubCommand(client *c);$/;"	p	language:C	signature:(client *c)
pubsubPattern	server.h	/^typedef struct pubsubPattern {$/;"	s	language:C
pubsubPattern	server.h	/^} pubsubPattern;$/;"	t	language:C	typeref:struct:pubsubPattern
pubsubPattern::client	server.h	/^    client *client;$/;"	m	language:C	struct:pubsubPattern	access:public
pubsubPattern::pattern	server.h	/^    robj *pattern;$/;"	m	language:C	struct:pubsubPattern	access:public
pubsubPublishMessage	pubsub.c	/^int pubsubPublishMessage(robj *channel, robj *message) {$/;"	f	language:C	signature:(robj *channel, robj *message)
pubsubPublishMessage	server.h	/^int pubsubPublishMessage(robj *channel, robj *message);$/;"	p	language:C	signature:(robj *channel, robj *message)
pubsubSubscribeChannel	pubsub.c	/^int pubsubSubscribeChannel(client *c, robj *channel) {$/;"	f	language:C	signature:(client *c, robj *channel)
pubsubSubscribePattern	pubsub.c	/^int pubsubSubscribePattern(client *c, robj *pattern) {$/;"	f	language:C	signature:(client *c, robj *pattern)
pubsubUnsubscribeAllChannels	pubsub.c	/^int pubsubUnsubscribeAllChannels(client *c, int notify) {$/;"	f	language:C	signature:(client *c, int notify)
pubsubUnsubscribeAllChannels	server.h	/^int pubsubUnsubscribeAllChannels(client *c, int notify);$/;"	p	language:C	signature:(client *c, int notify)
pubsubUnsubscribeAllPatterns	pubsub.c	/^int pubsubUnsubscribeAllPatterns(client *c, int notify) {$/;"	f	language:C	signature:(client *c, int notify)
pubsubUnsubscribeAllPatterns	server.h	/^int pubsubUnsubscribeAllPatterns(client *c, int notify);$/;"	p	language:C	signature:(client *c, int notify)
pubsubUnsubscribeChannel	pubsub.c	/^int pubsubUnsubscribeChannel(client *c, robj *channel, int notify) {$/;"	f	language:C	signature:(client *c, robj *channel, int notify)
pubsubUnsubscribePattern	pubsub.c	/^int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {$/;"	f	language:C	signature:(client *c, robj *pattern, int notify)
pubsub_channels	server.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	language:C	struct:redisServer	access:public
pubsub_channels	server.h	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	language:C	struct:client	access:public
pubsub_mode	redis-cli.c	/^    int pubsub_mode;$/;"	m	language:C	struct:config	file:	access:public
pubsub_patterns	server.h	/^    list *pubsub_patterns;  \/* A list of pubsub_patterns *\/$/;"	m	language:C	struct:redisServer	access:public
pubsub_patterns	server.h	/^    list *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	language:C	struct:client	access:public
punsubscribeCommand	pubsub.c	/^void punsubscribeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
punsubscribeCommand	server.h	/^void punsubscribeCommand(client *c);$/;"	p	language:C	signature:(client *c)
punsubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
pushGenericCommand	t_list.c	/^void pushGenericCommand(client *c, int where) {$/;"	f	language:C	signature:(client *c, int where)
pushed	t_list.c	/^    int j, pushed = 0;$/;"	l	language:C
pushxGenericCommand	t_list.c	/^void pushxGenericCommand(client *c, int where) {$/;"	f	language:C	signature:(client *c, int where)
putSlaveOnline	replication.c	/^void putSlaveOnline(client *slave) {$/;"	f	language:C	signature:(client *slave)
putSlaveOnline	replication.c	/^void putSlaveOnline(client *slave);$/;"	p	language:C	file:	signature:(client *slave)
puts	redis-trib.rb	/^        puts "Set as importing in: #{importing.join(",")}"$/;"	v	language:C
q	rand.c	/^    uint32_t p[2], q[2], r[2], carry0, carry1;$/;"	l	language:C
q	ziplist.c	/^        unsigned char *q;$/;"	l	language:C
qblen	networking.c	/^                size_t qblen;$/;"	l	language:C
qblen	networking.c	/^    size_t qblen;$/;"	l	language:C
qe	t_list.c	/^            quicklistEntry *qe = &entry.entry;$/;"	l	language:C
ql	debug.c	/^            quicklist *ql = val->ptr;$/;"	l	language:C
ql	lazyfree.c	/^        quicklist *ql = obj->ptr;$/;"	l	language:C
ql	quicklist.c	/^                    quicklist *ql = quicklistNew(f, depth);$/;"	l	language:C
ql	quicklist.c	/^                quicklist *ql = quicklistCreateFromZiplist(f, options[_i], zl);$/;"	l	language:C
ql	quicklist.c	/^                quicklist *ql = quicklistNew(f, QUICKLIST_NOCOMPRESS);$/;"	l	language:C
ql	quicklist.c	/^                quicklist *ql = quicklistNew(f, options[_i]);$/;"	l	language:C
ql	quicklist.c	/^            quicklist *ql = quicklistNew(-2, options[_i]);$/;"	l	language:C
ql	rdb.c	/^            quicklist *ql = o->ptr;$/;"	l	language:C
ql	t_list.c	/^        quicklist *ql = o->ptr;$/;"	l	language:C
ql_info	quicklist.c	/^static void ql_info(quicklist *ql) {$/;"	f	language:C	file:	signature:(quicklist *ql)
ql_verify	quicklist.c	/^#define ql_verify(/;"	d	language:C	file:
ql_where	t_list.c	/^    int ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;$/;"	l	language:C
qsortCompareSetsByCardinality	t_set.c	/^int qsortCompareSetsByCardinality(const void *s1, const void *s2) {$/;"	f	language:C	signature:(const void *s1, const void *s2)
qsortCompareSetsByRevCardinality	t_set.c	/^int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {$/;"	f	language:C	signature:(const void *s1, const void *s2)
querybuf	server.h	/^    sds querybuf;           \/* Buffer we use to accumulate client queries. *\/$/;"	m	language:C	struct:client	access:public
querybuf_peak	server.h	/^    size_t querybuf_peak;   \/* Recent (100ms or more) peak of querybuf size. *\/$/;"	m	language:C	struct:client	access:public
querybuf_size	server.c	/^    size_t querybuf_size = sdsAllocSize(c->querybuf);$/;"	l	language:C
querylen	networking.c	/^    size_t querylen;$/;"	l	language:C
queueLoadModule	config.c	/^void queueLoadModule(sds path, sds *argv, int argc) {$/;"	f	language:C	signature:(sds path, sds *argv, int argc)
queueMultiCommand	multi.c	/^void queueMultiCommand(client *c) {$/;"	f	language:C	signature:(client *c)
queueMultiCommand	server.h	/^void queueMultiCommand(client *c);$/;"	p	language:C	signature:(client *c)
queued	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
quicklist	quicklist.c	/^    quicklist *quicklist = quicklistCreate();$/;"	l	language:C
quicklist	quicklist.c	/^    struct quicklist *quicklist;$/;"	l	language:C
quicklist	quicklist.h	/^    const quicklist *quicklist;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklist	quicklist.h	/^    const quicklist *quicklist;$/;"	m	language:C	struct:quicklistIter	access:public
quicklist	quicklist.h	/^typedef struct quicklist {$/;"	s	language:C
quicklist	quicklist.h	/^} quicklist;$/;"	t	language:C	typeref:struct:quicklist
quicklist::compress	quicklist.h	/^    unsigned int compress : 16; \/* depth of end nodes not to compress;0=off *\/$/;"	m	language:C	struct:quicklist	access:public
quicklist::count	quicklist.h	/^    unsigned long count;        \/* total count of all entries in all ziplists *\/$/;"	m	language:C	struct:quicklist	access:public
quicklist::fill	quicklist.h	/^    int fill : 16;              \/* fill factor for individual nodes *\/$/;"	m	language:C	struct:quicklist	access:public
quicklist::head	quicklist.h	/^    quicklistNode *head;$/;"	m	language:C	struct:quicklist	access:public
quicklist::len	quicklist.h	/^    unsigned int len;           \/* number of quicklistNodes *\/$/;"	m	language:C	struct:quicklist	access:public
quicklist::tail	quicklist.h	/^    quicklistNode *tail;$/;"	m	language:C	struct:quicklist	access:public
quicklistAllowsCompression	quicklist.c	/^#define quicklistAllowsCompression(/;"	d	language:C	file:
quicklistAppendValuesFromZiplist	quicklist.c	/^quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,$/;"	f	language:C	signature:(quicklist *quicklist, unsigned char *zl)
quicklistAppendValuesFromZiplist	quicklist.h	/^quicklist *quicklistAppendValuesFromZiplist(quicklist *quicklist,$/;"	p	language:C	signature:(quicklist *quicklist, unsigned char *zl)
quicklistAppendZiplist	quicklist.c	/^void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl) {$/;"	f	language:C	signature:(quicklist *quicklist, unsigned char *zl)
quicklistAppendZiplist	quicklist.h	/^void quicklistAppendZiplist(quicklist *quicklist, unsigned char *zl);$/;"	p	language:C	signature:(quicklist *quicklist, unsigned char *zl)
quicklistCompare	quicklist.c	/^int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len) {$/;"	f	language:C	signature:(unsigned char *p1, unsigned char *p2, int p2_len)
quicklistCompare	quicklist.h	/^int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len);$/;"	p	language:C	signature:(unsigned char *p1, unsigned char *p2, int p2_len)
quicklistCompress	quicklist.c	/^#define quicklistCompress(/;"	d	language:C	file:
quicklistCompressNode	quicklist.c	/^#define quicklistCompressNode(/;"	d	language:C	file:
quicklistCount	quicklist.c	/^unsigned int quicklistCount(const quicklist *ql) { return ql->count; }$/;"	f	language:C	signature:(const quicklist *ql)
quicklistCount	quicklist.h	/^unsigned int quicklistCount(const quicklist *ql);$/;"	p	language:C	signature:(const quicklist *ql)
quicklistCreate	quicklist.c	/^quicklist *quicklistCreate(void) {$/;"	f	language:C	signature:(void)
quicklistCreate	quicklist.h	/^quicklist *quicklistCreate(void);$/;"	p	language:C	signature:(void)
quicklistCreateFromZiplist	quicklist.c	/^quicklist *quicklistCreateFromZiplist(int fill, int compress,$/;"	f	language:C	signature:(int fill, int compress, unsigned char *zl)
quicklistCreateFromZiplist	quicklist.h	/^quicklist *quicklistCreateFromZiplist(int fill, int compress,$/;"	p	language:C	signature:(int fill, int compress, unsigned char *zl)
quicklistCreateNode	quicklist.c	/^REDIS_STATIC quicklistNode *quicklistCreateNode(void) {$/;"	f	language:C	signature:(void)
quicklistDecompressNode	quicklist.c	/^#define quicklistDecompressNode(/;"	d	language:C	file:
quicklistDecompressNodeForUse	quicklist.c	/^#define quicklistDecompressNodeForUse(/;"	d	language:C	file:
quicklistDelEntry	quicklist.c	/^void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {$/;"	f	language:C	signature:(quicklistIter *iter, quicklistEntry *entry)
quicklistDelEntry	quicklist.h	/^void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry);$/;"	p	language:C	signature:(quicklistIter *iter, quicklistEntry *entry)
quicklistDelIndex	quicklist.c	/^REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistNode *node, unsigned char **p)
quicklistDelRange	quicklist.c	/^int quicklistDelRange(quicklist *quicklist, const long start,$/;"	f	language:C	signature:(quicklist *quicklist, const long start, const long count)
quicklistDelRange	quicklist.h	/^int quicklistDelRange(quicklist *quicklist, const long start, const long stop);$/;"	p	language:C	signature:(quicklist *quicklist, const long start, const long stop)
quicklistDeleteIfEmpty	quicklist.c	/^#define quicklistDeleteIfEmpty(/;"	d	language:C	file:
quicklistDup	quicklist.c	/^quicklist *quicklistDup(quicklist *orig) {$/;"	f	language:C	signature:(quicklist *orig)
quicklistDup	quicklist.h	/^quicklist *quicklistDup(quicklist *orig);$/;"	p	language:C	signature:(quicklist *orig)
quicklistEntry	quicklist.h	/^typedef struct quicklistEntry {$/;"	s	language:C
quicklistEntry	quicklist.h	/^} quicklistEntry;$/;"	t	language:C	typeref:struct:quicklistEntry
quicklistEntry::longval	quicklist.h	/^    long long longval;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklistEntry::node	quicklist.h	/^    quicklistNode *node;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklistEntry::offset	quicklist.h	/^    int offset;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklistEntry::quicklist	quicklist.h	/^    const quicklist *quicklist;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklistEntry::sz	quicklist.h	/^    unsigned int sz;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklistEntry::value	quicklist.h	/^    unsigned char *value;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklistEntry::zi	quicklist.h	/^    unsigned char *zi;$/;"	m	language:C	struct:quicklistEntry	access:public
quicklistGetIterator	quicklist.c	/^quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction) {$/;"	f	language:C	signature:(const quicklist *quicklist, int direction)
quicklistGetIterator	quicklist.h	/^quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction);$/;"	p	language:C	signature:(const quicklist *quicklist, int direction)
quicklistGetIteratorAtIdx	quicklist.c	/^quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,$/;"	f	language:C	signature:(const quicklist *quicklist, const int direction, const long long idx)
quicklistGetIteratorAtIdx	quicklist.h	/^quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist,$/;"	p	language:C	signature:(const quicklist *quicklist, int direction, const long long idx)
quicklistGetLzf	quicklist.c	/^size_t quicklistGetLzf(const quicklistNode *node, void **data) {$/;"	f	language:C	signature:(const quicklistNode *node, void **data)
quicklistGetLzf	quicklist.h	/^size_t quicklistGetLzf(const quicklistNode *node, void **data);$/;"	p	language:C	signature:(const quicklistNode *node, void **data)
quicklistIndex	quicklist.c	/^int quicklistIndex(const quicklist *quicklist, const long long idx,$/;"	f	language:C	signature:(const quicklist *quicklist, const long long idx, quicklistEntry *entry)
quicklistIndex	quicklist.h	/^int quicklistIndex(const quicklist *quicklist, const long long index,$/;"	p	language:C	signature:(const quicklist *quicklist, const long long index, quicklistEntry *entry)
quicklistInsertAfter	quicklist.c	/^void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistEntry *entry, void *value, const size_t sz)
quicklistInsertAfter	quicklist.h	/^void quicklistInsertAfter(quicklist *quicklist, quicklistEntry *node,$/;"	p	language:C	signature:(quicklist *quicklist, quicklistEntry *node, void *value, const size_t sz)
quicklistInsertBefore	quicklist.c	/^void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *entry,$/;"	f	language:C	signature:(quicklist *quicklist, quicklistEntry *entry, void *value, const size_t sz)
quicklistInsertBefore	quicklist.h	/^void quicklistInsertBefore(quicklist *quicklist, quicklistEntry *node,$/;"	p	language:C	signature:(quicklist *quicklist, quicklistEntry *node, void *value, const size_t sz)
quicklistIter	quicklist.h	/^typedef struct quicklistIter {$/;"	s	language:C
quicklistIter	quicklist.h	/^} quicklistIter;$/;"	t	language:C	typeref:struct:quicklistIter
quicklistIter::current	quicklist.h	/^    quicklistNode *current;$/;"	m	language:C	struct:quicklistIter	access:public
quicklistIter::direction	quicklist.h	/^    int direction;$/;"	m	language:C	struct:quicklistIter	access:public
quicklistIter::offset	quicklist.h	/^    long offset; \/* offset in current ziplist *\/$/;"	m	language:C	struct:quicklistIter	access:public
quicklistIter::quicklist	quicklist.h	/^    const quicklist *quicklist;$/;"	m	language:C	struct:quicklistIter	access:public
quicklistIter::zi	quicklist.h	/^    unsigned char *zi;$/;"	m	language:C	struct:quicklistIter	access:public
quicklistLZF	quicklist.h	/^typedef struct quicklistLZF {$/;"	s	language:C
quicklistLZF	quicklist.h	/^} quicklistLZF;$/;"	t	language:C	typeref:struct:quicklistLZF
quicklistLZF::compressed	quicklist.h	/^    char compressed[];$/;"	m	language:C	struct:quicklistLZF	access:public
quicklistLZF::sz	quicklist.h	/^    unsigned int sz; \/* LZF size in bytes*\/$/;"	m	language:C	struct:quicklistLZF	access:public
quicklistNew	quicklist.c	/^quicklist *quicklistNew(int fill, int compress) {$/;"	f	language:C	signature:(int fill, int compress)
quicklistNew	quicklist.h	/^quicklist *quicklistNew(int fill, int compress);$/;"	p	language:C	signature:(int fill, int compress)
quicklistNext	quicklist.c	/^int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {$/;"	f	language:C	signature:(quicklistIter *iter, quicklistEntry *entry)
quicklistNext	quicklist.h	/^int quicklistNext(quicklistIter *iter, quicklistEntry *node);$/;"	p	language:C	signature:(quicklistIter *iter, quicklistEntry *node)
quicklistNode	quicklist.h	/^typedef struct quicklistNode {$/;"	s	language:C
quicklistNode	quicklist.h	/^} quicklistNode;$/;"	t	language:C	typeref:struct:quicklistNode
quicklistNode::attempted_compress	quicklist.h	/^    unsigned int attempted_compress : 1; \/* node can't compress; too small *\/$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNode::container	quicklist.h	/^    unsigned int container : 2;  \/* NONE==1 or ZIPLIST==2 *\/$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNode::count	quicklist.h	/^    unsigned int count : 16;     \/* count of items in ziplist *\/$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNode::encoding	quicklist.h	/^    unsigned int encoding : 2;   \/* RAW==1 or LZF==2 *\/$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNode::extra	quicklist.h	/^    unsigned int extra : 10; \/* more bits to steal for future usage *\/$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNode::next	quicklist.h	/^    struct quicklistNode *next;$/;"	m	language:C	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode	access:public
quicklistNode::prev	quicklist.h	/^    struct quicklistNode *prev;$/;"	m	language:C	struct:quicklistNode	typeref:struct:quicklistNode::quicklistNode	access:public
quicklistNode::recompress	quicklist.h	/^    unsigned int recompress : 1; \/* was this node previous compressed? *\/$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNode::sz	quicklist.h	/^    unsigned int sz;             \/* ziplist size in bytes *\/$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNode::zl	quicklist.h	/^    unsigned char *zl;$/;"	m	language:C	struct:quicklistNode	access:public
quicklistNodeIsCompressed	quicklist.h	/^#define quicklistNodeIsCompressed(/;"	d	language:C
quicklistNodeUpdateSz	quicklist.c	/^#define quicklistNodeUpdateSz(/;"	d	language:C	file:
quicklistPop	quicklist.c	/^int quicklistPop(quicklist *quicklist, int where, unsigned char **data,$/;"	f	language:C	signature:(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *slong)
quicklistPop	quicklist.h	/^int quicklistPop(quicklist *quicklist, int where, unsigned char **data,$/;"	p	language:C	signature:(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *slong)
quicklistPopCustom	quicklist.c	/^int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,$/;"	f	language:C	signature:(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *sval, void *(*saver)(unsigned char *data, unsigned int sz))
quicklistPopCustom	quicklist.h	/^int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,$/;"	p	language:C	signature:(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *sval, void *(*saver)(unsigned char *data, unsigned int sz))
quicklistPush	quicklist.c	/^void quicklistPush(quicklist *quicklist, void *value, const size_t sz,$/;"	f	language:C	signature:(quicklist *quicklist, void *value, const size_t sz, int where)
quicklistPush	quicklist.h	/^void quicklistPush(quicklist *quicklist, void *value, const size_t sz,$/;"	p	language:C	signature:(quicklist *quicklist, void *value, const size_t sz, int where)
quicklistPushHead	quicklist.c	/^int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {$/;"	f	language:C	signature:(quicklist *quicklist, void *value, size_t sz)
quicklistPushHead	quicklist.h	/^int quicklistPushHead(quicklist *quicklist, void *value, const size_t sz);$/;"	p	language:C	signature:(quicklist *quicklist, void *value, const size_t sz)
quicklistPushTail	quicklist.c	/^int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {$/;"	f	language:C	signature:(quicklist *quicklist, void *value, size_t sz)
quicklistPushTail	quicklist.h	/^int quicklistPushTail(quicklist *quicklist, void *value, const size_t sz);$/;"	p	language:C	signature:(quicklist *quicklist, void *value, const size_t sz)
quicklistRecompressOnly	quicklist.c	/^#define quicklistRecompressOnly(/;"	d	language:C	file:
quicklistRelease	quicklist.c	/^void quicklistRelease(quicklist *quicklist) {$/;"	f	language:C	signature:(quicklist *quicklist)
quicklistRelease	quicklist.h	/^void quicklistRelease(quicklist *quicklist);$/;"	p	language:C	signature:(quicklist *quicklist)
quicklistReleaseIterator	quicklist.c	/^void quicklistReleaseIterator(quicklistIter *iter) {$/;"	f	language:C	signature:(quicklistIter *iter)
quicklistReleaseIterator	quicklist.h	/^void quicklistReleaseIterator(quicklistIter *iter);$/;"	p	language:C	signature:(quicklistIter *iter)
quicklistReplaceAtIndex	quicklist.c	/^int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,$/;"	f	language:C	signature:(quicklist *quicklist, long index, void *data, int sz)
quicklistReplaceAtIndex	quicklist.h	/^int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,$/;"	p	language:C	signature:(quicklist *quicklist, long index, void *data, int sz)
quicklistRewind	quicklist.h	/^void quicklistRewind(quicklist *quicklist, quicklistIter *li);$/;"	p	language:C	signature:(quicklist *quicklist, quicklistIter *li)
quicklistRewindTail	quicklist.h	/^void quicklistRewindTail(quicklist *quicklist, quicklistIter *li);$/;"	p	language:C	signature:(quicklist *quicklist, quicklistIter *li)
quicklistRotate	quicklist.c	/^void quicklistRotate(quicklist *quicklist) {$/;"	f	language:C	signature:(quicklist *quicklist)
quicklistRotate	quicklist.h	/^void quicklistRotate(quicklist *quicklist);$/;"	p	language:C	signature:(quicklist *quicklist)
quicklistSetCompressDepth	quicklist.c	/^void quicklistSetCompressDepth(quicklist *quicklist, int compress) {$/;"	f	language:C	signature:(quicklist *quicklist, int compress)
quicklistSetCompressDepth	quicklist.h	/^void quicklistSetCompressDepth(quicklist *quicklist, int depth);$/;"	p	language:C	signature:(quicklist *quicklist, int depth)
quicklistSetFill	quicklist.c	/^void quicklistSetFill(quicklist *quicklist, int fill) {$/;"	f	language:C	signature:(quicklist *quicklist, int fill)
quicklistSetFill	quicklist.h	/^void quicklistSetFill(quicklist *quicklist, int fill);$/;"	p	language:C	signature:(quicklist *quicklist, int fill)
quicklistSetOptions	quicklist.c	/^void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {$/;"	f	language:C	signature:(quicklist *quicklist, int fill, int depth)
quicklistSetOptions	quicklist.h	/^void quicklistSetOptions(quicklist *quicklist, int fill, int depth);$/;"	p	language:C	signature:(quicklist *quicklist, int fill, int depth)
quicklistTest	quicklist.c	/^int quicklistTest(int argc, char *argv[]) {$/;"	f	language:C	signature:(int argc, char *argv[])
quicklistTest	quicklist.h	/^int quicklistTest(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
quiet	redis-benchmark.c	/^    int quiet;$/;"	m	language:C	struct:config	file:	access:public
quorum	sentinel.c	/^        int quorum = atoi(argv[4]);$/;"	l	language:C
quorum	sentinel.c	/^        long quorum, port;$/;"	l	language:C
quorum	sentinel.c	/^    unsigned int quorum = 0, odown = 0;$/;"	l	language:C
quorum	sentinel.c	/^    unsigned int quorum;\/* Number of sentinels that need to agree on failure. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
r	dict.c	/^    const int r = 24;$/;"	l	language:C
r	evict.c	/^    double r = (double)rand()\/RAND_MAX;$/;"	l	language:C
r	geo.c	/^            GeoHashRange r[2];$/;"	l	language:C
r	geohash.c	/^    GeoHashRange r[2] = {{0}};$/;"	l	language:C
r	hyperloglog.c	/^            unsigned int r = rand() & HLL_REGISTER_MAX;$/;"	l	language:C
r	hyperloglog.c	/^        uint8_t *r = registers;$/;"	l	language:C
r	hyperloglog.c	/^    const int r = 47;$/;"	l	language:C
r	pqsort.c	/^	size_t d, r;$/;"	l	language:C
r	rand.c	/^    uint32_t p[2], q[2], r[2], carry0, carry1;$/;"	l	language:C
r	redis-benchmark.c	/^                    redisReply *r = reply;$/;"	l	language:C
r	redis-benchmark.c	/^        size_t r = random() % config.randomkeys_keyspacelen;$/;"	l	language:C
r	redis-cli.c	/^    double pl, r;$/;"	l	language:C
r	redis-trib.rb	/^        @r = nil$/;"	v	language:C
r	scripting.c	/^  lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) \/$/;"	l	language:C
r	sentinel.c	/^    redisReply *r;$/;"	l	language:C
r0	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r1	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r10	hyperloglog.c	/^                      r10, r11, r12, r13, r14, r15;$/;"	l	language:C
r11	hyperloglog.c	/^                      r10, r11, r12, r13, r14, r15;$/;"	l	language:C
r12	hyperloglog.c	/^                      r10, r11, r12, r13, r14, r15;$/;"	l	language:C
r13	hyperloglog.c	/^                      r10, r11, r12, r13, r14, r15;$/;"	l	language:C
r14	hyperloglog.c	/^                      r10, r11, r12, r13, r14, r15;$/;"	l	language:C
r15	hyperloglog.c	/^                      r10, r11, r12, r13, r14, r15;$/;"	l	language:C
r2	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r3	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r4	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r5	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r6	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r7	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r8	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
r9	hyperloglog.c	/^        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,$/;"	l	language:C
rad_deg	geohash_helper.c	/^static inline double rad_deg(double ang) { return ang \/ D_R; }$/;"	f	language:C	file:	signature:(double ang)
radius	geohash_helper.c	/^    GeoHashRadius radius;$/;"	l	language:C
radius_meters	geo.c	/^    double radius_meters = 0, conversion = 1;$/;"	l	language:C
rand	scripting.c	/^        redisSrand48(rand());$/;"	p	language:C	file:
randfree	redis-benchmark.c	/^    size_t randfree;        \/* Number of unused pointers in client->randptr *\/$/;"	m	language:C	struct:_client	file:	access:public
randlen	redis-benchmark.c	/^    size_t randlen;         \/* Number of pointers in client->randptr *\/$/;"	m	language:C	struct:_client	file:	access:public
randomizeClientKey	redis-benchmark.c	/^static void randomizeClientKey(client c) {$/;"	f	language:C	file:	signature:(client c)
randomkeyCommand	db.c	/^void randomkeyCommand(client *c) {$/;"	f	language:C	signature:(client *c)
randomkeyCommand	server.h	/^void randomkeyCommand(client *c);$/;"	p	language:C	signature:(client *c)
randomkeys	redis-benchmark.c	/^    int randomkeys;$/;"	m	language:C	struct:config	file:	access:public
randomkeys_keyspacelen	redis-benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	language:C	struct:config	file:	access:public
randptr	redis-benchmark.c	/^    char **randptr;         \/* Pointers to :rand: strings inside the command buf *\/$/;"	m	language:C	struct:_client	file:	access:public
randstring	ziplist.c	/^static int randstring(char *target, unsigned int min, unsigned int max) {$/;"	f	language:C	file:	signature:(char *target, unsigned int min, unsigned int max)
range	db.c	/^    zrangespec range;$/;"	l	language:C
range	geo.c	/^    zrangespec range = { .min = min, .max = max, .minex = 0, .maxex = 1 };$/;"	l	language:C
range	t_zset.c	/^    zlexrangespec range;$/;"	l	language:C
range	t_zset.c	/^    zrangespec range;$/;"	l	language:C
rangelen	sort.c	/^        int rangelen = vectorlen;$/;"	l	language:C
rangelen	t_list.c	/^    long start, end, llen, rangelen;$/;"	l	language:C
rangelen	t_zset.c	/^    int rangelen;$/;"	l	language:C
rangelen	t_zset.c	/^    unsigned long rangelen = 0;$/;"	l	language:C
rank	cluster.c	/^    int j, rank = 0;$/;"	l	language:C
rank	db.c	/^    int rank, count = 0;$/;"	l	language:C
rank	t_zset.c	/^        unsigned long rank;$/;"	l	language:C
rank	t_zset.c	/^    long rank;$/;"	l	language:C
rank	t_zset.c	/^    unsigned int rank[ZSKIPLIST_MAXLEVEL];$/;"	l	language:C
rank	t_zset.c	/^    unsigned long rank = 0;$/;"	l	language:C
rank	t_zset.c	/^    unsigned long rank;$/;"	l	language:C
rawlen	ziplist.c	/^    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;$/;"	l	language:C
rawlensize	ziplist.c	/^    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;$/;"	l	language:C
rawmode	server.c	/^    int rawmode = (level & LL_RAW);$/;"	l	language:C
rcfile	redis-cli.c	/^    sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);$/;"	l	language:C
rcvbuf	cluster.h	/^    sds rcvbuf;                 \/* Packet reception buffer *\/$/;"	m	language:C	struct:clusterLink	access:public
rcvbuflen	cluster.c	/^    unsigned int readlen, rcvbuflen;$/;"	l	language:C
rdb	rdb.c	/^    rio rdb;$/;"	l	language:C
rdb	redis-check-rdb.c	/^    static rio rdb; \/* Pointed by global struct riostate. *\/$/;"	l	language:C	file:
rdbCheckError	rdb.c	/^void rdbCheckError(const char *fmt, ...);$/;"	p	language:C	file:	signature:(const char *fmt, ...)
rdbCheckError	redis-check-rdb.c	/^void rdbCheckError(const char *fmt, ...) {$/;"	f	language:C	signature:(const char *fmt, ...)
rdbCheckHandleCrash	redis-check-rdb.c	/^void rdbCheckHandleCrash(int sig, siginfo_t *info, void *secret) {$/;"	f	language:C	signature:(int sig, siginfo_t *info, void *secret)
rdbCheckInfo	redis-check-rdb.c	/^void rdbCheckInfo(const char *fmt, ...) {$/;"	f	language:C	signature:(const char *fmt, ...)
rdbCheckMode	rdb.c	/^extern int rdbCheckMode;$/;"	x	language:C
rdbCheckMode	redis-check-rdb.c	/^int rdbCheckMode = 0;$/;"	v	language:C
rdbCheckSetError	rdb.c	/^void rdbCheckSetError(const char *fmt, ...);$/;"	p	language:C	file:	signature:(const char *fmt, ...)
rdbCheckSetError	redis-check-rdb.c	/^void rdbCheckSetError(const char *fmt, ...) {$/;"	f	language:C	signature:(const char *fmt, ...)
rdbCheckSetupSignals	redis-check-rdb.c	/^void rdbCheckSetupSignals(void) {$/;"	f	language:C	signature:(void)
rdbCheckThenExit	rdb.c	/^void rdbCheckThenExit(int linenum, char *reason, ...) {$/;"	f	language:C	signature:(int linenum, char *reason, ...)
rdbEncodeInteger	rdb.c	/^int rdbEncodeInteger(long long value, unsigned char *enc) {$/;"	f	language:C	signature:(long long value, unsigned char *enc)
rdbExitReportCorruptRDB	rdb.c	/^#define rdbExitReportCorruptRDB(/;"	d	language:C	file:
rdbGenericLoadStringObject	rdb.c	/^void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {$/;"	f	language:C	signature:(rio *rdb, int flags, size_t *lenptr)
rdbGenericLoadStringObject	rdb.h	/^void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr);$/;"	p	language:C	signature:(rio *rdb, int flags, size_t *lenptr)
rdbIsObjectType	rdb.h	/^#define rdbIsObjectType(/;"	d	language:C
rdbLoad	rdb.c	/^int rdbLoad(char *filename) {$/;"	f	language:C	signature:(char *filename)
rdbLoad	rdb.h	/^int rdbLoad(char *filename);$/;"	p	language:C	signature:(char *filename)
rdbLoadBinaryDoubleValue	rdb.c	/^int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {$/;"	f	language:C	signature:(rio *rdb, double *val)
rdbLoadBinaryDoubleValue	rdb.h	/^int rdbLoadBinaryDoubleValue(rio *rdb, double *val);$/;"	p	language:C	signature:(rio *rdb, double *val)
rdbLoadDoubleValue	rdb.c	/^int rdbLoadDoubleValue(rio *rdb, double *val) {$/;"	f	language:C	signature:(rio *rdb, double *val)
rdbLoadEncodedStringObject	rdb.c	/^robj *rdbLoadEncodedStringObject(rio *rdb) {$/;"	f	language:C	signature:(rio *rdb)
rdbLoadIntegerObject	rdb.c	/^void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {$/;"	f	language:C	signature:(rio *rdb, int enctype, int flags, size_t *lenptr)
rdbLoadLen	rdb.c	/^uint64_t rdbLoadLen(rio *rdb, int *isencoded) {$/;"	f	language:C	signature:(rio *rdb, int *isencoded)
rdbLoadLen	rdb.h	/^uint64_t rdbLoadLen(rio *rdb, int *isencoded);$/;"	p	language:C	signature:(rio *rdb, int *isencoded)
rdbLoadLenByRef	rdb.c	/^int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {$/;"	f	language:C	signature:(rio *rdb, int *isencoded, uint64_t *lenptr)
rdbLoadLenByRef	rdb.h	/^int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr);$/;"	p	language:C	signature:(rio *rdb, int *isencoded, uint64_t *lenptr)
rdbLoadLzfStringObject	rdb.c	/^void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {$/;"	f	language:C	signature:(rio *rdb, int flags, size_t *lenptr)
rdbLoadMillisecondTime	rdb.c	/^long long rdbLoadMillisecondTime(rio *rdb) {$/;"	f	language:C	signature:(rio *rdb)
rdbLoadMillisecondTime	redis-check-rdb.c	/^long long rdbLoadMillisecondTime(rio *rdb);$/;"	p	language:C	file:	signature:(rio *rdb)
rdbLoadObject	rdb.c	/^robj *rdbLoadObject(int rdbtype, rio *rdb) {$/;"	f	language:C	signature:(int rdbtype, rio *rdb)
rdbLoadObject	rdb.h	/^robj *rdbLoadObject(int type, rio *rdb);$/;"	p	language:C	signature:(int type, rio *rdb)
rdbLoadObjectType	rdb.c	/^int rdbLoadObjectType(rio *rdb) {$/;"	f	language:C	signature:(rio *rdb)
rdbLoadObjectType	rdb.h	/^int rdbLoadObjectType(rio *rdb);$/;"	p	language:C	signature:(rio *rdb)
rdbLoadProgressCallback	rdb.c	/^void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {$/;"	f	language:C	signature:(rio *r, const void *buf, size_t len)
rdbLoadProgressCallback	redis-check-rdb.c	/^void rdbLoadProgressCallback(rio *r, const void *buf, size_t len);$/;"	p	language:C	file:	signature:(rio *r, const void *buf, size_t len)
rdbLoadStringObject	rdb.c	/^robj *rdbLoadStringObject(rio *rdb) {$/;"	f	language:C	signature:(rio *rdb)
rdbLoadStringObject	rdb.h	/^robj *rdbLoadStringObject(rio *rdb);$/;"	p	language:C	signature:(rio *rdb)
rdbLoadTime	rdb.c	/^time_t rdbLoadTime(rio *rdb) {$/;"	f	language:C	signature:(rio *rdb)
rdbLoadTime	rdb.h	/^time_t rdbLoadTime(rio *rdb);$/;"	p	language:C	signature:(rio *rdb)
rdbLoadType	rdb.c	/^int rdbLoadType(rio *rdb) {$/;"	f	language:C	signature:(rio *rdb)
rdbLoadType	rdb.h	/^int rdbLoadType(rio *rdb);$/;"	p	language:C	signature:(rio *rdb)
rdbRemoveTempFile	rdb.c	/^void rdbRemoveTempFile(pid_t childpid) {$/;"	f	language:C	signature:(pid_t childpid)
rdbRemoveTempFile	rdb.h	/^void rdbRemoveTempFile(pid_t childpid);$/;"	p	language:C	signature:(pid_t childpid)
rdbSave	rdb.c	/^int rdbSave(char *filename) {$/;"	f	language:C	signature:(char *filename)
rdbSave	rdb.h	/^int rdbSave(char *filename);$/;"	p	language:C	signature:(char *filename)
rdbSaveAuxField	rdb.c	/^int rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {$/;"	f	language:C	signature:(rio *rdb, void *key, size_t keylen, void *val, size_t vallen)
rdbSaveAuxFieldStrInt	rdb.c	/^int rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {$/;"	f	language:C	signature:(rio *rdb, char *key, long long val)
rdbSaveAuxFieldStrStr	rdb.c	/^int rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {$/;"	f	language:C	signature:(rio *rdb, char *key, char *val)
rdbSaveBackground	rdb.c	/^int rdbSaveBackground(char *filename) {$/;"	f	language:C	signature:(char *filename)
rdbSaveBackground	rdb.h	/^int rdbSaveBackground(char *filename);$/;"	p	language:C	signature:(char *filename)
rdbSaveBinaryDoubleValue	rdb.c	/^int rdbSaveBinaryDoubleValue(rio *rdb, double val) {$/;"	f	language:C	signature:(rio *rdb, double val)
rdbSaveBinaryDoubleValue	rdb.h	/^int rdbSaveBinaryDoubleValue(rio *rdb, double val);$/;"	p	language:C	signature:(rio *rdb, double val)
rdbSaveDoubleValue	rdb.c	/^int rdbSaveDoubleValue(rio *rdb, double val) {$/;"	f	language:C	signature:(rio *rdb, double val)
rdbSaveInfoAuxFields	rdb.c	/^int rdbSaveInfoAuxFields(rio *rdb) {$/;"	f	language:C	signature:(rio *rdb)
rdbSaveKeyValuePair	rdb.c	/^int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val,$/;"	f	language:C	signature:(rio *rdb, robj *key, robj *val, long long expiretime, long long now)
rdbSaveKeyValuePair	rdb.h	/^int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, long long now);$/;"	p	language:C	signature:(rio *rdb, robj *key, robj *val, long long expiretime, long long now)
rdbSaveLen	rdb.c	/^int rdbSaveLen(rio *rdb, uint64_t len) {$/;"	f	language:C	signature:(rio *rdb, uint64_t len)
rdbSaveLen	rdb.h	/^int rdbSaveLen(rio *rdb, uint64_t len);$/;"	p	language:C	signature:(rio *rdb, uint64_t len)
rdbSaveLongLongAsStringObject	rdb.c	/^ssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {$/;"	f	language:C	signature:(rio *rdb, long long value)
rdbSaveLzfBlob	rdb.c	/^ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,$/;"	f	language:C	signature:(rio *rdb, void *data, size_t compress_len, size_t original_len)
rdbSaveLzfStringObject	rdb.c	/^ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {$/;"	f	language:C	signature:(rio *rdb, unsigned char *s, size_t len)
rdbSaveMillisecondTime	rdb.c	/^int rdbSaveMillisecondTime(rio *rdb, long long t) {$/;"	f	language:C	signature:(rio *rdb, long long t)
rdbSaveObject	cluster.c	/^    serverAssert(rdbSaveObject(payload,o));$/;"	p	language:C	file:
rdbSaveObject	rdb.c	/^ssize_t rdbSaveObject(rio *rdb, robj *o) {$/;"	f	language:C	signature:(rio *rdb, robj *o)
rdbSaveObject	rdb.h	/^ssize_t rdbSaveObject(rio *rdb, robj *o);$/;"	p	language:C	signature:(rio *rdb, robj *o)
rdbSaveObjectType	cluster.c	/^    serverAssert(rdbSaveObjectType(payload,o));$/;"	p	language:C	file:
rdbSaveObjectType	rdb.c	/^int rdbSaveObjectType(rio *rdb, robj *o) {$/;"	f	language:C	signature:(rio *rdb, robj *o)
rdbSaveObjectType	rdb.h	/^int rdbSaveObjectType(rio *rdb, robj *o);$/;"	p	language:C	signature:(rio *rdb, robj *o)
rdbSaveRawString	rdb.c	/^ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {$/;"	f	language:C	signature:(rio *rdb, unsigned char *s, size_t len)
rdbSaveRawString	rdb.h	/^ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len);$/;"	p	language:C	signature:(rio *rdb, unsigned char *s, size_t len)
rdbSaveRio	rdb.c	/^int rdbSaveRio(rio *rdb, int *error) {$/;"	f	language:C	signature:(rio *rdb, int *error)
rdbSaveRioWithEOFMark	rdb.c	/^int rdbSaveRioWithEOFMark(rio *rdb, int *error) {$/;"	f	language:C	signature:(rio *rdb, int *error)
rdbSaveStringObject	rdb.c	/^int rdbSaveStringObject(rio *rdb, robj *obj) {$/;"	f	language:C	signature:(rio *rdb, robj *obj)
rdbSaveStringObject	rdb.h	/^int rdbSaveStringObject(rio *rdb, robj *obj);$/;"	p	language:C	signature:(rio *rdb, robj *obj)
rdbSaveTime	rdb.h	/^int rdbSaveTime(rio *rdb, time_t t);$/;"	p	language:C	signature:(rio *rdb, time_t t)
rdbSaveToSlavesSockets	rdb.c	/^int rdbSaveToSlavesSockets(void) {$/;"	f	language:C	signature:(void)
rdbSaveToSlavesSockets	rdb.h	/^int rdbSaveToSlavesSockets(void);$/;"	p	language:C	signature:(void)
rdbSaveType	rdb.c	/^int rdbSaveType(rio *rdb, unsigned char type) {$/;"	f	language:C	signature:(rio *rdb, unsigned char type)
rdbSaveType	rdb.h	/^int rdbSaveType(rio *rdb, unsigned char type);$/;"	p	language:C	signature:(rio *rdb, unsigned char type)
rdbSavedObjectLen	rdb.c	/^size_t rdbSavedObjectLen(robj *o) {$/;"	f	language:C	signature:(robj *o)
rdbSavedObjectLen	rdb.h	/^size_t rdbSavedObjectLen(robj *o);$/;"	p	language:C	signature:(robj *o)
rdbShowGenericInfo	redis-check-rdb.c	/^void rdbShowGenericInfo(void) {$/;"	f	language:C	signature:(void)
rdbTryIntegerEncoding	rdb.c	/^int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {$/;"	f	language:C	signature:(char *s, size_t len, unsigned char *enc)
rdbWriteRaw	rdb.c	/^static int rdbWriteRaw(rio *rdb, void *p, size_t len) {$/;"	f	language:C	file:	signature:(rio *rdb, void *p, size_t len)
rdb_bgsave_scheduled	server.h	/^    int rdb_bgsave_scheduled;       \/* BGSAVE when possible if true. *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_check_doing_string	redis-check-rdb.c	/^char *rdb_check_doing_string[] = {$/;"	v	language:C
rdb_checksum	server.h	/^    int rdb_checksum;               \/* Use RDB checksum? *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_child_pid	server.h	/^    pid_t rdb_child_pid;            \/* PID of RDB saving child *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_child_type	server.h	/^    int rdb_child_type;             \/* Type of save by active child. *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_compression	server.h	/^    int rdb_compression;            \/* Use compression in RDB? *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_filename	redis-cli.c	/^    char *rdb_filename;$/;"	m	language:C	struct:config	file:	access:public
rdb_filename	server.h	/^    char *rdb_filename;             \/* Name of RDB file *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_fsync_range	config.h	/^#define rdb_fsync_range(/;"	d	language:C
rdb_load	server.h	/^    moduleTypeLoadFunc rdb_load;$/;"	m	language:C	struct:RedisModuleType	access:public
rdb_pipe_read_result_from_child	server.h	/^    int rdb_pipe_read_result_from_child; \/* of each slave in diskless SYNC. *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_pipe_write_result_to_parent	server.h	/^    int rdb_pipe_write_result_to_parent; \/* RDB pipes used to return the state *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_save	modules/TYPES.md	/^The remaining arguments `rdb_load`, `rdb_save`, `aof_rewrite`, `digest` and$/;"	v	language:C
rdb_save	server.h	/^    moduleTypeSaveFunc rdb_save;$/;"	m	language:C	struct:RedisModuleType	access:public
rdb_save_time_last	server.h	/^    time_t rdb_save_time_last;      \/* Time used by last RDB save run. *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_save_time_start	server.h	/^    time_t rdb_save_time_start;     \/* Current RDB save start time. *\/$/;"	m	language:C	struct:redisServer	access:public
rdb_type_string	redis-check-rdb.c	/^char *rdb_type_string[] = {$/;"	v	language:C
rdbstate	redis-check-rdb.c	/^} rdbstate;$/;"	v	language:C	typeref:struct:__anon23
rdbver	cluster.c	/^    uint16_t rdbver;$/;"	l	language:C
rdbver	rdb.c	/^    int type, rdbver;$/;"	l	language:C
rdbver	redis-check-rdb.c	/^    int type, rdbver;$/;"	l	language:C
reachable_masters	cluster.c	/^    int reachable_masters = 0;$/;"	l	language:C
read	rio.h	/^    size_t (*read)(struct _rio *, void *buf, size_t len);$/;"	m	language:C	struct:_rio	access:public
readArgFromStdin	redis-cli.c	/^static sds readArgFromStdin(void) {$/;"	f	language:C	file:	signature:(void)
readArgc	redis-check-aof.c	/^int readArgc(FILE *fp, long *target) {$/;"	f	language:C	signature:(FILE *fp, long *target)
readBytes	redis-check-aof.c	/^int readBytes(FILE *fp, char *target, long length) {$/;"	f	language:C	signature:(FILE *fp, char *target, long length)
readHandler	redis-benchmark.c	/^static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
readLong	redis-check-aof.c	/^int readLong(FILE *fp, char prefix, long *target) {$/;"	f	language:C	signature:(FILE *fp, char prefix, long *target)
readQueryFromClient	networking.c	/^void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
readQueryFromClient	server.h	/^void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
readString	redis-check-aof.c	/^int readString(FILE *fp, char** target) {$/;"	f	language:C	signature:(FILE *fp, char** target)
readSyncBulkPayload	replication.c	/^void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
reader	redis-cli.c	/^    redisReader *reader = redisReaderCreate();$/;"	l	language:C
reading	sentinel.c	/^    int reading, writing;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
readlen	cluster.c	/^    unsigned int readlen, rcvbuflen;$/;"	l	language:C
readlen	networking.c	/^    int nread, readlen;$/;"	l	language:C
readlen	rdb.c	/^        int readlen = sizeof(uint64_t);$/;"	l	language:C
readlen	replication.c	/^    ssize_t nread, readlen;$/;"	l	language:C
readonly	bitops.c	/^    int readonly = 1;$/;"	l	language:C
readonlyCommand	cluster.c	/^void readonlyCommand(client *c) {$/;"	f	language:C	signature:(client *c)
readonlyCommand	server.h	/^void readonlyCommand(client *c);$/;"	p	language:C	signature:(client *c)
readwriteCommand	cluster.c	/^void readwriteCommand(client *c) {$/;"	f	language:C	signature:(client *c)
readwriteCommand	server.h	/^void readwriteCommand(client *c);$/;"	p	language:C	signature:(client *c)
readyList	server.h	/^typedef struct readyList {$/;"	s	language:C
readyList	server.h	/^} readyList;$/;"	t	language:C	typeref:struct:readyList
readyList::db	server.h	/^    redisDb *db;$/;"	m	language:C	struct:readyList	access:public
readyList::key	server.h	/^    robj *key;$/;"	m	language:C	struct:readyList	access:public
ready_keys	server.h	/^    dict *ready_keys;           \/* Blocked keys that received a PUSH *\/$/;"	m	language:C	struct:redisDb	access:public
ready_keys	server.h	/^    list *ready_keys;        \/* List of readyList structures for BLPOP & co *\/$/;"	m	language:C	struct:redisServer	access:public
real	redis-check-aof.c	/^    long real;$/;"	l	language:C
reallen	sds.c	/^    int reallen = strlen(s);$/;"	l	language:C
realloc	modules/TYPES.md	/^    #define realloc /;"	d	language:C	file:
realloc	server.h	/^void *realloc(void *ptr, size_t size) __attribute__ ((deprecated));$/;"	p	language:C	signature:(void *ptr, size_t size)
realloc	zmalloc.c	/^#define realloc(/;"	d	language:C	file:
realptr	zmalloc.c	/^    void *realptr = (char*)ptr-PREFIX_SIZE;$/;"	l	language:C
realptr	zmalloc.c	/^    void *realptr;$/;"	l	language:C
realsize	dict.c	/^    unsigned long realsize = _dictNextPower(size);$/;"	l	language:C
reason	scripting.c	/^            ldb.currentline, reason));$/;"	l	language:C
reason	scripting.c	/^        char *reason = "step over";$/;"	l	language:C
receiver	t_list.c	/^                        client *receiver = clientnode->value;$/;"	l	language:C
receivers	pubsub.c	/^    int receivers = 0;$/;"	l	language:C
receivers	pubsub.c	/^    int receivers = pubsubPublishMessage(c->argv[1],c->argv[2]);$/;"	l	language:C
reclaiming	modules/TYPES.md	/^complex memory reclaiming, by casting the void pointer to some structure$/;"	v	language:C
recognized	modules/INTRO.md	/^characters that are not recognized, or when the command is called with the$/;"	v	language:C
recompiled	modules/INTRO.md	/^so a given module does not need to be designed, or recompiled, in order to$/;"	v	language:C
recompress	quicklist.h	/^    unsigned int recompress : 1; \/* was this node previous compressed? *\/$/;"	m	language:C	struct:quicklistNode	access:public
reconfigured	sentinel.c	/^    int reconfigured = 0;$/;"	l	language:C
reconnectingRedisCommand	redis-cli.c	/^static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {$/;"	f	language:C	file:	signature:(redisContext *c, const char *fmt, ...)
recursion_warning	scripting.c	/^        char *recursion_warning =$/;"	l	language:C
redisAeAddRead	sentinel.c	/^static void redisAeAddRead(void *privdata) {$/;"	f	language:C	file:	signature:(void *privdata)
redisAeAddWrite	sentinel.c	/^static void redisAeAddWrite(void *privdata) {$/;"	f	language:C	file:	signature:(void *privdata)
redisAeAttach	sentinel.c	/^static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {$/;"	f	language:C	file:	signature:(aeEventLoop *loop, redisAsyncContext *ac)
redisAeCleanup	sentinel.c	/^static void redisAeCleanup(void *privdata) {$/;"	f	language:C	file:	signature:(void *privdata)
redisAeDelRead	sentinel.c	/^static void redisAeDelRead(void *privdata) {$/;"	f	language:C	file:	signature:(void *privdata)
redisAeDelWrite	sentinel.c	/^static void redisAeDelWrite(void *privdata) {$/;"	f	language:C	file:	signature:(void *privdata)
redisAeEvents	sentinel.c	/^typedef struct redisAeEvents {$/;"	s	language:C	file:
redisAeEvents	sentinel.c	/^} redisAeEvents;$/;"	t	language:C	typeref:struct:redisAeEvents	file:
redisAeEvents::context	sentinel.c	/^    redisAsyncContext *context;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
redisAeEvents::fd	sentinel.c	/^    int fd;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
redisAeEvents::loop	sentinel.c	/^    aeEventLoop *loop;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
redisAeEvents::reading	sentinel.c	/^    int reading, writing;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
redisAeEvents::writing	sentinel.c	/^    int reading, writing;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
redisAeReadEvent	sentinel.c	/^static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
redisAeWriteEvent	sentinel.c	/^static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
redisAsciiArt	server.c	/^void redisAsciiArt(void) {$/;"	f	language:C	signature:(void)
redisBitpos	bitops.c	/^long redisBitpos(void *s, unsigned long count, int bit) {$/;"	f	language:C	signature:(void *s, unsigned long count, int bit)
redisBuildId	release.c	/^uint64_t redisBuildId(void) {$/;"	f	language:C	signature:(void)
redisBuildId	server.h	/^uint64_t redisBuildId(void);$/;"	p	language:C	signature:(void)
redisCommand	server.h	/^struct redisCommand {$/;"	s	language:C
redisCommand::arity	server.h	/^    int arity;$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::calls	server.h	/^    long long microseconds, calls;$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::firstkey	server.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::flags	server.h	/^    int flags;    \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::getkeys_proc	server.h	/^    redisGetKeysProc *getkeys_proc;$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::keystep	server.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::lastkey	server.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::microseconds	server.h	/^    long long microseconds, calls;$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::name	server.h	/^    char *name;$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::proc	server.h	/^    redisCommandProc *proc;$/;"	m	language:C	struct:redisCommand	access:public
redisCommand::sflags	server.h	/^    char *sflags; \/* Flags as string representation, one char per flag. *\/$/;"	m	language:C	struct:redisCommand	access:public
redisCommandProc	server.h	/^typedef void redisCommandProc(client *c);$/;"	t	language:C
redisCommandTable	server.c	/^struct redisCommand redisCommandTable[] = {$/;"	v	language:C	typeref:struct:redisCommand
redisDb	server.h	/^typedef struct redisDb {$/;"	s	language:C
redisDb	server.h	/^} redisDb;$/;"	t	language:C	typeref:struct:redisDb
redisDb::avg_ttl	server.h	/^    long long avg_ttl;          \/* Average TTL, just for stats *\/$/;"	m	language:C	struct:redisDb	access:public
redisDb::blocking_keys	server.h	/^    dict *blocking_keys;        \/* Keys with clients waiting for data (BLPOP)*\/$/;"	m	language:C	struct:redisDb	access:public
redisDb::dict	server.h	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	language:C	struct:redisDb	access:public
redisDb::expires	server.h	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	language:C	struct:redisDb	access:public
redisDb::id	server.h	/^    int id;                     \/* Database ID *\/$/;"	m	language:C	struct:redisDb	access:public
redisDb::ready_keys	server.h	/^    dict *ready_keys;           \/* Blocked keys that received a PUSH *\/$/;"	m	language:C	struct:redisDb	access:public
redisDb::watched_keys	server.h	/^    dict *watched_keys;         \/* WATCHED keys for MULTI\/EXEC CAS *\/$/;"	m	language:C	struct:redisDb	access:public
redisDebug	server.h	/^#define redisDebug(/;"	d	language:C
redisDebugMark	server.h	/^#define redisDebugMark(/;"	d	language:C
redisFunctionSym	server.h	/^struct redisFunctionSym {$/;"	s	language:C
redisFunctionSym::name	server.h	/^    char *name;$/;"	m	language:C	struct:redisFunctionSym	access:public
redisFunctionSym::pointer	server.h	/^    unsigned long pointer;$/;"	m	language:C	struct:redisFunctionSym	access:public
redisGetKeysProc	server.h	/^typedef int *redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	t	language:C
redisGitDirty	redis-cli.c	/^char *redisGitDirty(void);$/;"	p	language:C	file:	signature:(void)
redisGitDirty	release.c	/^char *redisGitDirty(void) {$/;"	f	language:C	signature:(void)
redisGitDirty	server.h	/^char *redisGitDirty(void);$/;"	p	language:C	signature:(void)
redisGitSHA1	redis-cli.c	/^char *redisGitSHA1(void);$/;"	p	language:C	file:	signature:(void)
redisGitSHA1	release.c	/^char *redisGitSHA1(void) {$/;"	f	language:C	signature:(void)
redisGitSHA1	server.h	/^char *redisGitSHA1(void);$/;"	p	language:C	signature:(void)
redisIsSupervised	server.c	/^int redisIsSupervised(int mode) {$/;"	f	language:C	signature:(int mode)
redisLrand48	rand.c	/^int32_t redisLrand48() {$/;"	f	language:C
redisLrand48	rand.h	/^int32_t redisLrand48();$/;"	p	language:C
redisNodeFlags	cluster.c	/^struct redisNodeFlags {$/;"	s	language:C	file:
redisNodeFlags::flag	cluster.c	/^    uint16_t flag;$/;"	m	language:C	struct:redisNodeFlags	file:	access:public
redisNodeFlags::name	cluster.c	/^    char *name;$/;"	m	language:C	struct:redisNodeFlags	file:	access:public
redisNodeFlagsTable	cluster.c	/^static struct redisNodeFlags redisNodeFlagsTable[] = {$/;"	v	language:C	typeref:struct:redisNodeFlags	file:
redisObject	rio.h	/^struct redisObject;$/;"	x	language:C
redisObject	server.h	/^struct redisObject;$/;"	x	language:C
redisObject	server.h	/^typedef struct redisObject {$/;"	s	language:C
redisObject::encoding	server.h	/^    unsigned encoding:4;$/;"	m	language:C	struct:redisObject	access:public
redisObject::lru	server.h	/^    unsigned lru:LRU_BITS; \/* LRU time (relative to server.lruclock) or$/;"	m	language:C	struct:redisObject	access:public
redisObject::ptr	server.h	/^    void *ptr;$/;"	m	language:C	struct:redisObject	access:public
redisObject::refcount	server.h	/^    int refcount;$/;"	m	language:C	struct:redisObject	access:public
redisObject::type	server.h	/^    unsigned type:4;$/;"	m	language:C	struct:redisObject	access:public
redisOp	server.h	/^typedef struct redisOp {$/;"	s	language:C
redisOp	server.h	/^} redisOp;$/;"	t	language:C	typeref:struct:redisOp
redisOp::argc	server.h	/^    int argc, dbid, target;$/;"	m	language:C	struct:redisOp	access:public
redisOp::argv	server.h	/^    robj **argv;$/;"	m	language:C	struct:redisOp	access:public
redisOp::cmd	server.h	/^    struct redisCommand *cmd;$/;"	m	language:C	struct:redisOp	typeref:struct:redisOp::redisCommand	access:public
redisOp::dbid	server.h	/^    int argc, dbid, target;$/;"	m	language:C	struct:redisOp	access:public
redisOp::target	server.h	/^    int argc, dbid, target;$/;"	m	language:C	struct:redisOp	access:public
redisOpArray	server.h	/^typedef struct redisOpArray {$/;"	s	language:C
redisOpArray	server.h	/^} redisOpArray;$/;"	t	language:C	typeref:struct:redisOpArray
redisOpArray::numops	server.h	/^    int numops;$/;"	m	language:C	struct:redisOpArray	access:public
redisOpArray::ops	server.h	/^    redisOp *ops;$/;"	m	language:C	struct:redisOpArray	access:public
redisOpArrayAppend	server.c	/^int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,$/;"	f	language:C	signature:(redisOpArray *oa, struct redisCommand *cmd, int dbid, robj **argv, int argc, int target)
redisOpArrayFree	server.c	/^void redisOpArrayFree(redisOpArray *oa) {$/;"	f	language:C	signature:(redisOpArray *oa)
redisOpArrayInit	server.c	/^void redisOpArrayInit(redisOpArray *oa) {$/;"	f	language:C	signature:(redisOpArray *oa)
redisOutOfMemoryHandler	server.c	/^void redisOutOfMemoryHandler(size_t allocation_size) {$/;"	f	language:C	signature:(size_t allocation_size)
redisPopcount	bitops.c	/^size_t redisPopcount(void *s, long count) {$/;"	f	language:C	signature:(void *s, long count)
redisPopcount	server.h	/^size_t redisPopcount(void *s, long count);$/;"	p	language:C	signature:(void *s, long count)
redisProtocolToLuaType	scripting.c	/^char *redisProtocolToLuaType(lua_State *lua, char* reply) {$/;"	f	language:C	signature:(lua_State *lua, char* reply)
redisProtocolToLuaType_Bulk	scripting.c	/^char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {$/;"	f	language:C	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Bulk	scripting.c	/^char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);$/;"	p	language:C	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Error	scripting.c	/^char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {$/;"	f	language:C	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Error	scripting.c	/^char *redisProtocolToLuaType_Error(lua_State *lua, char *reply);$/;"	p	language:C	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Int	scripting.c	/^char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {$/;"	f	language:C	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Int	scripting.c	/^char *redisProtocolToLuaType_Int(lua_State *lua, char *reply);$/;"	p	language:C	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_MultiBulk	scripting.c	/^char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {$/;"	f	language:C	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_MultiBulk	scripting.c	/^char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply);$/;"	p	language:C	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Status	scripting.c	/^char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {$/;"	f	language:C	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Status	scripting.c	/^char *redisProtocolToLuaType_Status(lua_State *lua, char *reply);$/;"	p	language:C	file:	signature:(lua_State *lua, char *reply)
redisServer	server.h	/^struct redisServer {$/;"	s	language:C
redisServer::__anon29::idx	server.h	/^        int idx;$/;"	m	language:C	struct:redisServer::__anon29	access:public
redisServer::__anon29::last_sample_count	server.h	/^        long long last_sample_count;\/* Count in last sample *\/$/;"	m	language:C	struct:redisServer::__anon29	access:public
redisServer::__anon29::last_sample_time	server.h	/^        long long last_sample_time; \/* Timestamp of last sample in ms *\/$/;"	m	language:C	struct:redisServer::__anon29	access:public
redisServer::__anon29::samples	server.h	/^        long long samples[STATS_METRIC_SAMPLES];$/;"	m	language:C	struct:redisServer::__anon29	access:public
redisServer::active_expire_enabled	server.h	/^    int active_expire_enabled;      \/* Can be disabled for testing purposes. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::activerehashing	server.h	/^    int activerehashing;        \/* Incremental rehash in serverCron() *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::also_propagate	server.h	/^    redisOpArray also_propagate;    \/* Additional command to propagate. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_buf	server.h	/^    sds aof_buf;      \/* AOF buffer, written before entering the event loop *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_child_diff	server.h	/^    sds aof_child_diff;             \/* AOF diff accumulator child side. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_child_pid	server.h	/^    pid_t aof_child_pid;            \/* PID if rewriting process *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_current_size	server.h	/^    off_t aof_current_size;         \/* AOF current size. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_delayed_fsync	server.h	/^    unsigned long aof_delayed_fsync;  \/* delayed AOF fsync() counter *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_fd	server.h	/^    int aof_fd;       \/* File descriptor of currently selected AOF file *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_filename	server.h	/^    char *aof_filename;             \/* Name of the AOF file *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_flush_postponed_start	server.h	/^    time_t aof_flush_postponed_start; \/* UNIX time of postponed AOF flush *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_fsync	server.h	/^    int aof_fsync;                  \/* Kind of fsync() policy *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_last_fsync	server.h	/^    time_t aof_last_fsync;            \/* UNIX time of last fsync() *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_last_write_errno	server.h	/^    int aof_last_write_errno;       \/* Valid if aof_last_write_status is ERR *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_last_write_status	server.h	/^    int aof_last_write_status;      \/* C_OK or C_ERR *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_lastbgrewrite_status	server.h	/^    int aof_lastbgrewrite_status;   \/* C_OK or C_ERR *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_load_truncated	server.h	/^    int aof_load_truncated;         \/* Don't stop on unexpected AOF EOF. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_no_fsync_on_rewrite	server.h	/^    int aof_no_fsync_on_rewrite;    \/* Don't fsync if a rewrite is in prog. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_pipe_read_ack_from_child	server.h	/^    int aof_pipe_read_ack_from_child;$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_pipe_read_ack_from_parent	server.h	/^    int aof_pipe_read_ack_from_parent;$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_pipe_read_data_from_parent	server.h	/^    int aof_pipe_read_data_from_parent;$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_pipe_write_ack_to_child	server.h	/^    int aof_pipe_write_ack_to_child;$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_pipe_write_ack_to_parent	server.h	/^    int aof_pipe_write_ack_to_parent;$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_pipe_write_data_to_child	server.h	/^    int aof_pipe_write_data_to_child;$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_base_size	server.h	/^    off_t aof_rewrite_base_size;    \/* AOF size on latest startup or rewrite. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_buf_blocks	server.h	/^    list *aof_rewrite_buf_blocks;   \/* Hold changes during an AOF rewrite. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_incremental_fsync	server.h	/^    int aof_rewrite_incremental_fsync;\/* fsync incrementally while rewriting? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_min_size	server.h	/^    off_t aof_rewrite_min_size;     \/* the AOF file is at least N bytes. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_perc	server.h	/^    int aof_rewrite_perc;           \/* Rewrite AOF if % growth is > M and... *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_scheduled	server.h	/^    int aof_rewrite_scheduled;      \/* Rewrite once BGSAVE terminates. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_time_last	server.h	/^    time_t aof_rewrite_time_last;   \/* Time used by last AOF rewrite run. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_rewrite_time_start	server.h	/^    time_t aof_rewrite_time_start;  \/* Current AOF rewrite start time. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_selected_db	server.h	/^    int aof_selected_db; \/* Currently selected DB in AOF *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_state	server.h	/^    int aof_state;                  \/* AOF_(ON|OFF|WAIT_REWRITE) *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::aof_stop_sending_diff	server.h	/^    int aof_stop_sending_diff;     \/* If true stop sending accumulated diffs$/;"	m	language:C	struct:redisServer	access:public
redisServer::arch_bits	server.h	/^    int arch_bits;              \/* 32 or 64 depending on sizeof(long) *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::assert_failed	server.h	/^    const char *assert_failed;$/;"	m	language:C	struct:redisServer	access:public
redisServer::assert_file	server.h	/^    const char *assert_file;$/;"	m	language:C	struct:redisServer	access:public
redisServer::assert_line	server.h	/^    int assert_line;$/;"	m	language:C	struct:redisServer	access:public
redisServer::bindaddr	server.h	/^    char *bindaddr[CONFIG_BINDADDR_MAX]; \/* Addresses we should bind to *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::bindaddr_count	server.h	/^    int bindaddr_count;         \/* Number of addresses in server.bindaddr[] *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::bpop_blocked_clients	server.h	/^    unsigned int bpop_blocked_clients; \/* Number of clients blocked by lists *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::bug_report_start	server.h	/^    int bug_report_start; \/* True if bug report header was already logged. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cached_master	server.h	/^    client *cached_master; \/* Cached master to be reused for PSYNC. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cfd	server.h	/^    int cfd[CONFIG_BINDADDR_MAX];\/* Cluster bus listening socket *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cfd_count	server.h	/^    int cfd_count;              \/* Used slots in cfd[] *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::client_max_querybuf_len	server.h	/^    size_t client_max_querybuf_len; \/* Limit for client query buffer length *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::client_obuf_limits	server.h	/^    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];$/;"	m	language:C	struct:redisServer	access:public
redisServer::clients	server.h	/^    list *clients;              \/* List of active clients *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::clients_pause_end_time	server.h	/^    mstime_t clients_pause_end_time; \/* Time when we undo clients_paused *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::clients_paused	server.h	/^    int clients_paused;         \/* True if clients are currently paused *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::clients_pending_write	server.h	/^    list *clients_pending_write; \/* There is to write or install handler. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::clients_to_close	server.h	/^    list *clients_to_close;     \/* Clients to close asynchronously *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::clients_waiting_acks	server.h	/^    list *clients_waiting_acks;         \/* Clients waiting in WAIT command. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster	server.h	/^    struct clusterState *cluster;  \/* State of the cluster *\/$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::clusterState	access:public
redisServer::cluster_announce_bus_port	server.h	/^    int cluster_announce_bus_port; \/* bus port to announce on cluster bus. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_announce_ip	server.h	/^    char *cluster_announce_ip;  \/* IP address to announce on cluster bus. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_announce_port	server.h	/^    int cluster_announce_port;     \/* base port to announce on cluster bus. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_configfile	server.h	/^    char *cluster_configfile; \/* Cluster auto-generated config file name. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_enabled	server.h	/^    int cluster_enabled;      \/* Is cluster enabled? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_migration_barrier	server.h	/^    int cluster_migration_barrier; \/* Cluster replicas migration barrier. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_node_timeout	server.h	/^    mstime_t cluster_node_timeout; \/* Cluster node timeout. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_require_full_coverage	server.h	/^    int cluster_require_full_coverage; \/* If true, put the cluster down if$/;"	m	language:C	struct:redisServer	access:public
redisServer::cluster_slave_validity_factor	server.h	/^    int cluster_slave_validity_factor; \/* Slave max data age for failover. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::commands	server.h	/^    dict *commands;             \/* Command table *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::configfile	server.h	/^    char *configfile;           \/* Absolute config file path, or NULL *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::cronloops	server.h	/^    int cronloops;              \/* Number of times the cron function run *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::current_client	server.h	/^    client *current_client; \/* Current client, only used on crash report *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::daemonize	server.h	/^    int daemonize;                  \/* True if running as a daemon *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::db	server.h	/^    redisDb *db;$/;"	m	language:C	struct:redisServer	access:public
redisServer::dbnum	server.h	/^    int dbnum;                      \/* Total number of configured DBs *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::delCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::redisCommand	access:public
redisServer::dirty	server.h	/^    long long dirty;                \/* Changes to DB from the last save *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::dirty_before_bgsave	server.h	/^    long long dirty_before_bgsave;  \/* Used to restore dirty on failed BGSAVE *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::el	server.h	/^    aeEventLoop *el;$/;"	m	language:C	struct:redisServer	access:public
redisServer::execCommand	server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::exec_argv	server.h	/^    char **exec_argv;           \/* Executable argv vector (copy). *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::executable	server.h	/^    char *executable;           \/* Absolute executable file path. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::get_ack_from_slaves	server.h	/^    int get_ack_from_slaves;            \/* If true we send REPLCONF GETACK. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::hash_max_ziplist_entries	server.h	/^    size_t hash_max_ziplist_entries;$/;"	m	language:C	struct:redisServer	access:public
redisServer::hash_max_ziplist_value	server.h	/^    size_t hash_max_ziplist_value;$/;"	m	language:C	struct:redisServer	access:public
redisServer::hll_sparse_max_bytes	server.h	/^    size_t hll_sparse_max_bytes;$/;"	m	language:C	struct:redisServer	access:public
redisServer::hz	server.h	/^    int hz;                     \/* serverCron() calls frequency in hertz *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::inst_metric	server.h	/^    } inst_metric[STATS_METRIC_COUNT];$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::__anon29	access:public
redisServer::ipfd	server.h	/^    int ipfd[CONFIG_BINDADDR_MAX]; \/* TCP socket file descriptors *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::ipfd_count	server.h	/^    int ipfd_count;             \/* Used slots in ipfd[] *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lastbgsave_status	server.h	/^    int lastbgsave_status;          \/* C_OK or C_ERR *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lastbgsave_try	server.h	/^    time_t lastbgsave_try;          \/* Unix time of last attempted bgsave *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lastsave	server.h	/^    time_t lastsave;                \/* Unix time of last successful save *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::latency_events	server.h	/^    dict *latency_events;$/;"	m	language:C	struct:redisServer	access:public
redisServer::latency_monitor_threshold	server.h	/^    long long latency_monitor_threshold;$/;"	m	language:C	struct:redisServer	access:public
redisServer::lazyfree_lazy_eviction	server.h	/^    int lazyfree_lazy_eviction;$/;"	m	language:C	struct:redisServer	access:public
redisServer::lazyfree_lazy_expire	server.h	/^    int lazyfree_lazy_expire;$/;"	m	language:C	struct:redisServer	access:public
redisServer::lazyfree_lazy_server_del	server.h	/^    int lazyfree_lazy_server_del;$/;"	m	language:C	struct:redisServer	access:public
redisServer::lfu_decay_time	server.h	/^    unsigned int lfu_decay_time;    \/* LFU counter decay factor. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lfu_log_factor	server.h	/^    unsigned int lfu_log_factor;    \/* LFU logarithmic counter factor. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::list_compress_depth	server.h	/^    int list_compress_depth;$/;"	m	language:C	struct:redisServer	access:public
redisServer::list_max_ziplist_size	server.h	/^    int list_max_ziplist_size;$/;"	m	language:C	struct:redisServer	access:public
redisServer::loading	server.h	/^    int loading;                \/* We are loading data from disk if true *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::loading_loaded_bytes	server.h	/^    off_t loading_loaded_bytes;$/;"	m	language:C	struct:redisServer	access:public
redisServer::loading_process_events_interval_bytes	server.h	/^    off_t loading_process_events_interval_bytes;$/;"	m	language:C	struct:redisServer	access:public
redisServer::loading_start_time	server.h	/^    time_t loading_start_time;$/;"	m	language:C	struct:redisServer	access:public
redisServer::loading_total_bytes	server.h	/^    off_t loading_total_bytes;$/;"	m	language:C	struct:redisServer	access:public
redisServer::loadmodule_queue	server.h	/^    list *loadmodule_queue;     \/* List of modules to load at startup. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::logfile	server.h	/^    char *logfile;                  \/* Path of log file *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lpopCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::lpushCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::lruclock	server.h	/^    unsigned lruclock:LRU_BITS; \/* Clock for LRU eviction *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua	server.h	/^    lua_State *lua; \/* The Lua interpreter. We use just one for all clients *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_always_replicate_commands	server.h	/^    int lua_always_replicate_commands; \/* Default replication type. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_caller	server.h	/^    client *lua_caller;   \/* The client running EVAL right now, or NULL *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_client	server.h	/^    client *lua_client;   \/* The "fake client" to query Redis from Lua *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_kill	server.h	/^    int lua_kill;         \/* Kill the script if true. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_multi_emitted	server.h	/^    int lua_multi_emitted;\/* True if we already proagated MULTI. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_random_dirty	server.h	/^    int lua_random_dirty; \/* True if a random command was called during the$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_repl	server.h	/^    int lua_repl;         \/* Script replication flags for redis.set_repl(). *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_replicate_commands	server.h	/^    int lua_replicate_commands; \/* True if we are doing single commands repl. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_scripts	server.h	/^    dict *lua_scripts;         \/* A dictionary of SHA1 -> Lua scripts *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_time_limit	server.h	/^    mstime_t lua_time_limit;  \/* Script timeout in milliseconds *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_time_start	server.h	/^    mstime_t lua_time_start;  \/* Start time of script, milliseconds time *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_timedout	server.h	/^    int lua_timedout;     \/* True if we reached the time limit for script$/;"	m	language:C	struct:redisServer	access:public
redisServer::lua_write_dirty	server.h	/^    int lua_write_dirty;  \/* True if a write command was called during the$/;"	m	language:C	struct:redisServer	access:public
redisServer::master	server.h	/^    client *master;     \/* Client that is master for this slave *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::master_repl_offset	server.h	/^    long long master_repl_offset;   \/* Global replication offset *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::masterauth	server.h	/^    char *masterauth;               \/* AUTH with this password with master *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::masterhost	server.h	/^    char *masterhost;               \/* Hostname of master *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::masterport	server.h	/^    int masterport;                 \/* Port of master *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::maxclients	server.h	/^    unsigned int maxclients;            \/* Max number of simultaneous clients *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::maxidletime	server.h	/^    int maxidletime;                \/* Client timeout in seconds *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::maxmemory	server.h	/^    unsigned long long maxmemory;   \/* Max number of memory bytes to use *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::maxmemory_policy	server.h	/^    int maxmemory_policy;           \/* Policy for key eviction *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::maxmemory_samples	server.h	/^    int maxmemory_samples;          \/* Pricision of random sampling *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::migrate_cached_sockets	server.h	/^    dict *migrate_cached_sockets;\/* MIGRATE cached sockets *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::moduleapi	server.h	/^    dict *moduleapi;            \/* Exported APIs dictionary for modules. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::monitors	server.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::mstime	server.h	/^    long long mstime;   \/* Like 'unixtime' but with milliseconds resolution. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::multiCommand	server.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::neterr	server.h	/^    char neterr[ANET_ERR_LEN];   \/* Error buffer for anet.c *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::next_client_id	server.h	/^    uint64_t next_client_id;    \/* Next client unique ID. Incremental. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::notify_keyspace_events	server.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	language:C	struct:redisServer	access:public
redisServer::orig_commands	server.h	/^    dict *orig_commands;        \/* Command table before command renaming. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::pid	server.h	/^    pid_t pid;                  \/* Main process pid. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::pidfile	server.h	/^    char *pidfile;              \/* PID file path *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::port	server.h	/^    int port;                   \/* TCP listening port *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::protected_mode	server.h	/^    int protected_mode;         \/* Don't accept external connections. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::pubsub_channels	server.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::pubsub_patterns	server.h	/^    list *pubsub_patterns;  \/* A list of pubsub_patterns *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_bgsave_scheduled	server.h	/^    int rdb_bgsave_scheduled;       \/* BGSAVE when possible if true. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_checksum	server.h	/^    int rdb_checksum;               \/* Use RDB checksum? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_child_pid	server.h	/^    pid_t rdb_child_pid;            \/* PID of RDB saving child *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_child_type	server.h	/^    int rdb_child_type;             \/* Type of save by active child. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_compression	server.h	/^    int rdb_compression;            \/* Use compression in RDB? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_filename	server.h	/^    char *rdb_filename;             \/* Name of RDB file *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_pipe_read_result_from_child	server.h	/^    int rdb_pipe_read_result_from_child; \/* of each slave in diskless SYNC. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_pipe_write_result_to_parent	server.h	/^    int rdb_pipe_write_result_to_parent; \/* RDB pipes used to return the state *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_save_time_last	server.h	/^    time_t rdb_save_time_last;      \/* Time used by last RDB save run. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rdb_save_time_start	server.h	/^    time_t rdb_save_time_start;     \/* Current RDB save start time. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::ready_keys	server.h	/^    list *ready_keys;        \/* List of readyList structures for BLPOP & co *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_backlog	server.h	/^    char *repl_backlog;             \/* Replication backlog for partial syncs *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_backlog_histlen	server.h	/^    long long repl_backlog_histlen; \/* Backlog actual data length *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_backlog_idx	server.h	/^    long long repl_backlog_idx;     \/* Backlog circular buffer current offset *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_backlog_off	server.h	/^    long long repl_backlog_off;     \/* Replication offset of first byte in the$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_backlog_size	server.h	/^    long long repl_backlog_size;    \/* Backlog circular buffer size *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_backlog_time_limit	server.h	/^    time_t repl_backlog_time_limit; \/* Time without slaves after the backlog$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_disable_tcp_nodelay	server.h	/^    int repl_disable_tcp_nodelay;   \/* Disable TCP_NODELAY after SYNC? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_diskless_sync	server.h	/^    int repl_diskless_sync;         \/* Send RDB to slaves sockets directly. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_diskless_sync_delay	server.h	/^    int repl_diskless_sync_delay;   \/* Delay to start a diskless repl BGSAVE. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_down_since	server.h	/^    time_t repl_down_since; \/* Unix time at which link with master went down *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_good_slaves_count	server.h	/^    int repl_good_slaves_count;     \/* Number of slaves with lag <= max_lag. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_master_initial_offset	server.h	/^    long long repl_master_initial_offset;         \/* Master PSYNC offset. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_master_runid	server.h	/^    char repl_master_runid[CONFIG_RUN_ID_SIZE+1];  \/* Master run id for PSYNC.*\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_min_slaves_max_lag	server.h	/^    int repl_min_slaves_max_lag;    \/* Max lag of <count> slaves to write. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_min_slaves_to_write	server.h	/^    int repl_min_slaves_to_write;   \/* Min number of slaves to write. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_no_slaves_since	server.h	/^    time_t repl_no_slaves_since;    \/* We have no slaves since that time.$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_ping_slave_period	server.h	/^    int repl_ping_slave_period;     \/* Master pings the slave every N seconds *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_scriptcache_dict	server.h	/^    dict *repl_scriptcache_dict;        \/* SHA1 all slaves are aware of. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_scriptcache_fifo	server.h	/^    list *repl_scriptcache_fifo;        \/* First in, first out LRU eviction. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_scriptcache_size	server.h	/^    unsigned int repl_scriptcache_size; \/* Max number of elements. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_serve_stale_data	server.h	/^    int repl_serve_stale_data; \/* Serve stale data when link is down? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_slave_lazy_flush	server.h	/^    int repl_slave_lazy_flush;          \/* Lazy FLUSHALL before loading DB? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_slave_ro	server.h	/^    int repl_slave_ro;          \/* Slave is read only? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_state	server.h	/^    int repl_state;          \/* Replication status if the instance is a slave *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_syncio_timeout	server.h	/^    int repl_syncio_timeout; \/* Timeout for synchronous I\/O calls *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_timeout	server.h	/^    int repl_timeout;               \/* Timeout after N seconds of master idle *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_transfer_fd	server.h	/^    int repl_transfer_fd;    \/* Slave -> Master SYNC temp file descriptor *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_transfer_last_fsync_off	server.h	/^    off_t repl_transfer_last_fsync_off; \/* Offset when we fsync-ed last time. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_transfer_lastio	server.h	/^    time_t repl_transfer_lastio; \/* Unix time of the latest read, for timeout *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_transfer_read	server.h	/^    off_t repl_transfer_read; \/* Amount of RDB read from master during sync. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_transfer_s	server.h	/^    int repl_transfer_s;     \/* Slave -> Master SYNC socket *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_transfer_size	server.h	/^    off_t repl_transfer_size; \/* Size of RDB to read from master during sync. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::repl_transfer_tmpfile	server.h	/^    char *repl_transfer_tmpfile; \/* Slave-> master SYNC temp file name *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::requirepass	server.h	/^    char *requirepass;          \/* Pass for AUTH command, or NULL *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::resident_set_size	server.h	/^    size_t resident_set_size;       \/* RSS sampled in serverCron(). *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::rpopCommand	server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::runid	server.h	/^    char runid[CONFIG_RUN_ID_SIZE+1];  \/* ID always different at every exec. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::saveparams	server.h	/^    struct saveparam *saveparams;   \/* Save points array for RDB *\/$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::saveparam	access:public
redisServer::saveparamslen	server.h	/^    int saveparamslen;              \/* Number of saving points *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::sentinel_mode	server.h	/^    int sentinel_mode;          \/* True if this instance is a Sentinel. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::set_max_intset_entries	server.h	/^    size_t set_max_intset_entries;$/;"	m	language:C	struct:redisServer	access:public
redisServer::shutdown_asap	server.h	/^    int shutdown_asap;          \/* SHUTDOWN needed ASAP *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slave_announce_ip	server.h	/^    char *slave_announce_ip;        \/* Give the master this ip address. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slave_announce_port	server.h	/^    int slave_announce_port;        \/* Give the master this listening port. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slave_priority	server.h	/^    int slave_priority;             \/* Reported in INFO and used by Sentinel. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slaves	server.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slaveseldb	server.h	/^    int slaveseldb;                 \/* Last SELECTed DB in replication output *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slowlog	server.h	/^    list *slowlog;                  \/* SLOWLOG list of commands *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slowlog_entry_id	server.h	/^    long long slowlog_entry_id;     \/* SLOWLOG current entry ID *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slowlog_log_slower_than	server.h	/^    long long slowlog_log_slower_than; \/* SLOWLOG time limit (to get logged) *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::slowlog_max_len	server.h	/^    unsigned long slowlog_max_len;     \/* SLOWLOG max number of items logged *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::sofd	server.h	/^    int sofd;                   \/* Unix socket file descriptor *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::sort_alpha	server.h	/^    int sort_alpha;$/;"	m	language:C	struct:redisServer	access:public
redisServer::sort_bypattern	server.h	/^    int sort_bypattern;$/;"	m	language:C	struct:redisServer	access:public
redisServer::sort_desc	server.h	/^    int sort_desc;$/;"	m	language:C	struct:redisServer	access:public
redisServer::sort_store	server.h	/^    int sort_store;$/;"	m	language:C	struct:redisServer	access:public
redisServer::sremCommand	server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::stat_evictedkeys	server.h	/^    long long stat_evictedkeys;     \/* Number of evicted keys (maxmemory) *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_expiredkeys	server.h	/^    long long stat_expiredkeys;     \/* Number of expired keys *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_fork_rate	server.h	/^    double stat_fork_rate;          \/* Fork rate in GB\/sec. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_fork_time	server.h	/^    long long stat_fork_time;       \/* Time needed to perform latest fork() *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_keyspace_hits	server.h	/^    long long stat_keyspace_hits;   \/* Number of successful lookups of keys *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_keyspace_misses	server.h	/^    long long stat_keyspace_misses; \/* Number of failed lookups of keys *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_net_input_bytes	server.h	/^    long long stat_net_input_bytes; \/* Bytes read from network. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_net_output_bytes	server.h	/^    long long stat_net_output_bytes; \/* Bytes written to network. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_numcommands	server.h	/^    long long stat_numcommands;     \/* Number of processed commands *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_numconnections	server.h	/^    long long stat_numconnections;  \/* Number of connections received *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_peak_memory	server.h	/^    size_t stat_peak_memory;        \/* Max used memory record *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_rejected_conn	server.h	/^    long long stat_rejected_conn;   \/* Clients rejected because of maxclients *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_starttime	server.h	/^    time_t stat_starttime;          \/* Server start time *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_sync_full	server.h	/^    long long stat_sync_full;       \/* Number of full resyncs with slaves. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_sync_partial_err	server.h	/^    long long stat_sync_partial_err;\/* Number of unaccepted PSYNC requests. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stat_sync_partial_ok	server.h	/^    long long stat_sync_partial_ok; \/* Number of accepted PSYNC requests. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::stop_writes_on_bgsave_err	server.h	/^    int stop_writes_on_bgsave_err;  \/* Don't allow writes if can't BGSAVE *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::supervised	server.h	/^    int supervised;                 \/* 1 if supervised, 0 otherwise. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::supervised_mode	server.h	/^    int supervised_mode;            \/* See SUPERVISED_* *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::syslog_enabled	server.h	/^    int syslog_enabled;             \/* Is syslog enabled? *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::syslog_facility	server.h	/^    int syslog_facility;            \/* Syslog facility *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::syslog_ident	server.h	/^    char *syslog_ident;             \/* Syslog ident *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::system_memory_size	server.h	/^    size_t system_memory_size;  \/* Total memory in system as reported by OS *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::tcp_backlog	server.h	/^    int tcp_backlog;            \/* TCP listen() backlog *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::tcpkeepalive	server.h	/^    int tcpkeepalive;               \/* Set SO_KEEPALIVE if non-zero. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::unblocked_clients	server.h	/^    list *unblocked_clients; \/* list of clients to unblock before next loop *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::unixsocket	server.h	/^    char *unixsocket;           \/* UNIX socket path *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::unixsocketperm	server.h	/^    mode_t unixsocketperm;      \/* UNIX socket permission *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::unixtime	server.h	/^    time_t unixtime;    \/* Unix time sampled every cron cycle. *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::verbosity	server.h	/^    int verbosity;                  \/* Loglevel in redis.conf *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::watchdog_period	server.h	/^    int watchdog_period;  \/* Software watchdog period in ms. 0 = off *\/$/;"	m	language:C	struct:redisServer	access:public
redisServer::zset_max_ziplist_entries	server.h	/^    size_t zset_max_ziplist_entries;$/;"	m	language:C	struct:redisServer	access:public
redisServer::zset_max_ziplist_value	server.h	/^    size_t zset_max_ziplist_value;$/;"	m	language:C	struct:redisServer	access:public
redisSetProcTitle	server.c	/^void redisSetProcTitle(char *title) {$/;"	f	language:C	signature:(char *title)
redisSetProcTitle	server.h	/^void redisSetProcTitle(char *title);$/;"	p	language:C	signature:(char *title)
redisSortObject	server.h	/^} redisSortObject;$/;"	t	language:C	typeref:struct:_redisSortObject
redisSortOperation	server.h	/^} redisSortOperation;$/;"	t	language:C	typeref:struct:_redisSortOperation
redisSrand48	rand.c	/^void redisSrand48(int32_t seedval) {$/;"	f	language:C	signature:(int32_t seedval)
redisSrand48	rand.h	/^void redisSrand48(int32_t seedval);$/;"	p	language:C	signature:(int32_t seedval)
redisSupervisedSystemd	server.c	/^int redisSupervisedSystemd(void) {$/;"	f	language:C	signature:(void)
redisSupervisedUpstart	server.c	/^int redisSupervisedUpstart(void) {$/;"	f	language:C	signature:(void)
redis_bits	rdb.c	/^    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;$/;"	l	language:C
redis_check_rdb	redis-check-rdb.c	/^int redis_check_rdb(char *rdbfilename) {$/;"	f	language:C	signature:(char *rdbfilename)
redis_check_rdb	server.h	/^int redis_check_rdb(char *rdbfilename);$/;"	p	language:C	signature:(char *rdbfilename)
redis_check_rdb_main	redis-check-rdb.c	/^int redis_check_rdb_main(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
redis_check_rdb_main	server.h	/^int redis_check_rdb_main(int argc, char **argv);$/;"	p	language:C	signature:(int argc, char **argv)
redis_fstat	config.h	/^#define redis_fstat /;"	d	language:C
redis_math_random	scripting.c	/^int redis_math_random (lua_State *L) {$/;"	f	language:C	signature:(lua_State *L)
redis_math_random	scripting.c	/^int redis_math_random (lua_State *L);$/;"	p	language:C	file:	signature:(lua_State *L)
redis_math_randomseed	scripting.c	/^int redis_math_randomseed (lua_State *L) {$/;"	f	language:C	signature:(lua_State *L)
redis_math_randomseed	scripting.c	/^int redis_math_randomseed (lua_State *L);$/;"	p	language:C	file:	signature:(lua_State *L)
redis_stat	config.h	/^#define redis_stat /;"	d	language:C
rediscmd	module.c	/^    struct redisCommand *rediscmd;$/;"	l	language:C
rediscmd	module.c	/^    struct redisCommand *rediscmd;$/;"	m	language:C	struct:RedisModuleCommandProxy	typeref:struct:RedisModuleCommandProxy::redisCommand	file:	access:public
ref	lzf_c.c	/^  const u8 *ref;$/;"	l	language:C
ref	lzf_d.c	/^          u8 *ref = op - ((ctrl & 0x1f) << 8) - 1;$/;"	l	language:C
ref	sentinel.c	/^    sentinelRedisInstance *ref = master->promoted_slave ?$/;"	l	language:C
ref	ziplist.c	/^        list *ref;$/;"	l	language:C
refcount	sentinel.c	/^    int refcount;          \/* Number of sentinelRedisInstance owners. *\/$/;"	m	language:C	struct:instanceLink	file:	access:public
refcount	server.h	/^    int refcount;$/;"	m	language:C	struct:redisObject	access:public
refnode	ziplist.c	/^        listNode *refnode;$/;"	l	language:C
refreshGoodSlavesCount	replication.c	/^void refreshGoodSlavesCount(void) {$/;"	f	language:C	signature:(void)
refreshGoodSlavesCount	server.h	/^void refreshGoodSlavesCount(void);$/;"	p	language:C	signature:(void)
reg	hyperloglog.c	/^            unsigned long reg;$/;"	l	language:C
regions	debug.c	/^    int regions = 0, j;$/;"	l	language:C
registers	hyperloglog.c	/^        uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;$/;"	l	language:C
registers	hyperloglog.c	/^    uint8_t registers[]; \/* Data bytes. *\/$/;"	m	language:C	struct:hllhdr	file:	access:public
registration	modules/API.md	/^keys, since it was flagged as "getkeys-api" during the registration,$/;"	v	language:C
registration	modules/TYPES.md	/^native type, as obtained during the type registration, and finally a `void*`$/;"	v	language:C
regval	hyperloglog.c	/^            int runlen, regval;$/;"	l	language:C
regval	hyperloglog.c	/^        long runlen, regval;$/;"	l	language:C
regval	hyperloglog.c	/^    int ez = 0, idx = 0, runlen, regval;$/;"	l	language:C
regval	hyperloglog.c	/^    int idx = 0, runlen, regval;$/;"	l	language:C
rehash_db	server.c	/^        static unsigned int rehash_db = 0;$/;"	l	language:C	file:
rehashes	dict.c	/^    int rehashes = 0;$/;"	l	language:C
rehashidx	dict.h	/^    long rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	language:C	struct:dict	access:public
rejoin_delay	cluster.c	/^        mstime_t rejoin_delay = server.cluster_node_timeout;$/;"	l	language:C
releaseInstanceLink	sentinel.c	/^instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)$/;"	f	language:C	signature:(instanceLink *link, sentinelRedisInstance *ri)
releaseSentinelAddr	sentinel.c	/^void releaseSentinelAddr(sentinelAddr *sa) {$/;"	f	language:C	signature:(sentinelAddr *sa)
releaseSentinelRedisInstance	sentinel.c	/^void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
releaseSentinelRedisInstance	sentinel.c	/^void releaseSentinelRedisInstance(sentinelRedisInstance *ri);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *ri)
relerr	hyperloglog.c	/^    double relerr = 1.04\/sqrt(HLL_REGISTERS);$/;"	l	language:C
relmax	sparkline.c	/^    double relmax = seq->max - seq->min;$/;"	l	language:C
relpath	util.c	/^    sds relpath = sdsnew(filename);$/;"	l	language:C
relval	sparkline.c	/^            double relval = s->value - seq->min;$/;"	l	language:C
rem	replication.c	/^            int rem = CONFIG_RUN_ID_SIZE-nread;$/;"	l	language:C
remaining	debug.c	/^            int remaining = sizeof(extra);$/;"	l	language:C
remaining	geo.c	/^        int remaining = c->argc - base_args;$/;"	l	language:C
remaining	networking.c	/^        int remaining = (unsigned)(c->bulklen+2)-sdslen(c->querybuf);$/;"	l	language:C
remaining	syncio.c	/^    long long remaining = timeout;$/;"	l	language:C
remaining	t_set.c	/^    unsigned long remaining = size-count; \/* Elements left after SPOP. *\/$/;"	l	language:C
remaining	t_zset.c	/^        int remaining = c->argc - 4;$/;"	l	language:C
remaining	t_zset.c	/^        int remaining = c->argc - j;$/;"	l	language:C
remaining_bytes	server.c	/^            off_t remaining_bytes = server.loading_total_bytes-$/;"	l	language:C
remaining_slaves	cluster.c	/^                int remaining_slaves = (master->numslaves - j) - 1;$/;"	l	language:C
remargs	bitops.c	/^        int remargs = c->argc-j-1; \/* Remaining args other than current. *\/$/;"	l	language:C
removeExpire	db.c	/^int removeExpire(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
removeExpire	server.h	/^int removeExpire(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
removeMatchingSentinelFromMaster	sentinel.c	/^int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {$/;"	f	language:C	signature:(sentinelRedisInstance *master, char *runid)
removed	db.c	/^    long long removed = 0;$/;"	l	language:C
removed	sentinel.c	/^    int numtokens, port, removed, master_port;$/;"	l	language:C
removed	sentinel.c	/^    int removed = 0;$/;"	l	language:C
removed	t_list.c	/^    long removed = 0;$/;"	l	language:C
removed	t_zset.c	/^    unsigned long removed = 0;$/;"	l	language:C
removed	t_zset.c	/^    unsigned long traversed = 0, removed = 0;$/;"	l	language:C
renameCommand	db.c	/^void renameCommand(client *c) {$/;"	f	language:C	signature:(client *c)
renameCommand	server.h	/^void renameCommand(client *c);$/;"	p	language:C	signature:(client *c)
renameGenericCommand	db.c	/^void renameGenericCommand(client *c, int nx) {$/;"	f	language:C	signature:(client *c, int nx)
renamenxCommand	db.c	/^void renamenxCommand(client *c) {$/;"	f	language:C	signature:(client *c)
renamenxCommand	server.h	/^void renamenxCommand(client *c);$/;"	p	language:C	signature:(client *c)
repeat	redis-cli.c	/^                    int repeat, skipargs = 0;$/;"	l	language:C
repeat	redis-cli.c	/^    long repeat;$/;"	m	language:C	struct:config	file:	access:public
repl	redis-cli.c	/^static void repl(void) {$/;"	f	language:C	file:	signature:(void)
replScriptCacheDictType	server.c	/^dictType replScriptCacheDictType = {$/;"	v	language:C
replScriptCacheDictType	server.h	/^extern dictType replScriptCacheDictType;$/;"	x	language:C
repl_ack_off	server.h	/^    long long repl_ack_off; \/* Replication ack offset, if this is a slave. *\/$/;"	m	language:C	struct:client	access:public
repl_ack_time	server.h	/^    long long repl_ack_time;\/* Replication ack time, if this is a slave. *\/$/;"	m	language:C	struct:client	access:public
repl_backlog	server.h	/^    char *repl_backlog;             \/* Replication backlog for partial syncs *\/$/;"	m	language:C	struct:redisServer	access:public
repl_backlog_histlen	server.h	/^    long long repl_backlog_histlen; \/* Backlog actual data length *\/$/;"	m	language:C	struct:redisServer	access:public
repl_backlog_idx	server.h	/^    long long repl_backlog_idx;     \/* Backlog circular buffer current offset *\/$/;"	m	language:C	struct:redisServer	access:public
repl_backlog_off	server.h	/^    long long repl_backlog_off;     \/* Replication offset of first byte in the$/;"	m	language:C	struct:redisServer	access:public
repl_backlog_size	server.h	/^    long long repl_backlog_size;    \/* Backlog circular buffer size *\/$/;"	m	language:C	struct:redisServer	access:public
repl_backlog_time_limit	server.h	/^    time_t repl_backlog_time_limit; \/* Time without slaves after the backlog$/;"	m	language:C	struct:redisServer	access:public
repl_disable_tcp_nodelay	server.h	/^    int repl_disable_tcp_nodelay;   \/* Disable TCP_NODELAY after SYNC? *\/$/;"	m	language:C	struct:redisServer	access:public
repl_diskless_sync	server.h	/^    int repl_diskless_sync;         \/* Send RDB to slaves sockets directly. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_diskless_sync_delay	server.h	/^    int repl_diskless_sync_delay;   \/* Delay to start a diskless repl BGSAVE. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_down_since	server.h	/^    time_t repl_down_since; \/* Unix time at which link with master went down *\/$/;"	m	language:C	struct:redisServer	access:public
repl_good_slaves_count	server.h	/^    int repl_good_slaves_count;     \/* Number of slaves with lag <= max_lag. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_master_initial_offset	server.h	/^    long long repl_master_initial_offset;         \/* Master PSYNC offset. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_master_runid	server.h	/^    char repl_master_runid[CONFIG_RUN_ID_SIZE+1];  \/* Master run id for PSYNC.*\/$/;"	m	language:C	struct:redisServer	access:public
repl_min_slaves_max_lag	server.h	/^    int repl_min_slaves_max_lag;    \/* Max lag of <count> slaves to write. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_min_slaves_to_write	server.h	/^    int repl_min_slaves_to_write;   \/* Min number of slaves to write. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_no_slaves_since	server.h	/^    time_t repl_no_slaves_since;    \/* We have no slaves since that time.$/;"	m	language:C	struct:redisServer	access:public
repl_offset	cluster.h	/^    long long repl_offset;      \/* Last known repl offset for this node. *\/$/;"	m	language:C	struct:clusterNode	access:public
repl_offset_time	cluster.h	/^    mstime_t repl_offset_time;  \/* Unix time we received offset for this node *\/$/;"	m	language:C	struct:clusterNode	access:public
repl_ping_slave_period	server.h	/^    int repl_ping_slave_period;     \/* Master pings the slave every N seconds *\/$/;"	m	language:C	struct:redisServer	access:public
repl_put_online_on_ack	server.h	/^    int repl_put_online_on_ack; \/* Install slave write handler on ACK. *\/$/;"	m	language:C	struct:client	access:public
repl_scriptcache_dict	server.h	/^    dict *repl_scriptcache_dict;        \/* SHA1 all slaves are aware of. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_scriptcache_fifo	server.h	/^    list *repl_scriptcache_fifo;        \/* First in, first out LRU eviction. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_scriptcache_size	server.h	/^    unsigned int repl_scriptcache_size; \/* Max number of elements. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_serve_stale_data	server.h	/^    int repl_serve_stale_data; \/* Serve stale data when link is down? *\/$/;"	m	language:C	struct:redisServer	access:public
repl_slave_lazy_flush	server.h	/^    int repl_slave_lazy_flush;          \/* Lazy FLUSHALL before loading DB? *\/$/;"	m	language:C	struct:redisServer	access:public
repl_slave_ro	server.h	/^    int repl_slave_ro;          \/* Slave is read only? *\/$/;"	m	language:C	struct:redisServer	access:public
repl_state	server.h	/^    int repl_state;          \/* Replication status if the instance is a slave *\/$/;"	m	language:C	struct:redisServer	access:public
repl_syncio_timeout	server.h	/^    int repl_syncio_timeout; \/* Timeout for synchronous I\/O calls *\/$/;"	m	language:C	struct:redisServer	access:public
repl_timeout	server.h	/^    int repl_timeout;               \/* Timeout after N seconds of master idle *\/$/;"	m	language:C	struct:redisServer	access:public
repl_transfer_fd	server.h	/^    int repl_transfer_fd;    \/* Slave -> Master SYNC temp file descriptor *\/$/;"	m	language:C	struct:redisServer	access:public
repl_transfer_last_fsync_off	server.h	/^    off_t repl_transfer_last_fsync_off; \/* Offset when we fsync-ed last time. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_transfer_lastio	server.h	/^    time_t repl_transfer_lastio; \/* Unix time of the latest read, for timeout *\/$/;"	m	language:C	struct:redisServer	access:public
repl_transfer_read	server.h	/^    off_t repl_transfer_read; \/* Amount of RDB read from master during sync. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_transfer_s	server.h	/^    int repl_transfer_s;     \/* Slave -> Master SYNC socket *\/$/;"	m	language:C	struct:redisServer	access:public
repl_transfer_size	server.h	/^    off_t repl_transfer_size; \/* Size of RDB to read from master during sync. *\/$/;"	m	language:C	struct:redisServer	access:public
repl_transfer_tmpfile	server.h	/^    char *repl_transfer_tmpfile; \/* Slave-> master SYNC temp file name *\/$/;"	m	language:C	struct:redisServer	access:public
replace	cluster.c	/^    int copy, replace, j;$/;"	l	language:C
replace	cluster.c	/^    int j, type, replace = 0;$/;"	l	language:C
replaceClientCommandVector	networking.c	/^void replaceClientCommandVector(client *c, int argc, robj **argv) {$/;"	f	language:C	signature:(client *c, int argc, robj **argv)
replaceClientCommandVector	server.h	/^void replaceClientCommandVector(client *c, int argc, robj **argv);$/;"	p	language:C	signature:(client *c, int argc, robj **argv)
replaced	t_list.c	/^        int replaced = quicklistReplaceAtIndex(ql, index,$/;"	l	language:C
replconfCommand	replication.c	/^void replconfCommand(client *c) {$/;"	f	language:C	signature:(client *c)
replconfCommand	server.h	/^void replconfCommand(client *c);$/;"	p	language:C	signature:(client *c)
repldbfd	server.h	/^    int repldbfd;           \/* Replication DB file descriptor. *\/$/;"	m	language:C	struct:client	access:public
repldboff	server.h	/^    off_t repldboff;        \/* Replication DB file offset. *\/$/;"	m	language:C	struct:client	access:public
repldbsize	server.h	/^    off_t repldbsize;       \/* Replication DB file size. *\/$/;"	m	language:C	struct:client	access:public
replicate	module.c	/^    int replicate = 0; \/* Replicate this command? *\/$/;"	l	language:C
replicationAbortSyncTransfer	replication.c	/^void replicationAbortSyncTransfer(void) {$/;"	f	language:C	signature:(void)
replicationCacheMaster	replication.c	/^void replicationCacheMaster(client *c) {$/;"	f	language:C	signature:(client *c)
replicationCacheMaster	server.h	/^void replicationCacheMaster(client *c);$/;"	p	language:C	signature:(client *c)
replicationCountAcksByOffset	replication.c	/^int replicationCountAcksByOffset(long long offset) {$/;"	f	language:C	signature:(long long offset)
replicationCountAcksByOffset	server.h	/^int replicationCountAcksByOffset(long long offset);$/;"	p	language:C	signature:(long long offset)
replicationCreateMasterClient	replication.c	/^void replicationCreateMasterClient(int fd) {$/;"	f	language:C	signature:(int fd)
replicationCron	replication.c	/^void replicationCron(void) {$/;"	f	language:C	signature:(void)
replicationCron	server.h	/^void replicationCron(void);$/;"	p	language:C	signature:(void)
replicationDiscardCachedMaster	replication.c	/^void replicationDiscardCachedMaster(void) {$/;"	f	language:C	signature:(void)
replicationDiscardCachedMaster	replication.c	/^void replicationDiscardCachedMaster(void);$/;"	p	language:C	file:	signature:(void)
replicationEmptyDbCallback	replication.c	/^void replicationEmptyDbCallback(void *privdata) {$/;"	f	language:C	signature:(void *privdata)
replicationFeedMonitors	replication.c	/^void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {$/;"	f	language:C	signature:(client *c, list *monitors, int dictid, robj **argv, int argc)
replicationFeedMonitors	server.h	/^void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc);$/;"	p	language:C	signature:(client *c, list *monitors, int dictid, robj **argv, int argc)
replicationFeedSlaves	replication.c	/^void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {$/;"	f	language:C	signature:(list *slaves, int dictid, robj **argv, int argc)
replicationFeedSlaves	server.h	/^void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);$/;"	p	language:C	signature:(list *slaves, int dictid, robj **argv, int argc)
replicationGetSlaveName	replication.c	/^char *replicationGetSlaveName(client *c) {$/;"	f	language:C	signature:(client *c)
replicationGetSlaveName	server.h	/^char *replicationGetSlaveName(client *c);$/;"	p	language:C	signature:(client *c)
replicationGetSlaveOffset	replication.c	/^long long replicationGetSlaveOffset(void) {$/;"	f	language:C	signature:(void)
replicationGetSlaveOffset	server.h	/^long long replicationGetSlaveOffset(void);$/;"	p	language:C	signature:(void)
replicationHandleMasterDisconnection	replication.c	/^void replicationHandleMasterDisconnection(void) {$/;"	f	language:C	signature:(void)
replicationHandleMasterDisconnection	server.h	/^void replicationHandleMasterDisconnection(void);$/;"	p	language:C	signature:(void)
replicationRequestAckFromSlaves	replication.c	/^void replicationRequestAckFromSlaves(void) {$/;"	f	language:C	signature:(void)
replicationResurrectCachedMaster	replication.c	/^void replicationResurrectCachedMaster(int newfd) {$/;"	f	language:C	signature:(int newfd)
replicationResurrectCachedMaster	replication.c	/^void replicationResurrectCachedMaster(int newfd);$/;"	p	language:C	file:	signature:(int newfd)
replicationScriptCacheAdd	replication.c	/^void replicationScriptCacheAdd(sds sha1) {$/;"	f	language:C	signature:(sds sha1)
replicationScriptCacheAdd	server.h	/^void replicationScriptCacheAdd(sds sha1);$/;"	p	language:C	signature:(sds sha1)
replicationScriptCacheExists	replication.c	/^int replicationScriptCacheExists(sds sha1) {$/;"	f	language:C	signature:(sds sha1)
replicationScriptCacheExists	server.h	/^int replicationScriptCacheExists(sds sha1);$/;"	p	language:C	signature:(sds sha1)
replicationScriptCacheFlush	replication.c	/^void replicationScriptCacheFlush(void) {$/;"	f	language:C	signature:(void)
replicationScriptCacheFlush	server.h	/^void replicationScriptCacheFlush(void);$/;"	p	language:C	signature:(void)
replicationScriptCacheInit	replication.c	/^void replicationScriptCacheInit(void) {$/;"	f	language:C	signature:(void)
replicationScriptCacheInit	server.h	/^void replicationScriptCacheInit(void);$/;"	p	language:C	signature:(void)
replicationSendAck	replication.c	/^void replicationSendAck(void) {$/;"	f	language:C	signature:(void)
replicationSendAck	replication.c	/^void replicationSendAck(void);$/;"	p	language:C	file:	signature:(void)
replicationSendNewlineToMaster	replication.c	/^void replicationSendNewlineToMaster(void) {$/;"	f	language:C	signature:(void)
replicationSendNewlineToMaster	server.h	/^void replicationSendNewlineToMaster(void);$/;"	p	language:C	signature:(void)
replicationSetMaster	replication.c	/^void replicationSetMaster(char *ip, int port) {$/;"	f	language:C	signature:(char *ip, int port)
replicationSetMaster	server.h	/^void replicationSetMaster(char *ip, int port);$/;"	p	language:C	signature:(char *ip, int port)
replicationSetupSlaveForFullResync	replication.c	/^int replicationSetupSlaveForFullResync(client *slave, long long offset) {$/;"	f	language:C	signature:(client *slave, long long offset)
replicationSetupSlaveForFullResync	server.h	/^int replicationSetupSlaveForFullResync(client *slave, long long offset);$/;"	p	language:C	signature:(client *slave, long long offset)
replicationUnsetMaster	replication.c	/^void replicationUnsetMaster(void) {$/;"	f	language:C	signature:(void)
replicationUnsetMaster	server.h	/^void replicationUnsetMaster(void);$/;"	p	language:C	signature:(void)
replication_cron_loops	replication.c	/^    static long long replication_cron_loops = 0;$/;"	l	language:C	file:
replies	redis-cli.c	/^    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;$/;"	l	language:C
reploff	server.h	/^    long long reploff;      \/* Replication offset if this is our master. *\/$/;"	m	language:C	struct:client	access:public
reploffset	server.h	/^    long long reploffset;   \/* Replication offset to reach. *\/$/;"	m	language:C	struct:blockingState	access:public
replpreamble	server.h	/^    sds replpreamble;       \/* Replication DB preamble. *\/$/;"	m	language:C	struct:client	access:public
replrunid	server.h	/^    char replrunid[CONFIG_RUN_ID_SIZE+1]; \/* Master run id if is a master. *\/$/;"	m	language:C	struct:client	access:public
replstate	server.h	/^    int replstate;          \/* Replication state if this is a slave. *\/$/;"	m	language:C	struct:client	access:public
reply	cluster.c	/^        sds reply = sdscatprintf(sdsempty(),"+%s %llu\\r\\n",$/;"	l	language:C
reply	module.c	/^    RedisModuleCallReply *reply = NULL;$/;"	l	language:C
reply	module.c	/^    RedisModuleCallReply *reply = zmalloc(sizeof(*reply));$/;"	l	language:C
reply	modules/INTRO.md	/^    RedisModuleCallReply *reply;$/;"	v	language:C
reply	modules/INTRO.md	/^    reply = RedisModule_Call(ctx,"INCR","sc",argv[1],"10");$/;"	v	language:C
reply	modules/INTRO.md	/^In order to obtain the type or reply (corresponding to one of the data types$/;"	p	language:C	file:	signature:(corresponding to one of the data types supported by the Redis protocol)
reply	modules/INTRO.md	/^In order to obtain the value of an integer reply, the following function is used, as already shown in the example above:$/;"	v	language:C
reply	modules/INTRO.md	/^you need to free only the top level reply, not the nested replies.$/;"	v	language:C
reply	modules/helloworld.c	/^    RedisModuleCallReply *reply;$/;"	l	language:C
reply	modules/testmodule.c	/^    RedisModuleCallReply *reply;$/;"	l	language:C
reply	redis-benchmark.c	/^    void *reply = NULL;$/;"	l	language:C
reply	redis-cli.c	/^            redisReply *reply = redisCommand(context,$/;"	l	language:C
reply	redis-cli.c	/^    redisReply *reply = NULL;$/;"	l	language:C
reply	redis-cli.c	/^    redisReply *reply = redisCommand(context, "SCAN %llu", *it);$/;"	l	language:C
reply	redis-cli.c	/^    redisReply *reply, *keys;$/;"	l	language:C
reply	redis-cli.c	/^    redisReply *reply;$/;"	l	language:C
reply	replication.c	/^    sds reply;$/;"	l	language:C
reply	scripting.c	/^    sds reply;$/;"	l	language:C
reply	server.h	/^    list *reply;            \/* List of reply objects to send to the client. *\/$/;"	m	language:C	struct:client	access:public
replyToBlockedClientTimedOut	blocked.c	/^void replyToBlockedClientTimedOut(client *c) {$/;"	f	language:C	signature:(client *c)
replyToBlockedClientTimedOut	server.h	/^void replyToBlockedClientTimedOut(client *c);$/;"	p	language:C	signature:(client *c)
replyWithStatus	module.c	/^int replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {$/;"	f	language:C	signature:(RedisModuleCtx *ctx, const char *msg, char *prefix)
reply_bytes	server.h	/^    unsigned long long reply_bytes; \/* Tot bytes of objects in reply list. *\/$/;"	m	language:C	struct:client	access:public
reply_integer_val	modules/INTRO.md	/^    long long reply_integer_val = RedisModule_CallReplyInteger(reply);$/;"	v	language:C
replylen	config.c	/^    void *replylen = addDeferredMultiBulkLength(c);$/;"	l	language:C
replylen	db.c	/^    void *replylen = addDeferredMultiBulkLength(c);$/;"	l	language:C
replylen	latency.c	/^    void *replylen = addDeferredMultiBulkLength(c);$/;"	l	language:C
replylen	pubsub.c	/^        void *replylen;$/;"	l	language:C
replylen	scripting.c	/^            void *replylen = addDeferredMultiBulkLength(c);$/;"	l	language:C
replylen	t_set.c	/^    void *replylen = NULL;$/;"	l	language:C
replylen	t_zset.c	/^    void *replylen = NULL;$/;"	l	language:C
report	latency.c	/^        sds report = createLatencyReport();$/;"	l	language:C
report	latency.c	/^    sds report = sdsempty();$/;"	l	language:C
reportedConfigEpoch	cluster.c	/^        uint64_t reportedConfigEpoch =$/;"	l	language:C
repr	debug.c	/^            sds repr = sdscatrepr(sdsempty(),o->ptr,sdslen(o->ptr));$/;"	l	language:C
repr1	scripting.c	/^        sds repr1 = sdsempty();$/;"	l	language:C
repr2	scripting.c	/^        sds repr2 = sdsempty();$/;"	l	language:C
representClusterNodeFlags	cluster.c	/^sds representClusterNodeFlags(sds ci, uint16_t flags) {$/;"	f	language:C	signature:(sds ci, uint16_t flags)
representClusterNodeFlags	cluster.c	/^sds representClusterNodeFlags(sds ci, uint16_t flags);$/;"	p	language:C	file:	signature:(sds ci, uint16_t flags)
req_epoch	sentinel.c	/^        long long req_epoch;$/;"	l	language:C
reqlen	ziplist.c	/^    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;$/;"	l	language:C
reqlen	zipmap.c	/^    unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen);$/;"	l	language:C
reqpersec	redis-benchmark.c	/^    float perc, reqpersec;$/;"	l	language:C
reqtype	server.h	/^    int reqtype;            \/* Request protocol type: PROTO_REQ_* *\/$/;"	m	language:C	struct:client	access:public
requestConfigEpoch	cluster.c	/^    uint64_t requestConfigEpoch = ntohu64(request->configEpoch);$/;"	l	language:C
requestCurrentEpoch	cluster.c	/^    uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);$/;"	l	language:C
requests	redis-benchmark.c	/^    int requests;$/;"	m	language:C	struct:config	file:	access:public
requests	redis-cli.c	/^    long aux, requests = 0;$/;"	l	language:C
requests_finished	redis-benchmark.c	/^    int requests_finished;$/;"	m	language:C	struct:config	file:	access:public
requests_issued	redis-benchmark.c	/^    int requests_issued;$/;"	m	language:C	struct:config	file:	access:public
requirepass	server.h	/^    char *requirepass;          \/* Pass for AUTH command, or NULL *\/$/;"	m	language:C	struct:redisServer	access:public
res	bitops.c	/^        uint64_t res = value+incr;$/;"	l	language:C
res	bitops.c	/^    unsigned char *res = NULL; \/* Resulting string. *\/$/;"	l	language:C
res	module.c	/^    int *res = ctx.keys_pos;$/;"	l	language:C
res	notify.c	/^    sds res;$/;"	l	language:C
res	t_zset.c	/^    int res = zslLexValueGteMin(value,spec);$/;"	l	language:C
res	t_zset.c	/^    int res = zslLexValueLteMax(value,spec);$/;"	l	language:C
resB	quicklist.c	/^                size_t resB = sizeof(resultB) \/ sizeof(*resultB);$/;"	l	language:C
reset	sentinel.c	/^    int reset = 0;$/;"	l	language:C
reset	setproctitle.c	/^	_Bool reset;$/;"	m	language:C	struct:__anon37	file:	access:public
resetClient	networking.c	/^void resetClient(client *c) {$/;"	f	language:C	signature:(client *c)
resetClient	redis-benchmark.c	/^static void resetClient(client c) {$/;"	f	language:C	file:	signature:(client c)
resetClient	server.h	/^void resetClient(client *c);$/;"	p	language:C	signature:(client *c)
resetCommandTableStats	server.c	/^void resetCommandTableStats(void) {$/;"	f	language:C	signature:(void)
resetCommandTableStats	server.h	/^void resetCommandTableStats(void);$/;"	p	language:C	signature:(void)
resetManualFailover	cluster.c	/^void resetManualFailover(void) {$/;"	f	language:C	signature:(void)
resetManualFailover	cluster.c	/^void resetManualFailover(void);$/;"	p	language:C	file:	signature:(void)
resetRefCount	object.c	/^robj *resetRefCount(robj *obj) {$/;"	f	language:C	signature:(robj *obj)
resetRefCount	server.h	/^robj *resetRefCount(robj *obj);$/;"	p	language:C	signature:(robj *obj)
resetServerSaveParams	config.c	/^void resetServerSaveParams(void) {$/;"	f	language:C	signature:(void)
resetServerSaveParams	server.h	/^void resetServerSaveParams(void);$/;"	p	language:C	signature:(void)
resetServerStats	server.c	/^void resetServerStats(void) {$/;"	f	language:C	signature:(void)
resetServerStats	server.h	/^void resetServerStats(void);$/;"	p	language:C	signature:(void)
resets	latency.c	/^            int j, resets = 0;$/;"	l	language:C
resets	latency.c	/^    int resets = 0;$/;"	l	language:C
resident_set_size	server.h	/^    size_t resident_set_size;       \/* RSS sampled in serverCron(). *\/$/;"	m	language:C	struct:redisServer	access:public
resizeReplicationBacklog	replication.c	/^void resizeReplicationBacklog(long long newsize) {$/;"	f	language:C	signature:(long long newsize)
resizeReplicationBacklog	server.h	/^void resizeReplicationBacklog(long long newsize);$/;"	p	language:C	signature:(long long newsize)
resize_db	server.c	/^        static unsigned int resize_db = 0;$/;"	l	language:C	file:
resolved	modules/TYPES.md	/^cannot be resolved, since there is no loaded module having this signature,$/;"	v	language:C
restartServer	server.c	/^int restartServer(int flags, mstime_t delay) {$/;"	f	language:C	signature:(int flags, mstime_t delay)
restartServer	server.h	/^int restartServer(int flags, mstime_t delay);$/;"	p	language:C	signature:(int flags, mstime_t delay)
restoreCommand	cluster.c	/^void restoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
restoreCommand	server.h	/^void restoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
result	modules/INTRO.md	/^fetch the result, similarly to how Lua scripts access Redis.$/;"	v	language:C
result	quicklist.c	/^                char *result[] = {"abc", "foo",  "foobar", "foobared",$/;"	l	language:C
result	quicklist.c	/^    static char result[64] = {0};$/;"	l	language:C	file:
result	redis-cli.c	/^        int result = REDIS_OK;$/;"	l	language:C
result	redis-cli.c	/^    char *result;$/;"	l	language:C
result	sentinel.c	/^        int result = sentinelIsQuorumReachable(ri,&usable);$/;"	l	language:C
result	sentinel.c	/^    int result = SENTINEL_ISQR_OK;$/;"	l	language:C
resultB	quicklist.c	/^                char *resultB[] = {"abc",      "foo", "foobar",$/;"	l	language:C
result_length	geo.c	/^    long result_length = ga->used;$/;"	l	language:C
ret	quicklist.c	/^                int ret = quicklistPop(ql, QUICKLIST_HEAD, &data, &sz, &lv);$/;"	l	language:C
ret	quicklist.c	/^    int ret = quicklistPopCustom(quicklist, where, &vstr, &vlen, &vlong,$/;"	l	language:C
ret	rdb.c	/^        int ret;$/;"	l	language:C
ret	syncio.c	/^    ssize_t nwritten, ret = size;$/;"	l	language:C
ret	t_hash.c	/^        int ret;$/;"	l	language:C
ret	t_hash.c	/^    int ret;$/;"	l	language:C
ret	ziplist.c	/^    int64_t i64, ret = 0;$/;"	l	language:C
retflags	module.c	/^    int retflags = 0;$/;"	l	language:C
retflags	t_zset.c	/^        int retflags = flags;$/;"	l	language:C
retmask	ae.c	/^    int retmask = 0, retval;$/;"	l	language:C
retry	replication.c	/^            int retry = 10;$/;"	l	language:C
retry_num	sentinel.c	/^    int retry_num;          \/* Number of times we tried to execute it. *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
returned	modules/API.md	/^type) `REDISMODULE_ERR` is returned, otherwise `REDISMODULE_OK` is returned.$/;"	v	language:C
returned_items	geo.c	/^    long returned_items = (count == 0 || result_length < count) ?$/;"	l	language:C
retval	ae.c	/^            int retval;$/;"	l	language:C
retval	ae.c	/^    int retmask = 0, retval;$/;"	l	language:C
retval	ae_epoll.c	/^    int retval, numevents = 0;$/;"	l	language:C
retval	ae_kqueue.c	/^    int retval, numevents = 0;$/;"	l	language:C
retval	ae_select.c	/^    int retval, j, numevents = 0;$/;"	l	language:C
retval	bitops.c	/^                int64_t oldval, newval, wrapped, retval;$/;"	l	language:C
retval	bitops.c	/^                uint64_t oldval, newval, wrapped, retval;$/;"	l	language:C
retval	cluster.c	/^                int retval;$/;"	l	language:C
retval	cluster.c	/^        int retval = clusterBumpConfigEpochWithoutConsensus();$/;"	l	language:C
retval	cluster.c	/^        int retval = clusterSaveConfig(1);$/;"	l	language:C
retval	cluster.c	/^    int retval;$/;"	l	language:C
retval	config.c	/^            int retval;$/;"	l	language:C
retval	config.c	/^    int retval = 0;$/;"	l	language:C
retval	config.c	/^    int retval;$/;"	l	language:C
retval	db.c	/^    int retval = dictAdd(db->dict, copy, val);$/;"	l	language:C
retval	hyperloglog.c	/^        int retval = hllAdd(o, (unsigned char*)c->argv[j]->ptr,$/;"	l	language:C
retval	module.c	/^    char *retval = b->memory + b->used;$/;"	l	language:C
retval	module.c	/^    int retval = getDoubleFromObject(str,d);$/;"	l	language:C
retval	module.c	/^    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);$/;"	l	language:C
retval	module.c	/^    int retval = rdbLoadLenByRef(io->rio, NULL, &value);$/;"	l	language:C
retval	module.c	/^    int retval = rdbSaveBinaryDoubleValue(io->rio, value);$/;"	l	language:C
retval	module.c	/^    int retval = rdbSaveLen(io->rio, value);$/;"	l	language:C
retval	module.c	/^    int retval = rdbSaveRawString(io->rio,(unsigned char*)str,len);$/;"	l	language:C
retval	module.c	/^    int retval = rdbSaveStringObject(io->rio,s);$/;"	l	language:C
retval	module.c	/^    int retval = selectDb(ctx->client,newid);$/;"	l	language:C
retval	pubsub.c	/^    int retval = 0;$/;"	l	language:C
retval	rdb.c	/^        int retval = rdbSaveLen(rdb,mt->id);$/;"	l	language:C
retval	rdb.c	/^        int retval;$/;"	l	language:C
retval	redis-check-rdb.c	/^    int retval = redis_check_rdb(argv[1]);$/;"	l	language:C
retval	redis-cli.c	/^    int retval = 0;$/;"	l	language:C
retval	redis-cli.c	/^    int retval = REDIS_OK;$/;"	l	language:C
retval	replication.c	/^    int retval;$/;"	l	language:C
retval	rio.c	/^    size_t retval;$/;"	l	language:C
retval	rio.c	/^    ssize_t retval;$/;"	l	language:C
retval	scripting.c	/^        int retval = dictAdd(server.lua_scripts,$/;"	l	language:C
retval	sentinel.c	/^                int retval = sentinelSendSlaveOf(ri,$/;"	l	language:C
retval	sentinel.c	/^            int retval = sentinelSendSlaveOf(ri,$/;"	l	language:C
retval	sentinel.c	/^            int retval;$/;"	l	language:C
retval	sentinel.c	/^        int retval;$/;"	l	language:C
retval	sentinel.c	/^    int retval = redisAsyncCommand(ri->link->cc,$/;"	l	language:C
retval	sentinel.c	/^    int retval;$/;"	l	language:C
retval	server.c	/^        int retval = freeMemoryIfNeeded();$/;"	l	language:C
retval	t_list.c	/^            int retval;$/;"	l	language:C
retval	t_set.c	/^            int retval = DICT_ERR;$/;"	l	language:C
retval	t_zset.c	/^        int retval = zsetAdd(zobj, score, ele, &retflags, &newscore);$/;"	l	language:C
retval1	server.c	/^        int retval1, retval2;$/;"	l	language:C
retval1	t_zset.c	/^            int retval1 = dictDelete(zs->dict,ele);$/;"	l	language:C
retval2	server.c	/^        int retval1, retval2;$/;"	l	language:C
retval2	t_zset.c	/^            int retval2 = zslDelete(zs->zsl,score,ele,NULL);$/;"	l	language:C
rev	dict.c	/^static unsigned long rev(unsigned long v) {$/;"	f	language:C	file:	signature:(unsigned long v)
reverse	quicklist.c	/^    quicklistNode *reverse = quicklist->tail;$/;"	l	language:C
rewriteAppendOnlyFile	aof.c	/^int rewriteAppendOnlyFile(char *filename) {$/;"	f	language:C	signature:(char *filename)
rewriteAppendOnlyFileBackground	aof.c	/^int rewriteAppendOnlyFileBackground(void) {$/;"	f	language:C	signature:(void)
rewriteAppendOnlyFileBackground	server.h	/^int rewriteAppendOnlyFileBackground(void);$/;"	p	language:C	signature:(void)
rewriteClientCommandArgument	networking.c	/^void rewriteClientCommandArgument(client *c, int i, robj *newval) {$/;"	f	language:C	signature:(client *c, int i, robj *newval)
rewriteClientCommandArgument	server.h	/^void rewriteClientCommandArgument(client *c, int i, robj *newval);$/;"	p	language:C	signature:(client *c, int i, robj *newval)
rewriteClientCommandVector	networking.c	/^void rewriteClientCommandVector(client *c, int argc, ...) {$/;"	f	language:C	signature:(client *c, int argc, ...)
rewriteClientCommandVector	server.h	/^void rewriteClientCommandVector(client *c, int argc, ...);$/;"	p	language:C	signature:(client *c, int argc, ...)
rewriteConfig	config.c	/^int rewriteConfig(char *path) {$/;"	f	language:C	signature:(char *path)
rewriteConfig	server.h	/^int rewriteConfig(char *path);$/;"	p	language:C	signature:(char *path)
rewriteConfigAddLineNumberToOption	config.c	/^void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, sds option, int linenum)
rewriteConfigAppendLine	config.c	/^void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, sds line)
rewriteConfigBindOption	config.c	/^void rewriteConfigBindOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigBytesOption	config.c	/^void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, char *option, long long value, long long defvalue)
rewriteConfigClientoutputbufferlimitOption	config.c	/^void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigDirOption	config.c	/^void rewriteConfigDirOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigEnumOption	config.c	/^void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, char *option, int value, configEnum *ce, int defval)
rewriteConfigFormatMemory	config.c	/^int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {$/;"	f	language:C	signature:(char *buf, size_t len, long long bytes)
rewriteConfigGetContentFromState	config.c	/^sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigMarkAsProcessed	config.c	/^void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, const char *option)
rewriteConfigNotifykeyspaceeventsOption	config.c	/^void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigNumericalOption	config.c	/^void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, char *option, long long value, long long defvalue)
rewriteConfigOctalOption	config.c	/^void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, char *option, int value, int defvalue)
rewriteConfigOverwriteFile	config.c	/^int rewriteConfigOverwriteFile(char *configfile, sds content) {$/;"	f	language:C	signature:(char *configfile, sds content)
rewriteConfigReadOldFile	config.c	/^struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {$/;"	f	language:C	signature:(char *path)
rewriteConfigReleaseState	config.c	/^void rewriteConfigReleaseState(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigRemoveOrphaned	config.c	/^void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigRewriteLine	config.c	/^void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, const char *option, sds line, int force)
rewriteConfigRewriteLine	server.h	/^void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force);$/;"	p	language:C	signature:(struct rewriteConfigState *state, const char *option, sds line, int force)
rewriteConfigSaveOption	config.c	/^void rewriteConfigSaveOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigSentinelOption	config.c	/^void rewriteConfigSentinelOption(struct rewriteConfigState *state);$/;"	p	language:C	file:	signature:(struct rewriteConfigState *state)
rewriteConfigSentinelOption	sentinel.c	/^void rewriteConfigSentinelOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigSlaveofOption	config.c	/^void rewriteConfigSlaveofOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigState	config.c	/^struct rewriteConfigState {$/;"	s	language:C	file:
rewriteConfigState	server.h	/^struct rewriteConfigState; \/* Forward declaration to export API. *\/$/;"	x	language:C
rewriteConfigState::has_tail	config.c	/^    int has_tail;         \/* True if we already added directives that were$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
rewriteConfigState::lines	config.c	/^    sds *lines;           \/* Current lines as an array of sds strings *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
rewriteConfigState::numlines	config.c	/^    int numlines;         \/* Number of lines in current config *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
rewriteConfigState::option_to_line	config.c	/^    dict *option_to_line; \/* Option -> list of config file lines map *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
rewriteConfigState::rewritten	config.c	/^    dict *rewritten;      \/* Dictionary of already processed options *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
rewriteConfigStringOption	config.c	/^void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, char *option, char *value, char *defvalue)
rewriteConfigSyslogfacilityOption	config.c	/^void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {$/;"	f	language:C	signature:(struct rewriteConfigState *state)
rewriteConfigYesNoOption	config.c	/^void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {$/;"	f	language:C	signature:(struct rewriteConfigState *state, char *option, int value, int defvalue)
rewriteHashObject	aof.c	/^int rewriteHashObject(rio *r, robj *key, robj *o) {$/;"	f	language:C	signature:(rio *r, robj *key, robj *o)
rewriteListObject	aof.c	/^int rewriteListObject(rio *r, robj *key, robj *o) {$/;"	f	language:C	signature:(rio *r, robj *key, robj *o)
rewriteModuleObject	aof.c	/^int rewriteModuleObject(rio *r, robj *key, robj *o) {$/;"	f	language:C	signature:(rio *r, robj *key, robj *o)
rewriteSetObject	aof.c	/^int rewriteSetObject(rio *r, robj *key, robj *o) {$/;"	f	language:C	signature:(rio *r, robj *key, robj *o)
rewriteSortedSetObject	aof.c	/^int rewriteSortedSetObject(rio *r, robj *key, robj *o) {$/;"	f	language:C	signature:(rio *r, robj *key, robj *o)
rewrite_status	sentinel.c	/^    int rewrite_status;$/;"	l	language:C
rewriting	modules/TYPES.md	/^* A set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the `DEBUG DIGEST` command.$/;"	v	language:C
rewritten	config.c	/^    dict *rewritten;      \/* Dictionary of already processed options *\/$/;"	m	language:C	struct:rewriteConfigState	file:	access:public
rfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
rfileProc	ae.h	/^    aeFileProc *rfileProc;$/;"	m	language:C	struct:aeFileEvent	access:public
rfired	ae.c	/^            int rfired = 0;$/;"	l	language:C
ri	sentinel.c	/^                sentinelRedisInstance *ri;$/;"	l	language:C
ri	sentinel.c	/^            sentinelRedisInstance *ri = dictGetVal(de);$/;"	l	language:C
ri	sentinel.c	/^        sentinelRedisInstance *master, *ri;$/;"	l	language:C
ri	sentinel.c	/^        sentinelRedisInstance *ri = dictGetVal(de);$/;"	l	language:C
ri	sentinel.c	/^        sentinelRedisInstance *ri;$/;"	l	language:C
ri	sentinel.c	/^    sentinelRedisInstance *ri = privdata;$/;"	l	language:C
ri	sentinel.c	/^    sentinelRedisInstance *ri;$/;"	l	language:C
rio	redis-check-rdb.c	/^    rio *rio;$/;"	m	language:C	struct:__anon23	file:	access:public
rio	rio.h	/^typedef struct _rio rio;$/;"	t	language:C	typeref:struct:_rio
rio	server.h	/^    rio *rio;           \/* Rio stream. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
rioBufferFlush	rio.c	/^static int rioBufferFlush(rio *r) {$/;"	f	language:C	file:	signature:(rio *r)
rioBufferIO	rio.c	/^static const rio rioBufferIO = {$/;"	v	language:C	file:
rioBufferRead	rio.c	/^static size_t rioBufferRead(rio *r, void *buf, size_t len) {$/;"	f	language:C	file:	signature:(rio *r, void *buf, size_t len)
rioBufferTell	rio.c	/^static off_t rioBufferTell(rio *r) {$/;"	f	language:C	file:	signature:(rio *r)
rioBufferWrite	rio.c	/^static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {$/;"	f	language:C	file:	signature:(rio *r, const void *buf, size_t len)
rioFdsetFlush	rio.c	/^static int rioFdsetFlush(rio *r) {$/;"	f	language:C	file:	signature:(rio *r)
rioFdsetIO	rio.c	/^static const rio rioFdsetIO = {$/;"	v	language:C	file:
rioFdsetRead	rio.c	/^static size_t rioFdsetRead(rio *r, void *buf, size_t len) {$/;"	f	language:C	file:	signature:(rio *r, void *buf, size_t len)
rioFdsetTell	rio.c	/^static off_t rioFdsetTell(rio *r) {$/;"	f	language:C	file:	signature:(rio *r)
rioFdsetWrite	rio.c	/^static size_t rioFdsetWrite(rio *r, const void *buf, size_t len) {$/;"	f	language:C	file:	signature:(rio *r, const void *buf, size_t len)
rioFileFlush	rio.c	/^static int rioFileFlush(rio *r) {$/;"	f	language:C	file:	signature:(rio *r)
rioFileIO	rio.c	/^static const rio rioFileIO = {$/;"	v	language:C	file:
rioFileRead	rio.c	/^static size_t rioFileRead(rio *r, void *buf, size_t len) {$/;"	f	language:C	file:	signature:(rio *r, void *buf, size_t len)
rioFileTell	rio.c	/^static off_t rioFileTell(rio *r) {$/;"	f	language:C	file:	signature:(rio *r)
rioFileWrite	rio.c	/^static size_t rioFileWrite(rio *r, const void *buf, size_t len) {$/;"	f	language:C	file:	signature:(rio *r, const void *buf, size_t len)
rioFlush	rio.h	/^static inline int rioFlush(rio *r) {$/;"	f	language:C	signature:(rio *r)
rioFreeFdset	rio.c	/^void rioFreeFdset(rio *r) {$/;"	f	language:C	signature:(rio *r)
rioFreeFdset	rio.h	/^void rioFreeFdset(rio *r);$/;"	p	language:C	signature:(rio *r)
rioGenericUpdateChecksum	rio.c	/^void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {$/;"	f	language:C	signature:(rio *r, const void *buf, size_t len)
rioGenericUpdateChecksum	rio.h	/^void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len);$/;"	p	language:C	signature:(rio *r, const void *buf, size_t len)
rioInitWithBuffer	rio.c	/^void rioInitWithBuffer(rio *r, sds s) {$/;"	f	language:C	signature:(rio *r, sds s)
rioInitWithBuffer	rio.h	/^void rioInitWithBuffer(rio *r, sds s);$/;"	p	language:C	signature:(rio *r, sds s)
rioInitWithFdset	rio.c	/^void rioInitWithFdset(rio *r, int *fds, int numfds) {$/;"	f	language:C	signature:(rio *r, int *fds, int numfds)
rioInitWithFdset	rio.h	/^void rioInitWithFdset(rio *r, int *fds, int numfds);$/;"	p	language:C	signature:(rio *r, int *fds, int numfds)
rioInitWithFile	rio.c	/^void rioInitWithFile(rio *r, FILE *fp) {$/;"	f	language:C	signature:(rio *r, FILE *fp)
rioInitWithFile	rio.h	/^void rioInitWithFile(rio *r, FILE *fp);$/;"	p	language:C	signature:(rio *r, FILE *fp)
rioRead	rio.h	/^static inline size_t rioRead(rio *r, void *buf, size_t len) {$/;"	f	language:C	signature:(rio *r, void *buf, size_t len)
rioSetAutoSync	rio.c	/^void rioSetAutoSync(rio *r, off_t bytes) {$/;"	f	language:C	signature:(rio *r, off_t bytes)
rioSetAutoSync	rio.h	/^void rioSetAutoSync(rio *r, off_t bytes);$/;"	p	language:C	signature:(rio *r, off_t bytes)
rioTell	rio.h	/^static inline off_t rioTell(rio *r) {$/;"	f	language:C	signature:(rio *r)
rioWrite	rio.h	/^static inline size_t rioWrite(rio *r, const void *buf, size_t len) {$/;"	f	language:C	signature:(rio *r, const void *buf, size_t len)
rioWriteBulkCount	rio.c	/^size_t rioWriteBulkCount(rio *r, char prefix, int count) {$/;"	f	language:C	signature:(rio *r, char prefix, int count)
rioWriteBulkCount	rio.h	/^size_t rioWriteBulkCount(rio *r, char prefix, int count);$/;"	p	language:C	signature:(rio *r, char prefix, int count)
rioWriteBulkDouble	rio.c	/^size_t rioWriteBulkDouble(rio *r, double d) {$/;"	f	language:C	signature:(rio *r, double d)
rioWriteBulkDouble	rio.h	/^size_t rioWriteBulkDouble(rio *r, double d);$/;"	p	language:C	signature:(rio *r, double d)
rioWriteBulkLongLong	rio.c	/^size_t rioWriteBulkLongLong(rio *r, long long l) {$/;"	f	language:C	signature:(rio *r, long long l)
rioWriteBulkLongLong	rio.h	/^size_t rioWriteBulkLongLong(rio *r, long long l);$/;"	p	language:C	signature:(rio *r, long long l)
rioWriteBulkObject	aof.c	/^int rioWriteBulkObject(rio *r, robj *obj) {$/;"	f	language:C	signature:(rio *r, robj *obj)
rioWriteBulkObject	rio.h	/^int rioWriteBulkObject(rio *r, struct redisObject *obj);$/;"	p	language:C	signature:(rio *r, struct redisObject *obj)
rioWriteBulkString	rio.c	/^size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {$/;"	f	language:C	signature:(rio *r, const char *buf, size_t len)
rioWriteBulkString	rio.h	/^size_t rioWriteBulkString(rio *r, const char *buf, size_t len);$/;"	p	language:C	signature:(rio *r, const char *buf, size_t len)
rioWriteHashIteratorCursor	aof.c	/^static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {$/;"	f	language:C	file:	signature:(rio *r, hashTypeIterator *hi, int what)
riting	modules/API.md	/^If the key is open for writing, remove it, and setup the key to$/;"	v	language:C
riting	modules/API.md	/^If the key is open for writing, set the specified module type object$/;"	v	language:C
riting	modules/API.md	/^If the key is open for writing, set the specified string 'str' as the$/;"	v	language:C
riting	modules/API.md	/^error, that is, the key is not open for writing, is not a string$/;"	v	language:C
riting	modules/TYPES.md	/^for writing, and gets three arguments: the key handle, the reference to the$/;"	v	language:C
rl	t_list.c	/^            readyList *rl = ln->value;$/;"	l	language:C
rl	t_list.c	/^    readyList *rl;$/;"	l	language:C
rloopr	quicklist.c	/^    int rloopr = itrprintr_rev(ql, 0);$/;"	l	language:C
robj	server.h	/^} robj;$/;"	t	language:C	typeref:struct:redisObject
rol	sha1.c	/^#define rol(/;"	d	language:C	file:
role	sentinel.c	/^    int role = 0;$/;"	l	language:C
roleCommand	replication.c	/^void roleCommand(client *c) {$/;"	f	language:C	signature:(client *c)
roleCommand	server.h	/^void roleCommand(client *c);$/;"	p	language:C	signature:(client *c)
role_char	server.c	/^        int role_char;$/;"	l	language:C
role_reported	sentinel.c	/^    int role_reported;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
role_reported_time	sentinel.c	/^    mstime_t role_reported_time;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
rop	server.c	/^        redisOp *rop;$/;"	l	language:C
roslaveerr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
rout	memtest.c	/^    uint64_t rout = 0;$/;"	l	language:C
row	sparkline.c	/^    int row = 0;$/;"	l	language:C
rpop	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
rpopCommand	server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
rpopCommand	server.h	/^void rpopCommand(client *c);$/;"	p	language:C	signature:(client *c)
rpopCommand	t_list.c	/^void rpopCommand(client *c) {$/;"	f	language:C	signature:(client *c)
rpoplpushCommand	server.h	/^void rpoplpushCommand(client *c);$/;"	p	language:C	signature:(client *c)
rpoplpushCommand	t_list.c	/^void rpoplpushCommand(client *c) {$/;"	f	language:C	signature:(client *c)
rpoplpushHandlePush	t_list.c	/^void rpoplpushHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value) {$/;"	f	language:C	signature:(client *c, robj *dstkey, robj *dstobj, robj *value)
rps	redis-benchmark.c	/^    float rps = (float)config.requests_finished\/dt;$/;"	l	language:C
rpushCommand	server.h	/^void rpushCommand(client *c);$/;"	p	language:C	signature:(client *c)
rpushCommand	t_list.c	/^void rpushCommand(client *c) {$/;"	f	language:C	signature:(client *c)
rpushxCommand	server.h	/^void rpushxCommand(client *c);$/;"	p	language:C	signature:(client *c)
rpushxCommand	t_list.c	/^void rpushxCommand(client *c) {$/;"	f	language:C	signature:(client *c)
rseed	memtest.c	/^    uint64_t rseed = UINT64_C(0xd13133de9afdb566); \/* Just a random seed. *\/$/;"	l	language:C
rss	zmalloc.c	/^    size_t rss;$/;"	l	language:C
rtrim	t_list.c	/^    long start, end, llen, ltrim, rtrim;$/;"	l	language:C
rue	modules/API.md	/^'minex' and 'maxex' parameters, if true, respectively setup a range$/;"	v	language:C
run_time	redis-cli.c	/^    long long test_end, run_time, max_latency = 0, runs = 0;$/;"	l	language:C
run_with_period	server.h	/^#define run_with_period(/;"	d	language:C
runid	replication.c	/^        char *runid = NULL, *offset = NULL;$/;"	l	language:C
runid	sentinel.c	/^    char *runid;    \/* Run ID of this instance, or unique ID if is a Sentinel.*\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
runid	sentinel.c	/^    char *runid;$/;"	m	language:C	struct:sentinelLeader	file:	access:public
runid	server.h	/^    char runid[CONFIG_RUN_ID_SIZE+1];  \/* ID always different at every exec. *\/$/;"	m	language:C	struct:redisServer	access:public
runlen	hyperloglog.c	/^            int runlen, regval;$/;"	l	language:C
runlen	hyperloglog.c	/^        long runlen, regval;$/;"	l	language:C
runlen	hyperloglog.c	/^    int ez = 0, idx = 0, runlen, regval;$/;"	l	language:C
runlen	hyperloglog.c	/^    int idx = 0, runlen, regval;$/;"	l	language:C
runlen	hyperloglog.c	/^    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;$/;"	l	language:C
running_scripts	sentinel.c	/^    int running_scripts;    \/* Number of scripts in execution right now. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
runs	redis-cli.c	/^    long long test_end, run_time, max_latency = 0, runs = 0;$/;"	l	language:C
runtime	quicklist.c	/^    long long runtime[option_count];$/;"	l	language:C
rv	ae_evport.c	/^    int rv, err;$/;"	l	language:C
rv	anet.c	/^    int rv;$/;"	l	language:C
rv	anet.c	/^    int s = ANET_ERR, rv;$/;"	l	language:C
rv	anet.c	/^    int s, rv;$/;"	l	language:C
s	anet.c	/^        struct sockaddr_in *s = (struct sockaddr_in *)&sa;$/;"	l	language:C
s	anet.c	/^        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;$/;"	l	language:C
s	anet.c	/^    int s = ANET_ERR, rv;$/;"	l	language:C
s	anet.c	/^    int s, rv;$/;"	l	language:C
s	anet.c	/^    int s;$/;"	l	language:C
s	cluster.c	/^        char *p, *s;$/;"	l	language:C
s	cluster.c	/^    int s, e; \/* start-end indexes of { and } *\/$/;"	l	language:C
s	cluster.c	/^    sds s = sdsnewlen(name, CLUSTER_NAMELEN);$/;"	l	language:C
s	cluster.c	/^    sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);$/;"	l	language:C
s	debug.c	/^    char *s = ptr;$/;"	l	language:C
s	debug.c	/^    unsigned char hash[20], *s = ptr;$/;"	l	language:C
s	dict.c	/^    unsigned long s = 8 * sizeof(v); \/\/ bit size; must be power of 2$/;"	l	language:C
s	hyperloglog.c	/^    sds s;$/;"	l	language:C
s	module.c	/^    void *s = rdbGenericLoadStringObject(io->rio,$/;"	l	language:C
s	modules/helloworld.c	/^        char *s = RedisModule_StringDMA(key,&len,REDISMODULE_WRITE);$/;"	l	language:C
s	modules/helloworld.c	/^        const char *s = RedisModule_StringPtrLen(argv[j],NULL);$/;"	l	language:C
s	modules/testmodule.c	/^    RedisModuleString *s = RedisModule_CreateString(ctx,"foo",3);$/;"	l	language:C
s	networking.c	/^            sds s = sdsdup(o->ptr);$/;"	l	language:C
s	networking.c	/^        sds s = sdsdup(o->ptr);$/;"	l	language:C
s	networking.c	/^    sds s = sdscatvprintf(sdsempty(),fmt,ap);$/;"	l	language:C
s	object.c	/^    sds s = o->ptr;$/;"	l	language:C
s	redis-cli.c	/^        char *p = reply->str, *s;$/;"	l	language:C
s	redis-cli.c	/^    int s = context->fd;$/;"	l	language:C
s	redis-cli.c	/^    unsigned char s[256], i, j, t;$/;"	l	language:C
s	scripting.c	/^            sds s = cached_objects[j]->ptr;$/;"	l	language:C
s	scripting.c	/^            sds s = o->ptr;$/;"	l	language:C
s	scripting.c	/^        char *s;$/;"	l	language:C
s	scripting.c	/^    char *s;$/;"	l	language:C
s	scripting.c	/^    char *s[32];$/;"	l	language:C
s	scripting.c	/^    sds s = sdsnew(prefix);$/;"	l	language:C
s	sds.c	/^    sds s;$/;"	l	language:C
s	slowlog.c	/^                sds s = sdsnewlen(argv[j]->ptr, SLOWLOG_ENTRY_MAX_STRING);$/;"	l	language:C
s	sparkline.c	/^            struct sample *s = &seq->samples[j+offset];$/;"	l	language:C
s	t_zset.c	/^    double s;$/;"	l	language:C
s64	dict.h	/^        int64_t s64;$/;"	m	language:C	union:dictEntry::__anon12	access:public
s_down_since_time	sentinel.c	/^    mstime_t s_down_since_time; \/* Subjectively down since time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
s_free	sdsalloc.h	/^#define s_free /;"	d	language:C
s_malloc	sdsalloc.h	/^#define s_malloc /;"	d	language:C
s_realloc	sdsalloc.h	/^#define s_realloc /;"	d	language:C
sa	anet.c	/^        struct sockaddr_in *sa = (struct sockaddr_in *)info->ai_addr;$/;"	l	language:C
sa	anet.c	/^        struct sockaddr_in6 *sa = (struct sockaddr_in6 *)info->ai_addr;$/;"	l	language:C
sa	anet.c	/^    struct sockaddr_storage sa;$/;"	l	language:C
sa	anet.c	/^    struct sockaddr_un sa;$/;"	l	language:C
sa	cluster.c	/^    struct sockaddr_storage sa;$/;"	l	language:C
sa	sentinel.c	/^    sentinelAddr *sa;$/;"	l	language:C
sa	sentinel.c	/^    sentinelRedisInstance **sa = (sentinelRedisInstance **)a,$/;"	l	language:C
sa_runid	sentinel.c	/^    char *sa_runid, *sb_runid;$/;"	l	language:C
saddCommand	server.h	/^void saddCommand(client *c);$/;"	p	language:C	signature:(client *c)
saddCommand	t_set.c	/^void saddCommand(client *c) {$/;"	f	language:C	signature:(client *c)
safe	dict.h	/^    int table, safe;$/;"	m	language:C	struct:dictIterator	access:public
salen	anet.c	/^    socklen_t salen = sizeof(sa);$/;"	l	language:C
samekey	db.c	/^    int samekey = 0;$/;"	l	language:C
sameobjecterr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sample	sparkline.h	/^struct sample {$/;"	s	language:C
sample::label	sparkline.h	/^    char *label;$/;"	m	language:C	struct:sample	access:public
sample::value	sparkline.h	/^    double value;$/;"	m	language:C	struct:sample	access:public
sampled	redis-cli.c	/^    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;$/;"	l	language:C
samples	evict.c	/^    dictEntry *samples[server.maxmemory_samples];$/;"	l	language:C
samples	latency.c	/^    int samples = 0, j;$/;"	l	language:C
samples	latency.h	/^    struct latencySample samples[LATENCY_TS_LEN]; \/* Latest history. *\/$/;"	m	language:C	struct:latencyTimeSeries	typeref:struct:latencyTimeSeries::latencySample	access:public
samples	latency.h	/^    uint32_t samples;       \/* Number of non-zero samples. *\/$/;"	m	language:C	struct:latencyStats	access:public
samples	redis-cli.c	/^    struct distsamples samples[] = {$/;"	l	language:C
samples	server.h	/^        long long samples[STATS_METRIC_SAMPLES];$/;"	m	language:C	struct:redisServer::__anon29	access:public
samples	sparkline.h	/^    struct sample *samples;$/;"	m	language:C	struct:sequence	typeref:struct:sequence::sample	access:public
save	server.c	/^    int save = flags & SHUTDOWN_SAVE;$/;"	l	language:C
saveCommand	rdb.c	/^void saveCommand(client *c) {$/;"	f	language:C	signature:(client *c)
saveCommand	server.h	/^void saveCommand(client *c);$/;"	p	language:C	signature:(client *c)
saveconf	cluster.c	/^    int saveconf = 0;$/;"	l	language:C
saved_dirty	db.c	/^        int saved_dirty = server.dirty;$/;"	l	language:C
saved_hz	sentinel.c	/^    int saved_hz = server.hz;$/;"	l	language:C
saved_lru	db.c	/^        int saved_lru = old->lru;$/;"	l	language:C
saved_next	module.c	/^                unsigned char *saved_next = next;$/;"	l	language:C
saved_prev	module.c	/^                unsigned char *saved_prev = prev;$/;"	l	language:C
saved_rc	scripting.c	/^    int j, saved_rc = server.lua_replicate_commands;$/;"	l	language:C
saveparam	server.h	/^struct saveparam {$/;"	s	language:C
saveparam::changes	server.h	/^    int changes;$/;"	m	language:C	struct:saveparam	access:public
saveparam::seconds	server.h	/^    time_t seconds;$/;"	m	language:C	struct:saveparam	access:public
saveparams	server.h	/^    struct saveparam *saveparams;   \/* Save points array for RDB *\/$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::saveparam	access:public
saveparamslen	server.h	/^    int saveparamslen;              \/* Number of saving points *\/$/;"	m	language:C	struct:redisServer	access:public
sb	aof.c	/^    struct redis_stat sb;$/;"	l	language:C
sb	cluster.c	/^    struct stat sb;$/;"	l	language:C
sb	config.c	/^    struct stat sb;$/;"	l	language:C
sb	rdb.c	/^    struct stat sb;$/;"	l	language:C
sb	redis-check-aof.c	/^    struct redis_stat sb;$/;"	l	language:C
sb	sentinel.c	/^                          **sb = (sentinelRedisInstance **)b;$/;"	l	language:C
sb_runid	sentinel.c	/^    char *sa_runid, *sb_runid;$/;"	l	language:C
sbuf	networking.c	/^    char dbuf[128], sbuf[128];$/;"	l	language:C
scanCallback	db.c	/^void scanCallback(void *privdata, const dictEntry *de) {$/;"	f	language:C	signature:(void *privdata, const dictEntry *de)
scanCommand	db.c	/^void scanCommand(client *c) {$/;"	f	language:C	signature:(client *c)
scanCommand	server.h	/^void scanCommand(client *c);$/;"	p	language:C	signature:(client *c)
scanGenericCommand	db.c	/^void scanGenericCommand(client *c, robj *o, unsigned long cursor) {$/;"	f	language:C	signature:(client *c, robj *o, unsigned long cursor)
scanGenericCommand	server.h	/^void scanGenericCommand(client *c, robj *o, unsigned long cursor);$/;"	p	language:C	signature:(client *c, robj *o, unsigned long cursor)
scanMode	redis-cli.c	/^static void scanMode(void) {$/;"	f	language:C	file:	signature:(void)
scan_mode	redis-cli.c	/^    int scan_mode;$/;"	m	language:C	struct:config	file:	access:public
scanlen	hyperloglog.c	/^    int scanlen = 5; \/* Scan up to 5 upcodes starting from prev. *\/$/;"	l	language:C
scardCommand	server.h	/^void scardCommand(client *c);$/;"	p	language:C	signature:(client *c)
scardCommand	t_set.c	/^void scardCommand(client *c) {$/;"	f	language:C	signature:(client *c)
schedule	rdb.c	/^    int schedule = 0;$/;"	l	language:C
score	aof.c	/^            double *score = dictGetVal(de);$/;"	l	language:C
score	aof.c	/^        double score;$/;"	l	language:C
score	debug.c	/^                        double *score = dictGetVal(de);$/;"	l	language:C
score	debug.c	/^                    double score;$/;"	l	language:C
score	geo.c	/^            double score = storedist ? gp->dist : gp->score;$/;"	l	language:C
score	geo.c	/^        double score = 0;$/;"	l	language:C
score	geo.c	/^        double score;$/;"	l	language:C
score	geo.c	/^        robj *score = createObject(OBJ_STRING, sdsfromlonglong(bits));$/;"	l	language:C
score	geo.c	/^    double score = 0;$/;"	l	language:C
score	geo.h	/^    double score;$/;"	m	language:C	struct:geoPoint	access:public
score	module.c	/^                double score = zzlGetScore(next); \/* Obtain the next score. *\/$/;"	l	language:C
score	module.c	/^                double score = zzlGetScore(prev); \/* Obtain the prev score. *\/$/;"	l	language:C
score	modules/API.md	/^a new score, the score of the existing element is incremented, or if the$/;"	v	language:C
score	modules/helloworld.c	/^        double score;$/;"	l	language:C
score	rdb.c	/^                double *score = dictGetVal(de);$/;"	l	language:C
score	rdb.c	/^            double score;$/;"	l	language:C
score	server.h	/^        double score;$/;"	m	language:C	union:_redisSortObject::__anon30	access:public
score	server.h	/^    double score;$/;"	m	language:C	struct:zskiplistNode	access:public
score	t_zset.c	/^                double score, value;$/;"	l	language:C
score	t_zset.c	/^        double score;$/;"	l	language:C
score	t_zset.c	/^    double score = 0, *scores = NULL;$/;"	l	language:C
score	t_zset.c	/^    double score;$/;"	l	language:C
score	t_zset.c	/^    double score;$/;"	m	language:C	struct:__anon46	file:	access:public
score1	geo.c	/^    double score1, score2, xyxy[4];$/;"	l	language:C
score2	geo.c	/^    double score1, score2, xyxy[4];$/;"	l	language:C
score_end	modules/helloworld.c	/^    double score_start, score_end;$/;"	l	language:C
score_start	modules/helloworld.c	/^    double score_start, score_end;$/;"	l	language:C
scorebuf	t_zset.c	/^    char scorebuf[128];$/;"	l	language:C
scoreidx	t_zset.c	/^    int scoreidx = 0;$/;"	l	language:C
scorelen	t_zset.c	/^    int scorelen;$/;"	l	language:C
scores	t_zset.c	/^    double score = 0, *scores = NULL;$/;"	l	language:C
scoresOfGeoHashBox	geo.c	/^void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max) {$/;"	f	language:C	signature:(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max)
scoresum_a	modules/helloworld.c	/^    double scoresum_a = 0;$/;"	l	language:C
scoresum_b	modules/helloworld.c	/^    double scoresum_b = 0;$/;"	l	language:C
script	redis-cli.c	/^    sds script = NULL;$/;"	l	language:C
script	scripting.c	/^            robj *script = dictFetchValue(server.lua_scripts,c->argv[1]->ptr);$/;"	l	language:C
scriptCommand	scripting.c	/^void scriptCommand(client *c) {$/;"	f	language:C	signature:(client *c)
scriptCommand	server.h	/^void scriptCommand(client *c);$/;"	p	language:C	signature:(client *c)
scriptingEnableGlobalsProtection	scripting.c	/^void scriptingEnableGlobalsProtection(lua_State *lua) {$/;"	f	language:C	signature:(lua_State *lua)
scriptingInit	scripting.c	/^void scriptingInit(int setup) {$/;"	f	language:C	signature:(int setup)
scriptingInit	server.h	/^void scriptingInit(int setup);$/;"	p	language:C	signature:(int setup)
scriptingRelease	scripting.c	/^void scriptingRelease(void) {$/;"	f	language:C	signature:(void)
scriptingReset	scripting.c	/^void scriptingReset(void) {$/;"	f	language:C	signature:(void)
scripts_queue	sentinel.c	/^    list *scripts_queue;            \/* Queue of user scripts to execute. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sde	sentinel.c	/^            dictEntry *sde;$/;"	l	language:C
sdi	sentinel.c	/^            dictIterator *sdi;$/;"	l	language:C
sdiffCommand	server.h	/^void sdiffCommand(client *c);$/;"	p	language:C	signature:(client *c)
sdiffCommand	t_set.c	/^void sdiffCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sdiffstoreCommand	server.h	/^void sdiffstoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
sdiffstoreCommand	t_set.c	/^void sdiffstoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sdigits10	util.c	/^uint32_t sdigits10(int64_t v) {$/;"	f	language:C	signature:(int64_t v)
sdigits10	util.h	/^uint32_t sdigits10(int64_t v);$/;"	p	language:C	signature:(int64_t v)
sds	rdb.c	/^    int sds = flags & RDB_LOAD_SDS;$/;"	l	language:C
sds	redis-cli.c	/^  char **sds = zmalloc(sizeof(char*)*count);$/;"	l	language:C
sds	sds.h	/^typedef char *sds;$/;"	t	language:C
sdsAllocPtr	sds.c	/^void *sdsAllocPtr(sds s) {$/;"	f	language:C	signature:(sds s)
sdsAllocPtr	sds.h	/^void *sdsAllocPtr(sds s);$/;"	p	language:C	signature:(sds s)
sdsAllocSize	sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f	language:C	signature:(sds s)
sdsAllocSize	sds.h	/^size_t sdsAllocSize(sds s);$/;"	p	language:C	signature:(sds s)
sdsCatColorizedLdbReply	redis-cli.c	/^sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {$/;"	f	language:C	signature:(sds o, char *s, size_t len)
sdsEncodedObject	server.h	/^#define sdsEncodedObject(/;"	d	language:C
sdsHdrSize	sds.c	/^static inline int sdsHdrSize(char type) {$/;"	f	language:C	file:	signature:(char type)
sdsIncrLen	sds.c	/^void sdsIncrLen(sds s, int incr) {$/;"	f	language:C	signature:(sds s, int incr)
sdsIncrLen	sds.h	/^void sdsIncrLen(sds s, int incr);$/;"	p	language:C	signature:(sds s, int incr)
sdsMakeRoomFor	sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f	language:C	signature:(sds s, size_t addlen)
sdsMakeRoomFor	sds.h	/^sds sdsMakeRoomFor(sds s, size_t addlen);$/;"	p	language:C	signature:(sds s, size_t addlen)
sdsRemoveFreeSpace	sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f	language:C	signature:(sds s)
sdsRemoveFreeSpace	sds.h	/^sds sdsRemoveFreeSpace(sds s);$/;"	p	language:C	signature:(sds s)
sdsReqType	sds.c	/^static inline char sdsReqType(size_t string_size) {$/;"	f	language:C	file:	signature:(size_t string_size)
sdsTest	sds.c	/^int sdsTest(void) {$/;"	f	language:C	signature:(void)
sdsTest	sds.h	/^int sdsTest(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
sdsZmallocSize	networking.c	/^size_t sdsZmallocSize(sds s) {$/;"	f	language:C	signature:(sds s)
sds_free	sds.c	/^void sds_free(void *ptr) { s_free(ptr); }$/;"	f	language:C	signature:(void *ptr)
sds_free	sds.h	/^void sds_free(void *ptr);$/;"	p	language:C	signature:(void *ptr)
sds_malloc	sds.c	/^void *sds_malloc(size_t size) { return s_malloc(size); }$/;"	f	language:C	signature:(size_t size)
sds_malloc	sds.h	/^void *sds_malloc(size_t size);$/;"	p	language:C	signature:(size_t size)
sds_realloc	sds.c	/^void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }$/;"	f	language:C	signature:(void *ptr, size_t size)
sds_realloc	sds.h	/^void *sds_realloc(void *ptr, size_t size);$/;"	p	language:C	signature:(void *ptr, size_t size)
sdsalloc	sds.h	/^static inline size_t sdsalloc(const sds s) {$/;"	f	language:C	signature:(const sds s)
sdsavail	sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f	language:C	signature:(const sds s)
sdscat	sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f	language:C	signature:(sds s, const char *t)
sdscat	sds.h	/^sds sdscat(sds s, const char *t);$/;"	p	language:C	signature:(sds s, const char *t)
sdscatcolor	redis-cli.c	/^sds sdscatcolor(sds o, char *s, size_t len, char *color) {$/;"	f	language:C	signature:(sds o, char *s, size_t len, char *color)
sdscatfmt	sds.c	/^sds sdscatfmt(sds s, char const *fmt, ...) {$/;"	f	language:C	signature:(sds s, char const *fmt, ...)
sdscatfmt	sds.h	/^sds sdscatfmt(sds s, char const *fmt, ...);$/;"	p	language:C	signature:(sds s, char const *fmt, ...)
sdscatlen	.sds.h.swp	/^/;"	p	language:C	file:	signature:(sds s, const void *t, size_t len)
sdscatlen	sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f	language:C	signature:(sds s, const void *t, size_t len)
sdscatlen	sds.h	/^sds sdscatlen(sds s, const void *t, size_t len);$/;"	p	language:C	signature:(sds s, const void *t, size_t len)
sdscatprintf	scripting.c	/^        ldbLog(sdscatprintf(sdsempty(),"<value> replies are unlimited."));$/;"	p	language:C	file:	signature:(sdsempty(
sdscatprintf	sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f	language:C	signature:(sds s, const char *fmt, ...)
sdscatprintf	sds.h	/^sds sdscatprintf(sds s, const char *fmt, ...)$/;"	p	language:C	signature:(sds s, const char *fmt, ...)
sdscatprintf	sds.h	/^sds sdscatprintf(sds s, const char *fmt, ...);$/;"	p	language:C	signature:(sds s, const char *fmt, ...)
sdscatrepr	sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f	language:C	signature:(sds s, const char *p, size_t len)
sdscatrepr	sds.h	/^sds sdscatrepr(sds s, const char *p, size_t len);$/;"	p	language:C	signature:(sds s, const char *p, size_t len)
sdscatsds	sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f	language:C	signature:(sds s, const sds t)
sdscatsds	sds.h	/^sds sdscatsds(sds s, const sds t);$/;"	p	language:C	signature:(sds s, const sds t)
sdscatvprintf	sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f	language:C	signature:(sds s, const char *fmt, va_list ap)
sdscatvprintf	sds.h	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap);$/;"	p	language:C	signature:(sds s, const char *fmt, va_list ap)
sdsclear	sds.c	/^void sdsclear(sds s) {$/;"	f	language:C	signature:(sds s)
sdsclear	sds.h	/^void sdsclear(sds s);$/;"	p	language:C	signature:(sds s)
sdscmp	sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f	language:C	signature:(const sds s1, const sds s2)
sdscmp	sds.h	/^int sdscmp(const sds s1, const sds s2);$/;"	p	language:C	signature:(const sds s1, const sds s2)
sdscmplex	t_zset.c	/^int sdscmplex(sds a, sds b) {$/;"	f	language:C	signature:(sds a, sds b)
sdscpy	sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f	language:C	signature:(sds s, const char *t)
sdscpy	sds.h	/^sds sdscpy(sds s, const char *t);$/;"	p	language:C	signature:(sds s, const char *t)
sdscpylen	sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f	language:C	signature:(sds s, const char *t, size_t len)
sdscpylen	sds.h	/^sds sdscpylen(sds s, const char *t, size_t len);$/;"	p	language:C	signature:(sds s, const char *t, size_t len)
sdsdup	.sds.h.swp	/^/;"	p	language:C	file:	signature:(const sds s)
sdsdup	sds.c	/^sds sdsdup(const sds s) {$/;"	f	language:C	signature:(const sds s)
sdsdup	sds.h	/^sds sdsdup(const sds s);$/;"	p	language:C	signature:(const sds s)
sdsele	debug.c	/^                        sds sdsele = dictGetKey(de);$/;"	l	language:C
sdsele	debug.c	/^                    sds sdsele;$/;"	l	language:C
sdsele	debug.c	/^                sds sdsele;$/;"	l	language:C
sdsele	rdb.c	/^            sds sdsele;$/;"	l	language:C
sdsele	sort.c	/^        sds sdsele;$/;"	l	language:C
sdsele	t_set.c	/^    sds sdsele;$/;"	l	language:C
sdsempty	.sds.h.swp	/^/;"	p	language:C	file:	signature:(void)
sdsempty	sds.c	/^sds sdsempty(void) {$/;"	f	language:C	signature:(void)
sdsempty	sds.h	/^sds sdsempty(void);$/;"	p	language:C	signature:(void)
sdsfree	.sds.h.swp	/^/;"	p	language:C	file:	signature:(sds s)
sdsfree	sds.c	/^void sdsfree(sds s) {$/;"	f	language:C	signature:(sds s)
sdsfree	sds.h	/^void sdsfree(sds s);$/;"	p	language:C	signature:(sds s)
sdsfreesplitres	sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f	language:C	signature:(sds *tokens, int count)
sdsfreesplitres	sds.h	/^void sdsfreesplitres(sds *tokens, int count);$/;"	p	language:C	signature:(sds *tokens, int count)
sdsfromlonglong	sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f	language:C	signature:(long long value)
sdsfromlonglong	sds.h	/^sds sdsfromlonglong(long long value);$/;"	p	language:C	signature:(long long value)
sdsgrowzero	.sds.h.swp	/^/;"	p	language:C	file:	signature:(sds s, size_t len)
sdsgrowzero	sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f	language:C	signature:(sds s, size_t len)
sdsgrowzero	sds.h	/^sds sdsgrowzero(sds s, size_t len);$/;"	p	language:C	signature:(sds s, size_t len)
sdshdr16	sds.h	/^struct __attribute__ ((__packed__)) sdshdr16 {$/;"	s	language:C
sdshdr16::alloc	sds.h	/^    uint16_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr16	access:public
sdshdr16::buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr16	access:public
sdshdr16::flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr16	access:public
sdshdr16::len	sds.h	/^    uint16_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr16	access:public
sdshdr32	sds.h	/^struct __attribute__ ((__packed__)) sdshdr32 {$/;"	s	language:C
sdshdr32::alloc	sds.h	/^    uint32_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr32	access:public
sdshdr32::buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr32	access:public
sdshdr32::flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr32	access:public
sdshdr32::len	sds.h	/^    uint32_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr32	access:public
sdshdr5	sds.h	/^struct __attribute__ ((__packed__)) sdshdr5 {$/;"	s	language:C
sdshdr5::buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr5	access:public
sdshdr5::flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, and 5 msb of string length *\/$/;"	m	language:C	struct:sdshdr5	access:public
sdshdr64	sds.h	/^struct __attribute__ ((__packed__)) sdshdr64 {$/;"	s	language:C
sdshdr64::alloc	sds.h	/^    uint64_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr64	access:public
sdshdr64::buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr64	access:public
sdshdr64::flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr64	access:public
sdshdr64::len	sds.h	/^    uint64_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr64	access:public
sdshdr8	sds.h	/^struct __attribute__ ((__packed__)) sdshdr8 {$/;"	s	language:C
sdshdr8::alloc	sds.h	/^    uint8_t alloc; \/* excluding the header and null terminator *\/$/;"	m	language:C	struct:sdshdr8	access:public
sdshdr8::buf	sds.h	/^    char buf[];$/;"	m	language:C	struct:sdshdr8	access:public
sdshdr8::flags	sds.h	/^    unsigned char flags; \/* 3 lsb of type, 5 unused bits *\/$/;"	m	language:C	struct:sdshdr8	access:public
sdshdr8::len	sds.h	/^    uint8_t len; \/* used *\/$/;"	m	language:C	struct:sdshdr8	access:public
sdsinclen	sds.h	/^static inline void sdsinclen(sds s, size_t inc) {$/;"	f	language:C	signature:(sds s, size_t inc)
sdsjoin	sds.c	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f	language:C	signature:(char **argv, int argc, char *sep)
sdsjoin	sds.h	/^sds sdsjoin(char **argv, int argc, char *sep);$/;"	p	language:C	signature:(char **argv, int argc, char *sep)
sdsjoinsds	sds.c	/^sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {$/;"	f	language:C	signature:(sds *argv, int argc, const char *sep, size_t seplen)
sdsjoinsds	sds.h	/^sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);$/;"	p	language:C	signature:(sds *argv, int argc, const char *sep, size_t seplen)
sdskey	db.c	/^        sds sdskey = dictGetKey(de);$/;"	l	language:C
sdskey	db.c	/^        sds sdskey = n->ele;$/;"	l	language:C
sdskey	db.c	/^    sds sdskey = sdsdup(key->ptr);$/;"	l	language:C
sdslen	sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f	language:C	signature:(const sds s)
sdsll2str	sds.c	/^int sdsll2str(char *s, long long value) {$/;"	f	language:C	signature:(char *s, long long value)
sdsmapchars	sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f	language:C	signature:(sds s, const char *from, const char *to, size_t setlen)
sdsmapchars	sds.h	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);$/;"	p	language:C	signature:(sds s, const char *from, const char *to, size_t setlen)
sdsname	sentinel.c	/^    char slavename[NET_PEER_ID_LEN], *sdsname;$/;"	l	language:C
sdsname	sentinel.c	/^    sds sdsname = sdsnew(name);$/;"	l	language:C
sdsnew	.sds.h.swp	/^/;"	p	language:C	file:	signature:(const char *init)
sdsnew	sds.c	/^sds sdsnew(const char *init) {$/;"	f	language:C	signature:(const char *init)
sdsnew	sds.h	/^sds sdsnew(const char *init);$/;"	p	language:C	signature:(const char *init)
sdsnewlen	.sds.h.swp	/^/;"	p	language:C	file:	signature:(const void *init, size_t initlen)
sdsnewlen	sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f	language:C	signature:(const void *init, size_t initlen)
sdsnewlen	sds.h	/^sds sdsnewlen(const void *init, size_t initlen);$/;"	p	language:C	signature:(const void *init, size_t initlen)
sdsrange	sds.c	/^void sdsrange(sds s, int start, int end) {$/;"	f	language:C	signature:(sds s, int start, int end)
sdsrange	sds.h	/^void sdsrange(sds s, int start, int end);$/;"	p	language:C	signature:(sds s, int start, int end)
sdssetalloc	sds.h	/^static inline void sdssetalloc(sds s, size_t newlen) {$/;"	f	language:C	signature:(sds s, size_t newlen)
sdssetlen	sds.h	/^static inline void sdssetlen(sds s, size_t newlen) {$/;"	f	language:C	signature:(sds s, size_t newlen)
sdssplitargs	sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f	language:C	signature:(const char *line, int *argc)
sdssplitargs	sds.h	/^sds *sdssplitargs(const char *line, int *argc);$/;"	p	language:C	signature:(const char *line, int *argc)
sdssplitlen	sds.c	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f	language:C	signature:(const char *s, int len, const char *sep, int seplen, int *count)
sdssplitlen	sds.h	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);$/;"	p	language:C	signature:(const char *s, int len, const char *sep, int seplen, int *count)
sdstolower	sds.c	/^void sdstolower(sds s) {$/;"	f	language:C	signature:(sds s)
sdstolower	sds.h	/^void sdstolower(sds s);$/;"	p	language:C	signature:(sds s)
sdstoupper	sds.c	/^void sdstoupper(sds s) {$/;"	f	language:C	signature:(sds s)
sdstoupper	sds.h	/^void sdstoupper(sds s);$/;"	p	language:C	signature:(sds s)
sdstrim	sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f	language:C	signature:(sds s, const char *cset)
sdstrim	sds.h	/^sds sdstrim(sds s, const char *cset);$/;"	p	language:C	signature:(sds s, const char *cset)
sdsull2str	sds.c	/^int sdsull2str(char *s, unsigned long long v) {$/;"	f	language:C	signature:(char *s, unsigned long long v)
sdsupdatelen	sds.c	/^void sdsupdatelen(sds s) {$/;"	f	language:C	signature:(sds s)
sdsupdatelen	sds.h	/^void sdsupdatelen(sds s);$/;"	p	language:C	signature:(sds s)
sdsval	db.c	/^        sds sdsval = dictGetVal(de);$/;"	l	language:C
se	slowlog.c	/^        slowlogEntry *se;$/;"	l	language:C
se	slowlog.c	/^    slowlogEntry *se = septr;$/;"	l	language:C
se	slowlog.c	/^    slowlogEntry *se = zmalloc(sizeof(*se));$/;"	l	language:C
second	modules/API.md	/^     RedisModuleString *first, *second;$/;"	v	language:C
second_bytes	ziplist.c	/^    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));$/;"	l	language:C
second_len	ziplist.c	/^    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));$/;"	l	language:C
second_offset	ziplist.c	/^    size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));$/;"	l	language:C
seconds	config.c	/^                int seconds = atoi(argv[1]);$/;"	l	language:C
seconds	config.c	/^            time_t seconds;$/;"	l	language:C
seconds	redis-cli.c	/^            double seconds = atof(argv[++i]);$/;"	l	language:C
seconds	server.h	/^    time_t seconds;$/;"	m	language:C	struct:saveparam	access:public
section	sentinel.c	/^    char *section = c->argc == 2 ? c->argv[1]->ptr : NULL;$/;"	l	language:C
section	server.c	/^    char *section = c->argc == 2 ? c->argv[1]->ptr : "default";$/;"	l	language:C
sections	sentinel.c	/^    int sections = 0;$/;"	l	language:C
sections	server.c	/^    int sections = 0;$/;"	l	language:C
securityWarningCommand	networking.c	/^void securityWarningCommand(client *c) {$/;"	f	language:C	signature:(client *c)
securityWarningCommand	server.h	/^void securityWarningCommand(client *c);$/;"	p	language:C	signature:(client *c)
seed	dict.c	/^    uint32_t seed = dict_hash_function_seed;$/;"	l	language:C
seed	hyperloglog.c	/^    uint64_t seed = (uint64_t)rand() | (uint64_t)rand() << 32;$/;"	l	language:C
seed	util.c	/^    static unsigned char seed[20]; \/* The SHA1 seed, from \/dev\/urandom. *\/$/;"	l	language:C	file:
seed_initialized	util.c	/^    static int seed_initialized = 0;$/;"	l	language:C	file:
seldb	aof.c	/^        char seldb[64];$/;"	l	language:C
select	cluster.c	/^    int select = cs->last_dbid != dbid; \/* Should we emit SELECT? *\/$/;"	l	language:C
select	server.h	/^    *select[PROTO_SHARED_SELECT_CMDS],$/;"	m	language:C	struct:sharedObjectsStruct	access:public
selectCommand	db.c	/^void selectCommand(client *c) {$/;"	f	language:C	signature:(client *c)
selectCommand	server.h	/^void selectCommand(client *c);$/;"	p	language:C	signature:(client *c)
selectDb	db.c	/^int selectDb(client *c, int id) {$/;"	f	language:C	signature:(client *c, int id)
selectDb	server.h	/^int selectDb(client *c, int id);$/;"	p	language:C	signature:(client *c, int id)
selectcmd	aof.c	/^        char selectcmd[] = "*2\\r\\n$6\\r\\nSELECT\\r\\n";$/;"	l	language:C
selectcmd	replication.c	/^        robj *selectcmd;$/;"	l	language:C
selected	sentinel.c	/^    sentinelRedisInstance *selected = NULL;$/;"	l	language:C
self_ru	server.c	/^    struct rusage self_ru, c_ru;$/;"	l	language:C
sencoding	ziplist.c	/^    unsigned char sencoding;$/;"	l	language:C
sendBulkToSlave	replication.c	/^void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
sendReplyToClient	networking.c	/^void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
sendReplyToClient	server.h	/^void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
sendScan	redis-cli.c	/^static redisReply *sendScan(unsigned long long *it) {$/;"	f	language:C	file:	signature:(unsigned long long *it)
sendSync	redis-cli.c	/^unsigned long long sendSync(int fd) {$/;"	f	language:C	signature:(int fd)
sendSynchronousCommand	replication.c	/^char *sendSynchronousCommand(int flags, int fd, ...) {$/;"	f	language:C	signature:(int flags, int fd, ...)
sender	cluster.c	/^    clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender);$/;"	l	language:C
sender	cluster.c	/^    clusterNode *sender;$/;"	l	language:C
sender	cluster.h	/^    char sender[CLUSTER_NAMELEN]; \/* Name of the sender node *\/$/;"	m	language:C	struct:__anon10	access:public
senderConfigEpoch	cluster.c	/^    uint64_t senderCurrentEpoch = 0, senderConfigEpoch = 0;$/;"	l	language:C
senderCurrentEpoch	cluster.c	/^    uint64_t senderCurrentEpoch = 0, senderConfigEpoch = 0;$/;"	l	language:C
sender_master	cluster.c	/^        clusterNode *sender_master = NULL; \/* Sender or its master if slave. *\/$/;"	l	language:C
sendto_flags	server.c	/^    int sendto_flags = 0;$/;"	l	language:C
sent	slowlog.c	/^        long count = 10, sent = 0;$/;"	l	language:C
sentinel	sentinel.c	/^} sentinel;$/;"	v	language:C	typeref:struct:sentinelState
sentinelAbortFailover	sentinel.c	/^void sentinelAbortFailover(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelAbortFailover	sentinel.c	/^void sentinelAbortFailover(sentinelRedisInstance *ri);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *ri)
sentinelAddFlagsToDictOfRedisInstances	sentinel.c	/^void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f	language:C	signature:(dict *instances, int flags)
sentinelAddr	sentinel.c	/^typedef struct sentinelAddr {$/;"	s	language:C	file:
sentinelAddr	sentinel.c	/^} sentinelAddr;$/;"	t	language:C	typeref:struct:sentinelAddr	file:
sentinelAddr::ip	sentinel.c	/^    char *ip;$/;"	m	language:C	struct:sentinelAddr	file:	access:public
sentinelAddr::port	sentinel.c	/^    int port;$/;"	m	language:C	struct:sentinelAddr	file:	access:public
sentinelAddrIsEqual	sentinel.c	/^int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {$/;"	f	language:C	signature:(sentinelAddr *a, sentinelAddr *b)
sentinelAskMasterStateToOtherSentinels	sentinel.c	/^void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {$/;"	f	language:C	signature:(sentinelRedisInstance *master, int flags)
sentinelCallClientReconfScript	sentinel.c	/^void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {$/;"	f	language:C	signature:(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to)
sentinelCheckObjectivelyDown	sentinel.c	/^void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelCheckSubjectivelyDown	sentinel.c	/^void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelCheckTiltCondition	sentinel.c	/^void sentinelCheckTiltCondition(void) {$/;"	f	language:C	signature:(void)
sentinelCollectTerminatedScripts	sentinel.c	/^void sentinelCollectTerminatedScripts(void) {$/;"	f	language:C	signature:(void)
sentinelCommand	sentinel.c	/^void sentinelCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sentinelCommand	sentinel.c	/^void sentinelCommand(client *c);$/;"	p	language:C	file:	signature:(client *c)
sentinelDelFlagsToDictOfRedisInstances	sentinel.c	/^void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f	language:C	signature:(dict *instances, int flags)
sentinelDiscardReplyCallback	sentinel.c	/^void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	language:C	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelDiscardReplyCallback	sentinel.c	/^void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata);$/;"	p	language:C	file:	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelDisconnectCallback	sentinel.c	/^void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {$/;"	f	language:C	signature:(const redisAsyncContext *c, int status)
sentinelDisconnectCallback	sentinel.c	/^void sentinelDisconnectCallback(const redisAsyncContext *c, int status);$/;"	p	language:C	file:	signature:(const redisAsyncContext *c, int status)
sentinelEvent	sentinel.c	/^void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...);$/;"	p	language:C	file:	signature:(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...)
sentinelEvent	sentinel.c	/^void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,$/;"	f	language:C	signature:(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...)
sentinelFailoverDetectEnd	sentinel.c	/^void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelFailoverReconfNextSlave	sentinel.c	/^void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelFailoverSelectSlave	sentinel.c	/^void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelFailoverSendSlaveOfNoOne	sentinel.c	/^void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelFailoverStateMachine	sentinel.c	/^void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelFailoverStateStr	sentinel.c	/^const char *sentinelFailoverStateStr(int state) {$/;"	f	language:C	signature:(int state)
sentinelFailoverSwitchToPromotedSlave	sentinel.c	/^void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelFailoverWaitPromotion	sentinel.c	/^void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelFailoverWaitStart	sentinel.c	/^void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelFlushConfig	sentinel.c	/^void sentinelFlushConfig(void) {$/;"	f	language:C	signature:(void)
sentinelFlushConfig	sentinel.c	/^void sentinelFlushConfig(void);$/;"	p	language:C	file:	signature:(void)
sentinelForceHelloUpdateDictOfRedisInstances	sentinel.c	/^void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {$/;"	f	language:C	signature:(dict *instances)
sentinelForceHelloUpdateForMaster	sentinel.c	/^int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelForceHelloUpdateForMaster	sentinel.c	/^int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *master)
sentinelGenerateInitialMonitorEvents	sentinel.c	/^void sentinelGenerateInitialMonitorEvents(void) {$/;"	f	language:C	signature:(void)
sentinelGenerateInitialMonitorEvents	sentinel.c	/^void sentinelGenerateInitialMonitorEvents(void);$/;"	p	language:C	file:	signature:(void)
sentinelGetCurrentMasterAddress	sentinel.c	/^sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelGetInstanceTypeString	sentinel.c	/^char *sentinelGetInstanceTypeString(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelGetLeader	sentinel.c	/^char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {$/;"	f	language:C	signature:(sentinelRedisInstance *master, uint64_t epoch)
sentinelGetMasterByName	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByName(char *name) {$/;"	f	language:C	signature:(char *name)
sentinelGetMasterByName	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByName(char *name);$/;"	p	language:C	file:	signature:(char *name)
sentinelGetMasterByNameOrReplyError	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,$/;"	f	language:C	signature:(client *c, robj *name)
sentinelGetObjectiveLeader	sentinel.c	/^char *sentinelGetObjectiveLeader(sentinelRedisInstance *master);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *master)
sentinelGetScriptListNodeByPid	sentinel.c	/^listNode *sentinelGetScriptListNodeByPid(pid_t pid) {$/;"	f	language:C	signature:(pid_t pid)
sentinelGetSubjectiveLeader	sentinel.c	/^char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *master)
sentinelHandleConfiguration	sentinel.c	/^char *sentinelHandleConfiguration(char **argv, int argc) {$/;"	f	language:C	signature:(char **argv, int argc)
sentinelHandleConfiguration	server.h	/^char *sentinelHandleConfiguration(char **argv, int argc);$/;"	p	language:C	signature:(char **argv, int argc)
sentinelHandleDictOfRedisInstances	sentinel.c	/^void sentinelHandleDictOfRedisInstances(dict *instances) {$/;"	f	language:C	signature:(dict *instances)
sentinelHandleRedisInstance	sentinel.c	/^void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelInfoCommand	sentinel.c	/^void sentinelInfoCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sentinelInfoCommand	sentinel.c	/^void sentinelInfoCommand(client *c);$/;"	p	language:C	file:	signature:(client *c)
sentinelInfoReplyCallback	sentinel.c	/^void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	language:C	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelIsQuorumReachable	sentinel.c	/^int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {$/;"	f	language:C	signature:(sentinelRedisInstance *master, int *usableptr)
sentinelIsRunning	sentinel.c	/^void sentinelIsRunning(void) {$/;"	f	language:C	signature:(void)
sentinelIsRunning	server.h	/^void sentinelIsRunning(void);$/;"	p	language:C	signature:(void)
sentinelKillTimedoutScripts	sentinel.c	/^void sentinelKillTimedoutScripts(void) {$/;"	f	language:C	signature:(void)
sentinelLeader	sentinel.c	/^struct sentinelLeader {$/;"	s	language:C	file:
sentinelLeader::runid	sentinel.c	/^    char *runid;$/;"	m	language:C	struct:sentinelLeader	file:	access:public
sentinelLeader::votes	sentinel.c	/^    unsigned long votes;$/;"	m	language:C	struct:sentinelLeader	file:	access:public
sentinelLeaderIncr	sentinel.c	/^int sentinelLeaderIncr(dict *counters, char *runid) {$/;"	f	language:C	signature:(dict *counters, char *runid)
sentinelLinkEstablishedCallback	sentinel.c	/^void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {$/;"	f	language:C	signature:(const redisAsyncContext *c, int status)
sentinelLinkEstablishedCallback	sentinel.c	/^void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status);$/;"	p	language:C	file:	signature:(const redisAsyncContext *c, int status)
sentinelMasterLooksSane	sentinel.c	/^int sentinelMasterLooksSane(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelPendingScriptsCommand	sentinel.c	/^void sentinelPendingScriptsCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sentinelPingReplyCallback	sentinel.c	/^void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	language:C	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelProcessHelloMessage	sentinel.c	/^void sentinelProcessHelloMessage(char *hello, int hello_len) {$/;"	f	language:C	signature:(char *hello, int hello_len)
sentinelPropagateDownAfterPeriod	sentinel.c	/^void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelPublishCommand	sentinel.c	/^void sentinelPublishCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sentinelPublishCommand	sentinel.c	/^void sentinelPublishCommand(client *c);$/;"	p	language:C	file:	signature:(client *c)
sentinelPublishReplyCallback	sentinel.c	/^void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	language:C	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReceiveHelloMessages	sentinel.c	/^void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	language:C	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReceiveHelloMessages	sentinel.c	/^void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata);$/;"	p	language:C	file:	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReceiveIsMasterDownReply	sentinel.c	/^void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	language:C	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReconnectInstance	sentinel.c	/^void sentinelReconnectInstance(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelRedisInstance	sentinel.c	/^typedef struct sentinelRedisInstance {$/;"	s	language:C	file:
sentinelRedisInstance	sentinel.c	/^} sentinelRedisInstance;$/;"	t	language:C	typeref:struct:sentinelRedisInstance	file:
sentinelRedisInstance::addr	sentinel.c	/^    sentinelAddr *addr; \/* Master host. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::auth_pass	sentinel.c	/^    char *auth_pass;    \/* Password to use for AUTH against master & slaves. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::client_reconfig_script	sentinel.c	/^    char *client_reconfig_script;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::config_epoch	sentinel.c	/^    uint64_t config_epoch;  \/* Configuration epoch. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::down_after_period	sentinel.c	/^    mstime_t down_after_period; \/* Consider it down after that period. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_delay_logged	sentinel.c	/^    mstime_t failover_delay_logged; \/* For what failover_start_time value we$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_epoch	sentinel.c	/^    uint64_t failover_epoch; \/* Epoch of the currently started failover. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_start_time	sentinel.c	/^    mstime_t failover_start_time;   \/* Last failover attempt start time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_state	sentinel.c	/^    int failover_state; \/* See SENTINEL_FAILOVER_STATE_* defines. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_state_change_time	sentinel.c	/^    mstime_t failover_state_change_time;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_timeout	sentinel.c	/^    mstime_t failover_timeout;      \/* Max time to refresh failover state. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::flags	sentinel.c	/^    int flags;      \/* See SRI_... defines *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::info	sentinel.c	/^    sds info; \/* cached INFO output *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::info_refresh	sentinel.c	/^    mstime_t info_refresh;  \/* Time at which we received INFO output from it. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_hello_time	sentinel.c	/^    mstime_t last_hello_time; \/* Only used if SRI_SENTINEL is set. Last time$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_master_down_reply_time	sentinel.c	/^    mstime_t last_master_down_reply_time; \/* Time of last reply to$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_pub_time	sentinel.c	/^    mstime_t last_pub_time;   \/* Last time we sent hello via Pub\/Sub. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::leader	sentinel.c	/^    char *leader;       \/* If this is a master instance, this is the runid of$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::leader_epoch	sentinel.c	/^    uint64_t leader_epoch; \/* Epoch of the 'leader' field. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::link	sentinel.c	/^    instanceLink *link; \/* Link to the instance, may be shared for Sentinels. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::master	sentinel.c	/^    struct sentinelRedisInstance *master; \/* Master instance if it's slave. *\/$/;"	m	language:C	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
sentinelRedisInstance::master_link_down_time	sentinel.c	/^    mstime_t master_link_down_time; \/* Slave replication link down time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::name	sentinel.c	/^    char *name;     \/* Master name from the point of view of this sentinel. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::notification_script	sentinel.c	/^    char *notification_script;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::o_down_since_time	sentinel.c	/^    mstime_t o_down_since_time; \/* Objectively down since time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::parallel_syncs	sentinel.c	/^    int parallel_syncs; \/* How many slaves to reconfigure at same time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::promoted_slave	sentinel.c	/^    struct sentinelRedisInstance *promoted_slave; \/* Promoted slave instance. *\/$/;"	m	language:C	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
sentinelRedisInstance::quorum	sentinel.c	/^    unsigned int quorum;\/* Number of sentinels that need to agree on failure. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::role_reported	sentinel.c	/^    int role_reported;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::role_reported_time	sentinel.c	/^    mstime_t role_reported_time;$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::runid	sentinel.c	/^    char *runid;    \/* Run ID of this instance, or unique ID if is a Sentinel.*\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::s_down_since_time	sentinel.c	/^    mstime_t s_down_since_time; \/* Subjectively down since time. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::sentinels	sentinel.c	/^    dict *sentinels;    \/* Other sentinels monitoring the same master. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_conf_change_time	sentinel.c	/^    mstime_t slave_conf_change_time; \/* Last time slave master addr changed. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_master_host	sentinel.c	/^    char *slave_master_host;    \/* Master host as reported by INFO *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_master_link_status	sentinel.c	/^    int slave_master_link_status; \/* Master link status as reported by INFO *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_master_port	sentinel.c	/^    int slave_master_port;      \/* Master port as reported by INFO *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_priority	sentinel.c	/^    int slave_priority; \/* Slave priority according to its INFO output. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_reconf_sent_time	sentinel.c	/^    mstime_t slave_reconf_sent_time; \/* Time at which we sent SLAVE OF <new> *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_repl_offset	sentinel.c	/^    unsigned long long slave_repl_offset; \/* Slave replication offset. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slaves	sentinel.c	/^    dict *slaves;       \/* Slaves for this master instance. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstanceLookupSlave	sentinel.c	/^sentinelRedisInstance *sentinelRedisInstanceLookupSlave($/;"	f	language:C	signature:( sentinelRedisInstance *ri, char *ip, int port)
sentinelRedisInstanceNoDownFor	sentinel.c	/^int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri, mstime_t ms)
sentinelRedisInstanceTypeStr	sentinel.c	/^const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelRedisInstanceTypeStr	sentinel.c	/^const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *ri)
sentinelRefreshInstanceInfo	sentinel.c	/^void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri, const char *info)
sentinelReleaseScriptJob	sentinel.c	/^void sentinelReleaseScriptJob(sentinelScriptJob *sj) {$/;"	f	language:C	signature:(sentinelScriptJob *sj)
sentinelResetMaster	sentinel.c	/^void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri, int flags)
sentinelResetMasterAndChangeAddress	sentinel.c	/^int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {$/;"	f	language:C	signature:(sentinelRedisInstance *master, char *ip, int port)
sentinelResetMastersByPattern	sentinel.c	/^int sentinelResetMastersByPattern(char *pattern, int flags) {$/;"	f	language:C	signature:(char *pattern, int flags)
sentinelRoleCommand	sentinel.c	/^void sentinelRoleCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sentinelRoleCommand	sentinel.c	/^void sentinelRoleCommand(client *c);$/;"	p	language:C	file:	signature:(client *c)
sentinelRunPendingScripts	sentinel.c	/^void sentinelRunPendingScripts(void) {$/;"	f	language:C	signature:(void)
sentinelScheduleScriptExecution	sentinel.c	/^void sentinelScheduleScriptExecution(char *path, ...) {$/;"	f	language:C	signature:(char *path, ...)
sentinelScheduleScriptExecution	sentinel.c	/^void sentinelScheduleScriptExecution(char *path, ...);$/;"	p	language:C	file:	signature:(char *path, ...)
sentinelScriptJob	sentinel.c	/^typedef struct sentinelScriptJob {$/;"	s	language:C	file:
sentinelScriptJob	sentinel.c	/^} sentinelScriptJob;$/;"	t	language:C	typeref:struct:sentinelScriptJob	file:
sentinelScriptJob::argv	sentinel.c	/^    char **argv;            \/* Arguments to call the script. *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::flags	sentinel.c	/^    int flags;              \/* Script job flags: SENTINEL_SCRIPT_* *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::pid	sentinel.c	/^    pid_t pid;              \/* Script execution pid. *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::retry_num	sentinel.c	/^    int retry_num;          \/* Number of times we tried to execute it. *\/$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::start_time	sentinel.c	/^    mstime_t start_time;    \/* Script execution time if the script is running,$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
sentinelScriptRetryDelay	sentinel.c	/^mstime_t sentinelScriptRetryDelay(int retry_num) {$/;"	f	language:C	signature:(int retry_num)
sentinelSelectSlave	sentinel.c	/^sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelSelectSlave	sentinel.c	/^sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *master)
sentinelSendAuthIfNeeded	sentinel.c	/^void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri, redisAsyncContext *c)
sentinelSendHello	sentinel.c	/^int sentinelSendHello(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelSendPeriodicCommands	sentinel.c	/^void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelSendPing	sentinel.c	/^int sentinelSendPing(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelSendPing	sentinel.c	/^int sentinelSendPing(sentinelRedisInstance *ri);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *ri)
sentinelSendSlaveOf	sentinel.c	/^int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri, char *host, int port)
sentinelSendSlaveOf	sentinel.c	/^int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *ri, char *host, int port)
sentinelSetClientName	sentinel.c	/^void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri, redisAsyncContext *c, char *type)
sentinelSetCommand	sentinel.c	/^void sentinelSetCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sentinelSetCommand	sentinel.c	/^void sentinelSetCommand(client *c);$/;"	p	language:C	file:	signature:(client *c)
sentinelSimFailureCrash	sentinel.c	/^void sentinelSimFailureCrash(void) {$/;"	f	language:C	signature:(void)
sentinelSimFailureCrash	sentinel.c	/^void sentinelSimFailureCrash(void);$/;"	p	language:C	file:	signature:(void)
sentinelStartFailover	sentinel.c	/^void sentinelStartFailover(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelStartFailover	sentinel.c	/^void sentinelStartFailover(sentinelRedisInstance *master);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *master)
sentinelStartFailoverIfNeeded	sentinel.c	/^int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {$/;"	f	language:C	signature:(sentinelRedisInstance *master)
sentinelState	sentinel.c	/^struct sentinelState {$/;"	s	language:C	file:
sentinelState::announce_ip	sentinel.c	/^    char *announce_ip;  \/* IP addr that is gossiped to other sentinels if$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::announce_port	sentinel.c	/^    int announce_port;  \/* Port that is gossiped to other sentinels if$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::current_epoch	sentinel.c	/^    uint64_t current_epoch;         \/* Current epoch. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::masters	sentinel.c	/^    dict *masters;      \/* Dictionary of master sentinelRedisInstances.$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::myid	sentinel.c	/^    char myid[CONFIG_RUN_ID_SIZE+1]; \/* This sentinel ID. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::previous_time	sentinel.c	/^    mstime_t previous_time;         \/* Last time we ran the time handler. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::running_scripts	sentinel.c	/^    int running_scripts;    \/* Number of scripts in execution right now. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::scripts_queue	sentinel.c	/^    list *scripts_queue;            \/* Queue of user scripts to execute. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::simfailure_flags	sentinel.c	/^    unsigned long simfailure_flags; \/* Failures simulation. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::tilt	sentinel.c	/^    int tilt;           \/* Are we in TILT mode? *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelState::tilt_start_time	sentinel.c	/^    mstime_t tilt_start_time;       \/* When TITL started. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
sentinelTimer	sentinel.c	/^void sentinelTimer(void) {$/;"	f	language:C	signature:(void)
sentinelTimer	server.h	/^void sentinelTimer(void);$/;"	p	language:C	signature:(void)
sentinelTryConnectionSharing	sentinel.c	/^int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelUpdateSentinelAddressInAllMasters	sentinel.c	/^int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {$/;"	f	language:C	signature:(sentinelRedisInstance *ri)
sentinelVoteLeader	sentinel.c	/^char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {$/;"	f	language:C	signature:(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch)
sentinelVoteLeader	sentinel.c	/^char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch);$/;"	p	language:C	file:	signature:(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch)
sentinel_mode	server.h	/^    int sentinel_mode;          \/* True if this instance is a Sentinel. *\/$/;"	m	language:C	struct:redisServer	access:public
sentinelcmds	sentinel.c	/^struct redisCommand sentinelcmds[] = {$/;"	v	language:C	typeref:struct:redisCommand
sentinels	sentinel.c	/^    dict *sentinels;    \/* Other sentinels monitoring the same master. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
sentlen	server.h	/^    size_t sentlen;         \/* Amount of bytes already sent in the current$/;"	m	language:C	struct:client	access:public
seq	hyperloglog.c	/^    uint8_t seq[5], *n = seq;$/;"	l	language:C
seq	latency.c	/^    struct sequence *seq = createSparklineSequence();$/;"	l	language:C
seq	sparkline.c	/^    struct sequence *seq = zmalloc(sizeof(*seq));$/;"	l	language:C
seqlen	hyperloglog.c	/^     int seqlen = n-seq;$/;"	l	language:C
sequence	sparkline.h	/^struct sequence {$/;"	s	language:C
sequence::labels	sparkline.h	/^    int labels;$/;"	m	language:C	struct:sequence	access:public
sequence::length	sparkline.h	/^    int length;$/;"	m	language:C	struct:sequence	access:public
sequence::max	sparkline.h	/^    double min, max;$/;"	m	language:C	struct:sequence	access:public
sequence::min	sparkline.h	/^    double min, max;$/;"	m	language:C	struct:sequence	access:public
sequence::samples	sparkline.h	/^    struct sample *samples;$/;"	m	language:C	struct:sequence	typeref:struct:sequence::sample	access:public
serveClientBlockedOnList	t_list.c	/^int serveClientBlockedOnList(client *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)$/;"	f	language:C	signature:(client *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)
server	modules/API.md	/^Register a new command in the Redis server, that will be handled by$/;"	v	language:C
server	server.c	/^struct redisServer server; \/* server global state *\/$/;"	v	language:C	typeref:struct:redisServer
server	server.h	/^extern struct redisServer server;$/;"	x	language:C
serverAssert	server.h	/^#define serverAssert(/;"	d	language:C
serverAssertWithInfo	server.h	/^#define serverAssertWithInfo(/;"	d	language:C
serverCron	server.c	/^int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f	language:C	signature:(struct aeEventLoop *eventLoop, long long id, void *clientData)
serverLog	server.c	/^void serverLog(int level, const char *fmt, ...) {$/;"	f	language:C	signature:(int level, const char *fmt, ...)
serverLog	server.h	/^void serverLog(int level, const char *fmt, ...)$/;"	p	language:C	signature:(int level, const char *fmt, ...)
serverLog	server.h	/^void serverLog(int level, const char *fmt, ...);$/;"	p	language:C	signature:(int level, const char *fmt, ...)
serverLogFromHandler	server.c	/^void serverLogFromHandler(int level, const char *msg) {$/;"	f	language:C	signature:(int level, const char *msg)
serverLogFromHandler	server.h	/^void serverLogFromHandler(int level, const char *msg);$/;"	p	language:C	signature:(int level, const char *msg)
serverLogHexDump	debug.c	/^void serverLogHexDump(int level, char *descr, void *value, size_t len) {$/;"	f	language:C	signature:(int level, char *descr, void *value, size_t len)
serverLogHexDump	server.h	/^void serverLogHexDump(int level, char *descr, void *value, size_t len);$/;"	p	language:C	signature:(int level, char *descr, void *value, size_t len)
serverLogObjectDebugInfo	debug.c	/^void serverLogObjectDebugInfo(const robj *o) {$/;"	f	language:C	signature:(const robj *o)
serverLogObjectDebugInfo	server.h	/^void serverLogObjectDebugInfo(const robj *o);$/;"	p	language:C	signature:(const robj *o)
serverLogRaw	server.c	/^void serverLogRaw(int level, const char *msg) {$/;"	f	language:C	signature:(int level, const char *msg)
serverLogRaw	server.h	/^void serverLogRaw(int level, const char *msg);$/;"	p	language:C	signature:(int level, const char *msg)
serverPanic	server.h	/^#define serverPanic(/;"	d	language:C
server_mode	server.c	/^    char *server_mode = "";$/;"	l	language:C
servinfo	anet.c	/^    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;$/;"	l	language:C
servinfo	anet.c	/^    struct addrinfo hints, *servinfo, *p;$/;"	l	language:C
set	modules/API.md	/^Add a new element into a sorted set, with the specified 'score'.$/;"	v	language:C
set	rdb.c	/^            dict *set = o->ptr;$/;"	l	language:C
set	sort.c	/^        dict *set = ((zset*)sortval->ptr)->dict;$/;"	l	language:C
set	t_set.c	/^    robj *set, *ele, *aux;$/;"	l	language:C
set	t_set.c	/^    robj *set;$/;"	l	language:C
set	t_zset.c	/^        } set;$/;"	m	language:C	union:__anon40::__anon41	typeref:union:__anon40::__anon41::_iterset	file:	access:public
setAccumulatorDictType	t_zset.c	/^dictType setAccumulatorDictType = {$/;"	v	language:C
setCommand	server.h	/^void setCommand(client *c);$/;"	p	language:C	signature:(client *c)
setCommand	t_string.c	/^void setCommand(client *c) {$/;"	f	language:C	signature:(client *c)
setDeferredMultiBulkLength	networking.c	/^void setDeferredMultiBulkLength(client *c, void *node, long length) {$/;"	f	language:C	signature:(client *c, void *node, long length)
setDeferredMultiBulkLength	server.h	/^void setDeferredMultiBulkLength(client *c, void *node, long length);$/;"	p	language:C	signature:(client *c, void *node, long length)
setDictType	server.c	/^dictType setDictType = {$/;"	v	language:C
setDictType	server.h	/^extern dictType setDictType;$/;"	x	language:C
setExpire	db.c	/^void setExpire(redisDb *db, robj *key, long long when) {$/;"	f	language:C	signature:(redisDb *db, robj *key, long long when)
setExpire	server.h	/^void setExpire(redisDb *db, robj *key, long long when);$/;"	p	language:C	signature:(redisDb *db, robj *key, long long when)
setGenericCommand	t_string.c	/^void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {$/;"	f	language:C	signature:(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply)
setKey	db.c	/^void setKey(redisDb *db, robj *key, robj *val) {$/;"	f	language:C	signature:(redisDb *db, robj *key, robj *val)
setKey	server.h	/^void setKey(redisDb *db, robj *key, robj *val);$/;"	p	language:C	signature:(redisDb *db, robj *key, robj *val)
setProtocolError	networking.c	/^static void setProtocolError(client *c, int pos) {$/;"	f	language:C	file:	signature:(client *c, int pos)
setProtocolError	networking.c	/^static void setProtocolError(client *c, int pos);$/;"	p	language:C	file:	signature:(client *c, int pos)
setSignedBitfield	bitops.c	/^void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {$/;"	f	language:C	signature:(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value)
setTypeAdd	server.h	/^int setTypeAdd(robj *subject, sds value);$/;"	p	language:C	signature:(robj *subject, sds value)
setTypeAdd	t_set.c	/^int setTypeAdd(robj *subject, sds value) {$/;"	f	language:C	signature:(robj *subject, sds value)
setTypeConvert	server.h	/^void setTypeConvert(robj *subject, int enc);$/;"	p	language:C	signature:(robj *subject, int enc)
setTypeConvert	t_set.c	/^void setTypeConvert(robj *setobj, int enc) {$/;"	f	language:C	signature:(robj *setobj, int enc)
setTypeCreate	server.h	/^robj *setTypeCreate(sds value);$/;"	p	language:C	signature:(sds value)
setTypeCreate	t_set.c	/^robj *setTypeCreate(sds value) {$/;"	f	language:C	signature:(sds value)
setTypeInitIterator	server.h	/^setTypeIterator *setTypeInitIterator(robj *subject);$/;"	p	language:C	signature:(robj *subject)
setTypeInitIterator	t_set.c	/^setTypeIterator *setTypeInitIterator(robj *subject) {$/;"	f	language:C	signature:(robj *subject)
setTypeIsMember	server.h	/^int setTypeIsMember(robj *subject, sds value);$/;"	p	language:C	signature:(robj *subject, sds value)
setTypeIsMember	t_set.c	/^int setTypeIsMember(robj *subject, sds value) {$/;"	f	language:C	signature:(robj *subject, sds value)
setTypeIterator	server.h	/^} setTypeIterator;$/;"	t	language:C	typeref:struct:__anon33
setTypeNext	server.h	/^int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele);$/;"	p	language:C	signature:(setTypeIterator *si, sds *sdsele, int64_t *llele)
setTypeNext	t_set.c	/^int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {$/;"	f	language:C	signature:(setTypeIterator *si, sds *sdsele, int64_t *llele)
setTypeNextObject	server.h	/^sds setTypeNextObject(setTypeIterator *si);$/;"	p	language:C	signature:(setTypeIterator *si)
setTypeNextObject	t_set.c	/^sds setTypeNextObject(setTypeIterator *si) {$/;"	f	language:C	signature:(setTypeIterator *si)
setTypeRandomElement	server.h	/^int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele);$/;"	p	language:C	signature:(robj *setobj, sds *sdsele, int64_t *llele)
setTypeRandomElement	t_set.c	/^int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {$/;"	f	language:C	signature:(robj *setobj, sds *sdsele, int64_t *llele)
setTypeRandomElements	server.h	/^unsigned long setTypeRandomElements(robj *set, unsigned long count, robj *aux_set);$/;"	p	language:C	signature:(robj *set, unsigned long count, robj *aux_set)
setTypeReleaseIterator	server.h	/^void setTypeReleaseIterator(setTypeIterator *si);$/;"	p	language:C	signature:(setTypeIterator *si)
setTypeReleaseIterator	t_set.c	/^void setTypeReleaseIterator(setTypeIterator *si) {$/;"	f	language:C	signature:(setTypeIterator *si)
setTypeRemove	server.h	/^int setTypeRemove(robj *subject, sds value);$/;"	p	language:C	signature:(robj *subject, sds value)
setTypeRemove	t_set.c	/^int setTypeRemove(robj *setobj, sds value) {$/;"	f	language:C	signature:(robj *setobj, sds value)
setTypeSize	server.h	/^unsigned long setTypeSize(const robj *subject);$/;"	p	language:C	signature:(const robj *subject)
setTypeSize	t_set.c	/^unsigned long setTypeSize(const robj *subject) {$/;"	f	language:C	signature:(const robj *subject)
setUnsignedBitfield	bitops.c	/^void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {$/;"	f	language:C	signature:(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value)
set_max_intset_entries	server.h	/^    size_t set_max_intset_entries;$/;"	m	language:C	struct:redisServer	access:public
setbitCommand	bitops.c	/^void setbitCommand(client *c) {$/;"	f	language:C	signature:(client *c)
setbitCommand	server.h	/^void setbitCommand(client *c);$/;"	p	language:C	signature:(client *c)
setele	sort.c	/^        dictEntry *setele;$/;"	l	language:C
setexCommand	server.h	/^void setexCommand(client *c);$/;"	p	language:C	signature:(client *c)
setexCommand	t_string.c	/^void setexCommand(client *c) {$/;"	f	language:C	signature:(client *c)
setnum	t_zset.c	/^    long setnum;$/;"	l	language:C
setnxCommand	server.h	/^void setnxCommand(client *c);$/;"	p	language:C	signature:(client *c)
setnxCommand	t_string.c	/^void setnxCommand(client *c) {$/;"	f	language:C	signature:(client *c)
setobj	t_set.c	/^        robj *setobj = dstkey ?$/;"	l	language:C
setproctitle	config.h	/^void setproctitle(const char *fmt, ...);$/;"	p	language:C	signature:(const char *fmt, ...)
setproctitle	setproctitle.c	/^void setproctitle(const char *fmt, ...) {$/;"	f	language:C	signature:(const char *fmt, ...)
setrangeCommand	server.h	/^void setrangeCommand(client *c);$/;"	p	language:C	signature:(client *c)
setrangeCommand	t_string.c	/^void setrangeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
setrlimit_error	server.c	/^            int setrlimit_error = 0;$/;"	l	language:C
sets	modules/TYPES.md	/^The 1 byte type identifies strings, lists, sets, and so forth. In the case$/;"	v	language:C
sets	t_set.c	/^    robj **sets = zmalloc(sizeof(robj*)*setnum);$/;"	l	language:C
setsize	ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	language:C	struct:aeEventLoop	access:public
setupSignalHandlers	server.c	/^void setupSignalHandlers(void) {$/;"	f	language:C	signature:(void)
setupSignalHandlers	server.h	/^void setupSignalHandlers(void);$/;"	p	language:C	signature:(void)
sflags	server.h	/^    char *sflags; \/* Flags as string representation, one char per flag. *\/$/;"	m	language:C	struct:redisCommand	access:public
sh	networking.c	/^    void *sh = sdsAllocPtr(s);$/;"	l	language:C
sh	object.c	/^    struct sdshdr8 *sh = (void*)(o+1);$/;"	l	language:C
sh	sds.c	/^    void *sh, *newsh;$/;"	l	language:C
sh	sds.c	/^    void *sh;$/;"	l	language:C
sha	scripting.c	/^        char *sha = c->argv[1]->ptr;$/;"	l	language:C
sha	scripting.c	/^        sds sha;$/;"	l	language:C
sha1Test	sha1.c	/^int sha1Test(int argc, char **argv)$/;"	f	language:C	signature:(int argc, char **argv)
sha1Test	sha1.h	/^int sha1Test(int argc, char **argv);$/;"	p	language:C	signature:(int argc, char **argv)
sha1hex	scripting.c	/^void sha1hex(char *digest, char *script, size_t len) {$/;"	f	language:C	signature:(char *digest, char *script, size_t len)
shaScriptObjectDictType	server.c	/^dictType shaScriptObjectDictType = {$/;"	v	language:C
shaScriptObjectDictType	server.h	/^extern dictType shaScriptObjectDictType;$/;"	x	language:C
shared	server.c	/^struct sharedObjectsStruct shared;$/;"	v	language:C	typeref:struct:sharedObjectsStruct
shared	server.h	/^extern struct sharedObjectsStruct shared;$/;"	x	language:C
sharedObjectsStruct	server.h	/^struct sharedObjectsStruct {$/;"	s	language:C
sharedObjectsStruct::bgsaveerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::bulkhdr	server.h	/^    *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  \/* "$<value>\\r\\n" *\/$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::busykeyerr	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::cnegone	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::colon	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::cone	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::crlf	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::czero	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::del	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::emptybulk	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::emptymultibulk	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::emptyscan	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::err	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::execaborterr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::integers	server.h	/^    *integers[OBJ_SHARED_INTEGERS],$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::loadingerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::lpop	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::lpush	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::masterdownerr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::maxstring	server.h	/^    sds minstring, maxstring;$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::mbulkhdr	server.h	/^    *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], \/* "*<value>\\r\\n" *\/$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::messagebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::minstring	server.h	/^    sds minstring, maxstring;$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::noautherr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::nokeyerr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::noreplicaserr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::noscripterr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::nullbulk	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::nullmultibulk	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::ok	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::oomerr	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::outofrangeerr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::plus	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::pmessagebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::pong	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::psubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::punsubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::queued	server.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::roslaveerr	server.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::rpop	server.h	/^    *rpop, *lpop, *lpush, *emptyscan,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::sameobjecterr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::select	server.h	/^    *select[PROTO_SHARED_SELECT_CMDS],$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::slowscripterr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::space	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::subscribebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::syntaxerr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::unlink	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::unsubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::wrongtypeerr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
shortest	ae.c	/^        aeTimeEvent *shortest = NULL;$/;"	l	language:C
showLatencyDistLegend	redis-cli.c	/^void showLatencyDistLegend(void) {$/;"	f	language:C	signature:(void)
showLatencyDistSamples	redis-cli.c	/^void showLatencyDistSamples(struct distsamples *samples, long long tot) {$/;"	f	language:C	signature:(struct distsamples *samples, long long tot)
showLatencyReport	redis-benchmark.c	/^static void showLatencyReport(void) {$/;"	f	language:C	file:	signature:(void)
showThroughput	redis-benchmark.c	/^int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f	language:C	signature:(struct aeEventLoop *eventLoop, long long id, void *clientData)
showerrors	redis-benchmark.c	/^    int showerrors;$/;"	m	language:C	struct:config	file:	access:public
shutdown	redis-cli.c	/^    int shutdown;$/;"	m	language:C	struct:config	file:	access:public
shutdownCommand	db.c	/^void shutdownCommand(client *c) {$/;"	f	language:C	signature:(client *c)
shutdownCommand	server.h	/^void shutdownCommand(client *c);$/;"	p	language:C	signature:(client *c)
shutdown_asap	server.h	/^    int shutdown_asap;          \/* SHUTDOWN needed ASAP *\/$/;"	m	language:C	struct:redisServer	access:public
si	debug.c	/^                setTypeIterator *si = setTypeInitIterator(o);$/;"	l	language:C
si	sentinel.c	/^        sentinelRedisInstance *si;$/;"	l	language:C
si	sentinel.c	/^    sentinelRedisInstance *si, *master;$/;"	l	language:C
si	sort.c	/^        setTypeIterator *si = setTypeInitIterator(sortval);$/;"	l	language:C
si	t_set.c	/^        setTypeIterator *si;$/;"	l	language:C
si	t_set.c	/^    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));$/;"	l	language:C
si	t_set.c	/^    setTypeIterator *si;$/;"	l	language:C
sig	cluster.h	/^    char sig[4];        \/* Siganture "RCmb" (Redis Cluster message bus). *\/$/;"	m	language:C	struct:__anon10	access:public
sig	debug.c	/^    kill(getpid(),sig);$/;"	l	language:C
sigShutdownHandler	server.c	/^static void sigShutdownHandler(int sig) {$/;"	f	language:C	file:	signature:(int sig)
sign	bitops.c	/^        int sign = 0; \/* Signed or unsigned type? *\/$/;"	l	language:C
sign	bitops.c	/^    int sign;           \/* True if signed, otherwise unsigned op. *\/$/;"	m	language:C	struct:bitfieldOp	file:	access:public
signalFlushedDb	db.c	/^void signalFlushedDb(int dbid) {$/;"	f	language:C	signature:(int dbid)
signalFlushedDb	server.h	/^void signalFlushedDb(int dbid);$/;"	p	language:C	signature:(int dbid)
signalListAsReady	server.h	/^void signalListAsReady(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
signalListAsReady	t_list.c	/^void signalListAsReady(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
signalModifiedKey	db.c	/^void signalModifiedKey(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
signalModifiedKey	server.h	/^void signalModifiedKey(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
signature	modules/TYPES.md	/^cannot be resolved, since there is no loaded module having this signature,$/;"	v	language:C
signatures	redis-trib.rb	/^        signatures=[]$/;"	v	language:C
sigsegvHandler	debug.c	/^void sigsegvHandler(int sig, siginfo_t *info, void *secret) {$/;"	f	language:C	signature:(int sig, siginfo_t *info, void *secret)
sigsegvHandler	server.h	/^void sigsegvHandler(int sig, siginfo_t *info, void *secret);$/;"	p	language:C	signature:(int sig, siginfo_t *info, void *secret)
sigset	bio.c	/^    sigset_t sigset;$/;"	l	language:C
simfailure_flags	sentinel.c	/^    unsigned long simfailure_flags; \/* Failures simulation. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
since	help.h	/^  char *since;$/;"	m	language:C	struct:commandHelp	access:public
sinterCommand	server.h	/^void sinterCommand(client *c);$/;"	p	language:C	signature:(client *c)
sinterCommand	t_set.c	/^void sinterCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sinterGenericCommand	t_set.c	/^void sinterGenericCommand(client *c, robj **setkeys,$/;"	f	language:C	signature:(client *c, robj **setkeys, unsigned long setnum, robj *dstkey)
sinterstoreCommand	server.h	/^void sinterstoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
sinterstoreCommand	t_set.c	/^void sinterstoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sismemberCommand	server.h	/^void sismemberCommand(client *c);$/;"	p	language:C	signature:(client *c)
sismemberCommand	t_set.c	/^void sismemberCommand(client *c) {$/;"	f	language:C	signature:(client *c)
size	aof.c	/^    unsigned long size = 0;$/;"	l	language:C
size	cluster.c	/^        int i, size = sizeof(redisNodeFlagsTable)\/sizeof(struct redisNodeFlags);$/;"	l	language:C
size	cluster.h	/^    int size;             \/* Num of master nodes with at least one slot *\/$/;"	m	language:C	struct:clusterState	access:public
size	config.c	/^            long long size = memtoll(argv[1],NULL);$/;"	l	language:C
size	debug.c	/^    size_t start_addr, end_addr, size;$/;"	l	language:C
size	dict.h	/^    unsigned long size;$/;"	m	language:C	struct:dictht	access:public
size	intset.c	/^        long num = 100000, size = 10000;$/;"	l	language:C
size	intset.c	/^    uint32_t size = len*intrev32ifbe(is->encoding);$/;"	l	language:C
size	module.c	/^    uint32_t size;$/;"	m	language:C	struct:RedisModulePoolAllocBlock	file:	access:public
size	modules/API.md	/^a pointer and size (by reference), that the user can use to read or$/;"	p	language:C	file:	signature:(by reference)
size	redis-check-aof.c	/^    off_t size = sb.st_size;$/;"	l	language:C
size	redis-cli.c	/^    int size;$/;"	l	language:C
size	server.c	/^            long long size, used, vkeys;$/;"	l	language:C
size	server.c	/^    long long size, used;$/;"	l	language:C
size	t_set.c	/^    unsigned long count, size;$/;"	l	language:C
size	zmalloc.c	/^    int64_t size = 0;               \/* 64-bit *\/$/;"	l	language:C
size	zmalloc.c	/^    size_t size = *((size_t*)realptr);$/;"	l	language:C
sizeMeetsSafetyLimit	quicklist.c	/^#define sizeMeetsSafetyLimit(/;"	d	language:C	file:
size_vect	debug.c	/^    size_t size_vect[MEMTEST_MAX_REGIONS];$/;"	l	language:C
sizecmds	redis-cli.c	/^    char *sizecmds[] = {"STRLEN","LLEN","SCARD","HLEN","ZCARD"};$/;"	l	language:C
sizemask	dict.h	/^    unsigned long sizemask;$/;"	m	language:C	struct:dictht	access:public
sizes	debug.c	/^        sds sizes = sdsempty();$/;"	l	language:C
sizes	redis-cli.c	/^    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;$/;"	l	language:C
sj	sentinel.c	/^        sentinelScriptJob *sj = ln->value;$/;"	l	language:C
sj	sentinel.c	/^        sentinelScriptJob *sj;$/;"	l	language:C
sj	sentinel.c	/^    sentinelScriptJob *sj;$/;"	l	language:C
skip	db.c	/^        int skip;$/;"	m	language:C	struct:__anon11	file:	access:public
skip	replication.c	/^    long long j, skip, len;$/;"	l	language:C
skipargs	redis-cli.c	/^                    int repeat, skipargs = 0;$/;"	l	language:C
skipcnt	ziplist.c	/^    int skipcnt = 0;$/;"	l	language:C
skiplist	db.c	/^    } skiplist[] = {$/;"	l	language:C
skipme	networking.c	/^        int skipme = 1;$/;"	l	language:C
skipval	bitops.c	/^    unsigned long skipval, word = 0, one;$/;"	l	language:C
sl	t_zset.c	/^            } sl;$/;"	m	language:C	union:__anon40::__anon41::_iterzset	typeref:struct:__anon40::__anon41::_iterzset::__anon45	file:	access:public
slargc	slowlog.c	/^    int j, slargc = argc;$/;"	l	language:C
slave	evict.c	/^            client *slave = listNodeValue(ln);$/;"	l	language:C
slave	networking.c	/^        client *slave = listNodeValue(ln);$/;"	l	language:C
slave	rdb.c	/^                client *slave = ln->value;$/;"	l	language:C
slave	rdb.c	/^        client *slave = ln->value;$/;"	l	language:C
slave	replication.c	/^            client *slave = ln->value;$/;"	l	language:C
slave	replication.c	/^        client *slave = ln->value;$/;"	l	language:C
slave	replication.c	/^        client *slave;$/;"	l	language:C
slave	replication.c	/^    client *slave = privdata;$/;"	l	language:C
slave	sentinel.c	/^            sentinelRedisInstance *slave = dictGetVal(de);$/;"	l	language:C
slave	sentinel.c	/^        sentinelRedisInstance *slave = dictGetVal(de);$/;"	l	language:C
slave	sentinel.c	/^        sentinelRedisInstance *slave;$/;"	l	language:C
slave	sentinel.c	/^    sentinelRedisInstance *slave = sentinelSelectSlave(ri);$/;"	l	language:C
slave	sentinel.c	/^    sentinelRedisInstance *slave;$/;"	l	language:C
slave	server.c	/^                client *slave = listNodeValue(ln);$/;"	l	language:C
slaveIsInHandshakeState	replication.c	/^int slaveIsInHandshakeState(void) {$/;"	f	language:C	signature:(void)
slaveMode	redis-cli.c	/^static void slaveMode(void) {$/;"	f	language:C	file:	signature:(void)
slaveMode	redis-cli.c	/^static void slaveMode(void);$/;"	p	language:C	file:	signature:(void)
slaveTryPartialResynchronization	replication.c	/^int slaveTryPartialResynchronization(int fd, int read_reply) {$/;"	f	language:C	signature:(int fd, int read_reply)
slave_addr	sentinel.c	/^            sentinelAddr *slave_addr;$/;"	l	language:C
slave_announce_ip	server.h	/^    char *slave_announce_ip;        \/* Give the master this ip address. *\/$/;"	m	language:C	struct:redisServer	access:public
slave_announce_port	server.h	/^    int slave_announce_port;        \/* Give the master this listening port. *\/$/;"	m	language:C	struct:redisServer	access:public
slave_capa	server.h	/^    int slave_capa;         \/* Slave capabilities: SLAVE_CAPA_* bitwise OR. *\/$/;"	m	language:C	struct:client	access:public
slave_conf_change_time	sentinel.c	/^    mstime_t slave_conf_change_time; \/* Last time slave master addr changed. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slave_ip	server.h	/^    char slave_ip[NET_IP_STR_LEN]; \/* Optionally given by REPLCONF ip-address *\/$/;"	m	language:C	struct:client	access:public
slave_listening_port	server.h	/^    int slave_listening_port; \/* As configured with: REPLCONF listening-port *\/$/;"	m	language:C	struct:client	access:public
slave_master_host	sentinel.c	/^    char *slave_master_host;    \/* Master host as reported by INFO *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slave_master_link_status	sentinel.c	/^    int slave_master_link_status; \/* Master link status as reported by INFO *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slave_master_port	sentinel.c	/^                int slave_master_port = atoi(l+12);$/;"	l	language:C
slave_master_port	sentinel.c	/^    int slave_master_port;      \/* Master port as reported by INFO *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slave_mode	redis-cli.c	/^    int slave_mode;$/;"	m	language:C	struct:config	file:	access:public
slave_priority	sentinel.c	/^    int slave_priority; \/* Slave priority according to its INFO output. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slave_priority	server.h	/^    int slave_priority;             \/* Reported in INFO and used by Sentinel. *\/$/;"	m	language:C	struct:redisServer	access:public
slave_reconf_sent_time	sentinel.c	/^    mstime_t slave_reconf_sent_time; \/* Time at which we sent SLAVE OF <new> *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slave_repl_offset	sentinel.c	/^    unsigned long long slave_repl_offset; \/* Slave replication offset. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slave_repl_offset	server.c	/^            long long slave_repl_offset = 1;$/;"	l	language:C
slave_sockets	rdb.c	/^        rio slave_sockets;$/;"	l	language:C
slaveid	server.c	/^            int slaveid = 0;$/;"	l	language:C
slaveip	replication.c	/^            char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;$/;"	l	language:C
slaveip	server.c	/^                char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;$/;"	l	language:C
slavename	sentinel.c	/^    char slavename[NET_PEER_ID_LEN], *sdsname;$/;"	l	language:C
slaveof	cluster.h	/^    char slaveof[CLUSTER_NAMELEN];$/;"	m	language:C	struct:__anon10	access:public
slaveof	cluster.h	/^    struct clusterNode *slaveof; \/* pointer to the master node. Note that it$/;"	m	language:C	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
slaveofCommand	replication.c	/^void slaveofCommand(client *c) {$/;"	f	language:C	signature:(client *c)
slaveofCommand	server.h	/^void slaveofCommand(client *c);$/;"	p	language:C	signature:(client *c)
slaveof_linenum	config.c	/^    int slaveof_linenum = 0;$/;"	l	language:C
slaves	cluster.c	/^    int slaves = 0;$/;"	l	language:C
slaves	cluster.h	/^    struct clusterNode **slaves; \/* pointers to slave nodes *\/$/;"	m	language:C	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
slaves	evict.c	/^    int slaves = listLength(server.slaves);$/;"	l	language:C
slaves	replication.c	/^        int slaves = 0;$/;"	l	language:C
slaves	sentinel.c	/^    dict *slaves;       \/* Slaves for this master instance. *\/$/;"	m	language:C	struct:sentinelRedisInstance	file:	access:public
slaves	sentinel.c	/^    sentinelAddr **slaves = NULL;$/;"	l	language:C
slaves	server.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	language:C	struct:redisServer	access:public
slaves_waiting	replication.c	/^        int slaves_waiting = 0;$/;"	l	language:C
slaveseldb	server.h	/^    int slaveseldb;                 \/* Last SELECTed DB in replication output *\/$/;"	m	language:C	struct:redisServer	access:public
slavestate	replication.c	/^        char *slavestate = NULL;$/;"	l	language:C
slen	networking.c	/^    int dlen, slen;$/;"	l	language:C
slen	scripting.c	/^        int slen = atoi(plen); \/* Length of this arg. *\/$/;"	l	language:C
slen	ziplist.c	/^        unsigned int slen;$/;"	l	language:C
slot	cluster.c	/^                int slot;$/;"	l	language:C
slot	cluster.c	/^            int slot = keyHashSlot((char*)key->ptr, sdslen(key->ptr));$/;"	l	language:C
slot	cluster.c	/^        int j, slot;$/;"	l	language:C
slot	cluster.c	/^        int slot;$/;"	l	language:C
slot	cluster.c	/^        long long maxkeys, slot;$/;"	l	language:C
slot	cluster.c	/^        long long slot;$/;"	l	language:C
slot	cluster.c	/^    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0;$/;"	l	language:C
slot	cluster.c	/^    long long slot;$/;"	l	language:C
slot	redis-cli.c	/^        int slot;$/;"	l	language:C
slotToKeyAdd	db.c	/^void slotToKeyAdd(robj *key) {$/;"	f	language:C	signature:(robj *key)
slotToKeyAdd	server.h	/^void slotToKeyAdd(robj *key);$/;"	p	language:C	signature:(robj *key)
slotToKeyDel	db.c	/^void slotToKeyDel(robj *key) {$/;"	f	language:C	signature:(robj *key)
slotToKeyDel	server.h	/^void slotToKeyDel(robj *key);$/;"	p	language:C	signature:(robj *key)
slotToKeyFlush	db.c	/^void slotToKeyFlush(void) {$/;"	f	language:C	signature:(void)
slotToKeyFlush	server.h	/^void slotToKeyFlush(void);$/;"	p	language:C	signature:(void)
slotToKeyFlushAsync	lazyfree.c	/^void slotToKeyFlushAsync(void) {$/;"	f	language:C	signature:(void)
slotToKeyFlushAsync	server.h	/^void slotToKeyFlushAsync(void);$/;"	p	language:C	signature:(void)
slot_replylen	cluster.c	/^    void *slot_replylen = addDeferredMultiBulkLength(c);$/;"	l	language:C
slots	cluster.c	/^        unsigned char *slots = zmalloc(CLUSTER_SLOTS);$/;"	l	language:C
slots	cluster.h	/^    clusterNode *slots[CLUSTER_SLOTS];$/;"	m	language:C	struct:clusterState	access:public
slots	cluster.h	/^    unsigned char slots[CLUSTER_SLOTS\/8]; \/* Slots bitmap. *\/$/;"	m	language:C	struct:__anon5	access:public
slots	cluster.h	/^    unsigned char slots[CLUSTER_SLOTS\/8]; \/* slots handled by this node *\/$/;"	m	language:C	struct:clusterNode	access:public
slots	dict.c	/^    unsigned long i, slots = 0, chainlen, maxchainlen = 0;$/;"	l	language:C
slots	expire.c	/^            unsigned long num, slots;$/;"	l	language:C
slots	sds.c	/^    int elements = 0, slots = 5, start = 0, j;$/;"	l	language:C
slots_assigned	cluster.c	/^        int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;$/;"	l	language:C
slots_fail	cluster.c	/^        int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;$/;"	l	language:C
slots_ok	cluster.c	/^        int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;$/;"	l	language:C
slots_pfail	cluster.c	/^        int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;$/;"	l	language:C
slots_to_keys	cluster.h	/^    zskiplist *slots_to_keys;$/;"	m	language:C	struct:clusterState	access:public
slowlog	server.h	/^    list *slowlog;                  \/* SLOWLOG list of commands *\/$/;"	m	language:C	struct:redisServer	access:public
slowlogCommand	slowlog.c	/^void slowlogCommand(client *c) {$/;"	f	language:C	signature:(client *c)
slowlogCommand	slowlog.h	/^void slowlogCommand(client *c);$/;"	p	language:C	signature:(client *c)
slowlogCreateEntry	slowlog.c	/^slowlogEntry *slowlogCreateEntry(robj **argv, int argc, long long duration) {$/;"	f	language:C	signature:(robj **argv, int argc, long long duration)
slowlogEntry	slowlog.h	/^typedef struct slowlogEntry {$/;"	s	language:C
slowlogEntry	slowlog.h	/^} slowlogEntry;$/;"	t	language:C	typeref:struct:slowlogEntry
slowlogEntry::argc	slowlog.h	/^    int argc;$/;"	m	language:C	struct:slowlogEntry	access:public
slowlogEntry::argv	slowlog.h	/^    robj **argv;$/;"	m	language:C	struct:slowlogEntry	access:public
slowlogEntry::duration	slowlog.h	/^    long long duration; \/* Time spent by the query, in nanoseconds. *\/$/;"	m	language:C	struct:slowlogEntry	access:public
slowlogEntry::id	slowlog.h	/^    long long id;       \/* Unique entry identifier. *\/$/;"	m	language:C	struct:slowlogEntry	access:public
slowlogEntry::time	slowlog.h	/^    time_t time;        \/* Unix time at which the query was executed. *\/$/;"	m	language:C	struct:slowlogEntry	access:public
slowlogFreeEntry	slowlog.c	/^void slowlogFreeEntry(void *septr) {$/;"	f	language:C	signature:(void *septr)
slowlogInit	slowlog.c	/^void slowlogInit(void) {$/;"	f	language:C	signature:(void)
slowlogInit	slowlog.h	/^void slowlogInit(void);$/;"	p	language:C	signature:(void)
slowlogPushEntryIfNeeded	slowlog.c	/^void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration) {$/;"	f	language:C	signature:(robj **argv, int argc, long long duration)
slowlogPushEntryIfNeeded	slowlog.h	/^void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration);$/;"	p	language:C	signature:(robj **argv, int argc, long long duration)
slowlogReset	slowlog.c	/^void slowlogReset(void) {$/;"	f	language:C	signature:(void)
slowlog_entry_id	server.h	/^    long long slowlog_entry_id;     \/* SLOWLOG current entry ID *\/$/;"	m	language:C	struct:redisServer	access:public
slowlog_log_slower_than	server.h	/^    long long slowlog_log_slower_than; \/* SLOWLOG time limit (to get logged) *\/$/;"	m	language:C	struct:redisServer	access:public
slowlog_max_len	server.h	/^    unsigned long slowlog_max_len;     \/* SLOWLOG max number of items logged *\/$/;"	m	language:C	struct:redisServer	access:public
slowscripterr	server.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
smoveCommand	server.h	/^void smoveCommand(client *c);$/;"	p	language:C	signature:(client *c)
smoveCommand	t_set.c	/^void smoveCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sndbuf	cluster.h	/^    sds sndbuf;                 \/* Packet send buffer *\/$/;"	m	language:C	struct:clusterLink	access:public
so	sort.c	/^    redisSortOperation *so = zmalloc(sizeof(*so));$/;"	l	language:C
so1	sort.c	/^    const redisSortObject *so1 = s1, *so2 = s2;$/;"	l	language:C
so2	sort.c	/^    const redisSortObject *so1 = s1, *so2 = s2;$/;"	l	language:C
sobj	sort.c	/^        robj *sobj = createQuicklistObject();$/;"	l	language:C
sobj	t_list.c	/^    robj *sobj, *value;$/;"	l	language:C
sockerr	replication.c	/^    int sockerr = 0, psync_result;$/;"	l	language:C
socket_error	cluster.c	/^    int socket_error = 0;$/;"	l	language:C
socket_target	replication.c	/^    int socket_target = server.repl_diskless_sync && (mincapa & SLAVE_CAPA_EOF);$/;"	l	language:C
sofd	server.h	/^    int sofd;                   \/* Unix socket file descriptor *\/$/;"	m	language:C	struct:redisServer	access:public
soft	config.c	/^            unsigned long long hard, soft;$/;"	l	language:C
soft	config.c	/^        char hard[64], soft[64];$/;"	l	language:C
soft	networking.c	/^    int soft = 0, hard = 0, class;$/;"	l	language:C
soft_limit_bytes	server.h	/^    unsigned long long soft_limit_bytes;$/;"	m	language:C	struct:clientBufferLimitsConfig	access:public
soft_limit_seconds	server.h	/^    time_t soft_limit_seconds;$/;"	m	language:C	struct:clientBufferLimitsConfig	access:public
soft_seconds	config.c	/^            int soft_seconds;$/;"	l	language:C
somaxconn	server.c	/^        int somaxconn = atoi(buf);$/;"	l	language:C
sop	sort.c	/^                    redisSortOperation *sop = ln->value;$/;"	l	language:C
sop	sort.c	/^                redisSortOperation *sop = ln->value;$/;"	l	language:C
sort	geo.c	/^    int sort = SORT_NONE;$/;"	l	language:C
sortCommand	server.h	/^void sortCommand(client *c);$/;"	p	language:C	signature:(client *c)
sortCommand	sort.c	/^void sortCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sortCompare	sort.c	/^int sortCompare(const void *s1, const void *s2) {$/;"	f	language:C	signature:(const void *s1, const void *s2)
sortGetKeys	db.c	/^int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
sortGetKeys	server.h	/^int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
sort_alpha	server.h	/^    int sort_alpha;$/;"	m	language:C	struct:redisServer	access:public
sort_bypattern	server.h	/^    int sort_bypattern;$/;"	m	language:C	struct:redisServer	access:public
sort_desc	server.h	/^    int sort_desc;$/;"	m	language:C	struct:redisServer	access:public
sort_gp_asc	geo.c	/^static int sort_gp_asc(const void *a, const void *b) {$/;"	f	language:C	file:	signature:(const void *a, const void *b)
sort_gp_desc	geo.c	/^static int sort_gp_desc(const void *a, const void *b) {$/;"	f	language:C	file:	signature:(const void *a, const void *b)
sort_store	server.h	/^    int sort_store;$/;"	m	language:C	struct:redisServer	access:public
sortby	sort.c	/^    robj *sortval, *sortby = NULL, *storekey = NULL;$/;"	l	language:C
sortval	sort.c	/^    robj *sortval, *sortby = NULL, *storekey = NULL;$/;"	l	language:C
source	ziplist.c	/^    unsigned char *source, *target;$/;"	l	language:C
source_bytes	ziplist.c	/^    size_t target_bytes, source_bytes;$/;"	l	language:C
south	geohash.h	/^    GeoHashBits south;$/;"	m	language:C	struct:__anon17	access:public
south	geohash_helper.c	/^        GeoHashArea north, south, east, west;$/;"	l	language:C
south_east	geohash.h	/^    GeoHashBits south_east;$/;"	m	language:C	struct:__anon17	access:public
south_west	geohash.h	/^    GeoHashBits south_west;$/;"	m	language:C	struct:__anon17	access:public
sp	sds.c	/^    char *start, *end, *sp, *ep;$/;"	l	language:C
sp	server.c	/^            struct saveparam *sp = server.saveparams+j;$/;"	l	language:C
space	modules/INTRO.md	/^access the Redis data space, one is a low level API that provides very$/;"	v	language:C
space	server.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
span	hyperloglog.c	/^    long index, first, span;$/;"	l	language:C
span	server.h	/^        unsigned int span;$/;"	m	language:C	struct:zskiplistNode::zskiplistLevel	access:public
sparklineRender	sparkline.c	/^sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags) {$/;"	f	language:C	signature:(sds output, struct sequence *seq, int columns, int rows, int flags)
sparklineRender	sparkline.h	/^sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags);$/;"	p	language:C	signature:(sds output, struct sequence *seq, int columns, int rows, int flags)
sparklineRenderRange	sparkline.c	/^sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags) {$/;"	f	language:C	signature:(sds output, struct sequence *seq, int rows, int offset, int len, int flags)
sparklineRenderRange	sparkline.h	/^sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags);$/;"	p	language:C	signature:(sds output, struct sequence *seq, int rows, int offset, int len, int flags)
sparklineSequenceAddSample	sparkline.c	/^void sparklineSequenceAddSample(struct sequence *seq, double value, char *label) {$/;"	f	language:C	signature:(struct sequence *seq, double value, char *label)
sparklineSequenceAddSample	sparkline.h	/^void sparklineSequenceAddSample(struct sequence *seq, double value, char *label);$/;"	p	language:C	signature:(struct sequence *seq, double value, char *label)
sparse	hyperloglog.c	/^    sds sparse = o->ptr, dense;$/;"	l	language:C
sparse	hyperloglog.c	/^    uint8_t oldcount, count, *sparse, *end, *p, *prev, *next;$/;"	l	language:C
sparselen	hyperloglog.c	/^    int sparselen = HLL_HDR_SIZE +$/;"	l	language:C
spat	sort.c	/^    sds spat, ssub;$/;"	l	language:C
spectrum_palette	redis-cli.c	/^int *spectrum_palette;$/;"	v	language:C
spectrum_palette_color	redis-cli.c	/^int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};$/;"	v	language:C
spectrum_palette_color_size	redis-cli.c	/^int spectrum_palette_color_size = 19;$/;"	v	language:C
spectrum_palette_mono	redis-cli.c	/^int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};$/;"	v	language:C
spectrum_palette_mono_size	redis-cli.c	/^int spectrum_palette_mono_size = 13;$/;"	v	language:C
spectrum_palette_size	redis-cli.c	/^int spectrum_palette_size;$/;"	v	language:C
spopCommand	server.h	/^void spopCommand(client *c);$/;"	p	language:C	signature:(client *c)
spopCommand	t_set.c	/^void spopCommand(client *c) {$/;"	f	language:C	signature:(client *c)
spopWithCountCommand	t_set.c	/^void spopWithCountCommand(client *c) {$/;"	f	language:C	signature:(client *c)
spt_clearenv	setproctitle.c	/^static int spt_clearenv(void) {$/;"	f	language:C	file:	signature:(void)
spt_copyargs	setproctitle.c	/^static int spt_copyargs(int argc, char *argv[]) {$/;"	f	language:C	file:	signature:(int argc, char *argv[])
spt_copyenv	setproctitle.c	/^static int spt_copyenv(char *oldenv[]) {$/;"	f	language:C	file:	signature:(char *oldenv[])
spt_init	config.h	/^void spt_init(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
spt_init	setproctitle.c	/^void spt_init(int argc, char *argv[]) {$/;"	f	language:C	signature:(int argc, char *argv[])
spt_min	setproctitle.c	/^static inline size_t spt_min(size_t a, size_t b) {$/;"	f	language:C	file:	signature:(size_t a, size_t b)
sptr	aof.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
sptr	debug.c	/^                    unsigned char *eptr, *sptr;$/;"	l	language:C
sptr	geo.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
sptr	module.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
sptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
sptr	t_zset.c	/^        unsigned char *eptr, *sptr;$/;"	l	language:C
sptr	t_zset.c	/^    unsigned char *eptr = ziplistIndex(zl,-2), *sptr;$/;"	l	language:C
sptr	t_zset.c	/^    unsigned char *eptr = ziplistIndex(zl,0), *sptr;$/;"	l	language:C
sptr	t_zset.c	/^    unsigned char *eptr, *sptr;$/;"	l	language:C
sptr	t_zset.c	/^    unsigned char *sptr;$/;"	l	language:C
srandmemberCommand	server.h	/^void srandmemberCommand(client *c);$/;"	p	language:C	signature:(client *c)
srandmemberCommand	t_set.c	/^void srandmemberCommand(client *c) {$/;"	f	language:C	signature:(client *c)
srandmemberWithCountCommand	t_set.c	/^void srandmemberWithCountCommand(client *c) {$/;"	f	language:C	signature:(client *c)
src	bitops.c	/^            unsigned char *src = NULL;$/;"	l	language:C
src	bitops.c	/^    unsigned char **src; \/* Array of source strings pointers. *\/$/;"	l	language:C
src	db.c	/^    redisDb *src, *dst;$/;"	l	language:C
src	intset.c	/^    void *src, *dst;$/;"	l	language:C
src	scripting.c	/^    sds *src;   \/* Lua script source code split by line. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
src	t_zset.c	/^    zsetopsrc *src;$/;"	l	language:C
srcid	db.c	/^    int srcid;$/;"	l	language:C
srckey	modules/helloworld.c	/^    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],$/;"	l	language:C
srclen	scripting.c	/^    size_t srclen = sdslen(srcstring);$/;"	l	language:C
srcset	t_set.c	/^    robj *srcset, *dstset, *ele;$/;"	l	language:C
srcstring	scripting.c	/^    sds srcstring = sdsdup(c->argv[1]->ptr);$/;"	l	language:C
sremCommand	server.h	/^                        *rpopCommand, *sremCommand, *execCommand;$/;"	m	language:C	struct:redisServer	typeref:struct:redisServer::	access:public
sremCommand	server.h	/^void sremCommand(client *c);$/;"	p	language:C	signature:(client *c)
sremCommand	t_set.c	/^void sremCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sri	sentinel.c	/^                sentinelRedisInstance *sri = dictGetVal(sde);$/;"	l	language:C
sscanCommand	server.h	/^void sscanCommand(client *c);$/;"	p	language:C	signature:(client *c)
sscanCommand	t_set.c	/^void sscanCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sstr	ziplist.c	/^        unsigned char *sstr;$/;"	l	language:C
ssub	sort.c	/^    sds spat, ssub;$/;"	l	language:C
stacksize	bio.c	/^    size_t stacksize;$/;"	l	language:C
start	aof.c	/^    long long start;$/;"	l	language:C
start	aof.c	/^    mstime_t start = mstime();$/;"	l	language:C
start	bitops.c	/^    long bit, start, end, strlen;$/;"	l	language:C
start	bitops.c	/^    long start, end, strlen;$/;"	l	language:C
start	cluster.c	/^            int start, stop;$/;"	l	language:C
start	cluster.c	/^        int j = 0, start = -1;$/;"	l	language:C
start	cluster.c	/^    int j, start;$/;"	l	language:C
start	debug.c	/^        char *start, *end, *p = line;$/;"	l	language:C
start	dict.c	/^    long long start = timeInMilliseconds();$/;"	l	language:C
start	expire.c	/^    long long start = ustime(), timelimit;$/;"	l	language:C
start	intset.c	/^        long long start;$/;"	l	language:C
start	quicklist.c	/^        long long start = mstime();$/;"	l	language:C
start	quicklist.c	/^    long long start = mstime();$/;"	l	language:C
start	rdb.c	/^    long long start;$/;"	l	language:C
start	redis-benchmark.c	/^    long long start;        \/* Start time of a request *\/$/;"	m	language:C	struct:_client	file:	access:public
start	redis-benchmark.c	/^    long long start;$/;"	m	language:C	struct:config	file:	access:public
start	redis-cli.c	/^        long long start, end, latency;$/;"	l	language:C
start	redis-cli.c	/^    long long start, latency, count = 0;$/;"	l	language:C
start	redis-cli.c	/^    long long start, latency, min = 0, max = 0, tot = 0, count = 0;$/;"	l	language:C
start	sds.c	/^    char *start, *end, *sp, *ep;$/;"	l	language:C
start	sds.c	/^    int elements = 0, slots = 5, start = 0, j;$/;"	l	language:C
start	server.c	/^    long long dirty, start, duration;$/;"	l	language:C
start	server.c	/^    long long start = ustime();$/;"	l	language:C
start	sort.c	/^    long limit_start = 0, limit_count = -1, start, end;$/;"	l	language:C
start	syncio.c	/^    long long start = mstime();$/;"	l	language:C
start	t_list.c	/^    long start, end, llen, ltrim, rtrim;$/;"	l	language:C
start	t_list.c	/^    long start, end, llen, rangelen;$/;"	l	language:C
start	t_string.c	/^        addReplyBulkCBuffer(c,(char*)str+start,end-start+1);$/;"	l	language:C
start	t_string.c	/^    long long start, end;$/;"	l	language:C
start	t_zset.c	/^    long start, end, llen;$/;"	l	language:C
start	t_zset.c	/^    long start;$/;"	l	language:C
start	util.c	/^                    int start = pattern[0];$/;"	l	language:C
start	ziplist.c	/^    long long start;$/;"	l	language:C
startAppendOnly	aof.c	/^int startAppendOnly(void) {$/;"	f	language:C	signature:(void)
startAppendOnly	server.h	/^int startAppendOnly(void);$/;"	p	language:C	signature:(void)
startBgsaveForReplication	replication.c	/^int startBgsaveForReplication(int mincapa) {$/;"	f	language:C	signature:(int mincapa)
startLoading	rdb.c	/^void startLoading(FILE *fp) {$/;"	f	language:C	signature:(FILE *fp)
startLoading	server.h	/^void startLoading(FILE *fp);$/;"	p	language:C	signature:(FILE *fp)
start_addr	debug.c	/^    size_t start_addr, end_addr, size;$/;"	l	language:C
start_cycle	redis-cli.c	/^    long long start_cycle;$/;"	l	language:C
start_time	redis-cli.c	/^                    long long start_time = mstime(), elapsed;$/;"	l	language:C
start_time	sentinel.c	/^    mstime_t start_time;    \/* Script execution time if the script is running,$/;"	m	language:C	struct:sentinelScriptJob	file:	access:public
start_vect	debug.c	/^    size_t start_vect[MEMTEST_MAX_REGIONS];$/;"	l	language:C
startbgsave	replication.c	/^    int startbgsave = 0;$/;"	l	language:C
startpos	redis-cli.c	/^    size_t startpos = 0;$/;"	l	language:C
statMode	redis-cli.c	/^static void statMode(void) {$/;"	f	language:C	file:	signature:(void)
stat_evictedkeys	server.h	/^    long long stat_evictedkeys;     \/* Number of evicted keys (maxmemory) *\/$/;"	m	language:C	struct:redisServer	access:public
stat_expiredkeys	server.h	/^    long long stat_expiredkeys;     \/* Number of expired keys *\/$/;"	m	language:C	struct:redisServer	access:public
stat_fork_rate	server.h	/^    double stat_fork_rate;          \/* Fork rate in GB\/sec. *\/$/;"	m	language:C	struct:redisServer	access:public
stat_fork_time	server.h	/^    long long stat_fork_time;       \/* Time needed to perform latest fork() *\/$/;"	m	language:C	struct:redisServer	access:public
stat_keyspace_hits	server.h	/^    long long stat_keyspace_hits;   \/* Number of successful lookups of keys *\/$/;"	m	language:C	struct:redisServer	access:public
stat_keyspace_misses	server.h	/^    long long stat_keyspace_misses; \/* Number of failed lookups of keys *\/$/;"	m	language:C	struct:redisServer	access:public
stat_mode	redis-cli.c	/^    int stat_mode;$/;"	m	language:C	struct:config	file:	access:public
stat_net_input_bytes	server.h	/^    long long stat_net_input_bytes; \/* Bytes read from network. *\/$/;"	m	language:C	struct:redisServer	access:public
stat_net_output_bytes	server.h	/^    long long stat_net_output_bytes; \/* Bytes written to network. *\/$/;"	m	language:C	struct:redisServer	access:public
stat_numcommands	server.h	/^    long long stat_numcommands;     \/* Number of processed commands *\/$/;"	m	language:C	struct:redisServer	access:public
stat_numconnections	server.h	/^    long long stat_numconnections;  \/* Number of connections received *\/$/;"	m	language:C	struct:redisServer	access:public
stat_peak_memory	server.h	/^    size_t stat_peak_memory;        \/* Max used memory record *\/$/;"	m	language:C	struct:redisServer	access:public
stat_rejected_conn	server.h	/^    long long stat_rejected_conn;   \/* Clients rejected because of maxclients *\/$/;"	m	language:C	struct:redisServer	access:public
stat_starttime	server.h	/^    time_t stat_starttime;          \/* Server start time *\/$/;"	m	language:C	struct:redisServer	access:public
stat_sync_full	server.h	/^    long long stat_sync_full;       \/* Number of full resyncs with slaves. *\/$/;"	m	language:C	struct:redisServer	access:public
stat_sync_partial_err	server.h	/^    long long stat_sync_partial_err;\/* Number of unaccepted PSYNC requests. *\/$/;"	m	language:C	struct:redisServer	access:public
stat_sync_partial_ok	server.h	/^    long long stat_sync_partial_ok; \/* Number of accepted PSYNC requests. *\/$/;"	m	language:C	struct:redisServer	access:public
state	ae_epoll.c	/^    aeApiState *state = eventLoop->apidata;$/;"	l	language:C
state	ae_epoll.c	/^    aeApiState *state = zmalloc(sizeof(aeApiState));$/;"	l	language:C
state	ae_evport.c	/^    aeApiState *state = eventLoop->apidata;$/;"	l	language:C
state	ae_evport.c	/^    aeApiState *state = zmalloc(sizeof(aeApiState));$/;"	l	language:C
state	ae_kqueue.c	/^    aeApiState *state = eventLoop->apidata;$/;"	l	language:C
state	ae_kqueue.c	/^    aeApiState *state = zmalloc(sizeof(aeApiState));$/;"	l	language:C
state	ae_select.c	/^    aeApiState *state = eventLoop->apidata;$/;"	l	language:C
state	ae_select.c	/^    aeApiState *state = zmalloc(sizeof(aeApiState));$/;"	l	language:C
state	cluster.h	/^    int state;            \/* CLUSTER_OK, CLUSTER_FAIL, ... *\/$/;"	m	language:C	struct:clusterState	access:public
state	cluster.h	/^    unsigned char state; \/* Cluster state from the POV of the sender *\/$/;"	m	language:C	struct:__anon10	access:public
state	config.c	/^    struct rewriteConfigState *state = zmalloc(sizeof(*state));$/;"	l	language:C
state	config.c	/^    struct rewriteConfigState *state;$/;"	l	language:C
state	rio.h	/^            int *state;     \/* Error state of each fd. 0 (if ok) or errno. *\/$/;"	m	language:C	struct:_rio::__anon25::__anon28	access:public
state	server.c	/^                char *state = NULL;$/;"	l	language:C
state	sha1.h	/^    uint32_t state[5];$/;"	m	language:C	struct:__anon39	access:public
statestr	cluster.c	/^        char *statestr[] = {"ok","fail","needhelp"};$/;"	l	language:C
staticbuf	sds.c	/^    char staticbuf[1024], *buf = staticbuf, *t;$/;"	l	language:C
statloc	aof.c	/^        int statloc;$/;"	l	language:C
statloc	sentinel.c	/^    int statloc;$/;"	l	language:C
statloc	server.c	/^        int statloc;$/;"	l	language:C
stats	debug.c	/^        sds stats = sdsempty();$/;"	l	language:C
stats_bus_messages_received	cluster.h	/^    long long stats_bus_messages_received; \/* Num of msg rcvd via cluster bus.*\/$/;"	m	language:C	struct:clusterState	access:public
stats_bus_messages_sent	cluster.h	/^    long long stats_bus_messages_sent;  \/* Num of msg sent via cluster bus. *\/$/;"	m	language:C	struct:clusterState	access:public
status	sentinel.c	/^            char *status = "ok";$/;"	l	language:C
std	lzfP.h	/^using namespace std;$/;"	v	language:C
stdinarg	redis-cli.c	/^    int stdinarg; \/* get last arg from stdin. (-x option) *\/$/;"	m	language:C	struct:config	file:	access:public
step	geohash.c	/^    uint8_t step = hash.step;$/;"	l	language:C
step	geohash.h	/^    uint8_t step;$/;"	m	language:C	struct:__anon14	access:public
step	geohash_helper.c	/^    int step = 1;$/;"	l	language:C
step	memtest.c	/^    unsigned long step = 4096\/sizeof(unsigned long);$/;"	l	language:C
step	scripting.c	/^    int step;   \/* Stop at next line ragardless of breakpoints. *\/$/;"	m	language:C	struct:ldbState	file:	access:public
step	sds.c	/^            int step = 10, j, i;$/;"	l	language:C
step	sparkline.c	/^            int step;$/;"	l	language:C
steps	geohash_helper.c	/^    int steps;$/;"	l	language:C
steps	sparkline.c	/^    int steps = charset_len*rows;$/;"	l	language:C
stop	ae.h	/^    int stop;$/;"	m	language:C	struct:aeEventLoop	access:public
stop	cluster.c	/^            int start, stop;$/;"	l	language:C
stop	quicklist.c	/^        long long stop = mstime();$/;"	l	language:C
stop	quicklist.c	/^    long long stop = mstime();$/;"	l	language:C
stopAppendOnly	aof.c	/^void stopAppendOnly(void) {$/;"	f	language:C	signature:(void)
stopAppendOnly	server.h	/^void stopAppendOnly(void);$/;"	p	language:C	signature:(void)
stopLoading	rdb.c	/^void stopLoading(void) {$/;"	f	language:C	signature:(void)
stopLoading	server.h	/^void stopLoading(void);$/;"	p	language:C	signature:(void)
stop_writes_on_bgsave_err	server.h	/^    int stop_writes_on_bgsave_err;  \/* Don't allow writes if can't BGSAVE *\/$/;"	m	language:C	struct:redisServer	access:public
stored	dict.c	/^    unsigned long stored = 0, maxsizemask;$/;"	l	language:C
storedist	geo.c	/^    int storedist = 0; \/* 0 for STORE, 1 for STOREDIST. *\/$/;"	l	language:C
storekey	geo.c	/^    robj *storekey = NULL;$/;"	l	language:C
storekey	sort.c	/^    robj *sortval, *sortby = NULL, *storekey = NULL;$/;"	l	language:C
str	module.c	/^        const char *str; \/* String pointer for string and error replies. This$/;"	m	language:C	union:RedisModuleCallReply::__anon19	file:	access:public
str	module.c	/^    RedisModuleString *str;$/;"	l	language:C
str	modules/helloworld.c	/^    const char *str = RedisModule_StringPtrLen(argv[1], &strlen);$/;"	l	language:C
str	redis-check-aof.c	/^    char *str;$/;"	l	language:C
str	sds.c	/^        char next, *str;$/;"	l	language:C
str	t_list.c	/^        sds str = value->ptr;$/;"	l	language:C
str	t_string.c	/^    char *str, llbuf[32];$/;"	l	language:C
strEncoding	object.c	/^char *strEncoding(int encoding) {$/;"	f	language:C	signature:(int encoding)
strEncoding	server.h	/^char *strEncoding(int encoding);$/;"	p	language:C	signature:(int encoding)
strdup	modules/TYPES.md	/^    #define strdup /;"	d	language:C	file:
strenc	debug.c	/^        char *strenc;$/;"	l	language:C
stress	ziplist.c	/^static void stress(int pos, int num, int maxsize, int dnum) {$/;"	f	language:C	file:	signature:(int pos, int num, int maxsize, int dnum)
string	modules/API.md	/^Reply with a bulk string, taking in input a C buffer pointer and length.$/;"	v	language:C
string	modules/API.md	/^Reply with a bulk string, taking in input a RedisModuleString object.$/;"	v	language:C
string	modules/API.md	/^Return a new string object from a call reply of type string, error or$/;"	v	language:C
string	modules/API.md	/^the string, and later call StringDMA() again to get the pointer.$/;"	v	language:C
string	modules/INTRO.md	/^To reply with a simple string, that can't contain binary values or newlines,$/;"	v	language:C
string	modules/INTRO.md	/^call reply of type string, error or integer:$/;"	v	language:C
string2l	util.c	/^    assert(string2l(buf,strlen(buf),&v) == 0);$/;"	p	language:C	file:	signature:(buf,strlen(buf),&v)
string2l	util.c	/^    assert(string2l(buf,strlen(buf),&v) == 1);$/;"	p	language:C	file:	signature:(buf,strlen(buf),&v)
string2l	util.c	/^int string2l(const char *s, size_t slen, long *lval) {$/;"	f	language:C	signature:(const char *s, size_t slen, long *lval)
string2l	util.h	/^int string2l(const char *s, size_t slen, long *value);$/;"	p	language:C	signature:(const char *s, size_t slen, long *value)
string2ld	util.c	/^int string2ld(const char *s, size_t slen, long double *dp) {$/;"	f	language:C	signature:(const char *s, size_t slen, long double *dp)
string2ld	util.h	/^int string2ld(const char *s, size_t slen, long double *dp);$/;"	p	language:C	signature:(const char *s, size_t slen, long double *dp)
string2ll	util.c	/^    assert(string2ll(buf,strlen(buf),&v) == 0);$/;"	p	language:C	file:	signature:(buf,strlen(buf),&v)
string2ll	util.c	/^    assert(string2ll(buf,strlen(buf),&v) == 1);$/;"	p	language:C	file:	signature:(buf,strlen(buf),&v)
string2ll	util.c	/^int string2ll(const char *s, size_t slen, long long *value) {$/;"	f	language:C	signature:(const char *s, size_t slen, long long *value)
string2ll	util.h	/^int string2ll(const char *s, size_t slen, long long *value);$/;"	p	language:C	signature:(const char *s, size_t slen, long long *value)
stringObjectLen	object.c	/^size_t stringObjectLen(robj *o) {$/;"	f	language:C	signature:(robj *o)
stringObjectLen	server.h	/^size_t stringObjectLen(robj *o);$/;"	p	language:C	signature:(robj *o)
stringmatch	util.c	/^int stringmatch(const char *pattern, const char *string, int nocase) {$/;"	f	language:C	signature:(const char *pattern, const char *string, int nocase)
stringmatch	util.h	/^int stringmatch(const char *p, const char *s, int nocase);$/;"	p	language:C	signature:(const char *p, const char *s, int nocase)
stringmatchlen	util.c	/^int stringmatchlen(const char *pattern, int patternLen,$/;"	f	language:C	signature:(const char *pattern, int patternLen, const char *string, int stringLen, int nocase)
stringmatchlen	util.h	/^int stringmatchlen(const char *p, int plen, const char *s, int slen, int nocase);$/;"	p	language:C	signature:(const char *p, int plen, const char *s, int slen, int nocase)
strings	modules/API.md	/^normal C strings, so for example to delete the field "foo" the following$/;"	v	language:C
strings	modules/INTRO.md	/^However if you want to avoid having to free strings, the automatic memory$/;"	v	language:C
strings	modules/TYPES.md	/^data structures into Redis strings, it is possible to create modules that$/;"	v	language:C
strl	scripting.c	/^        size_t strl;$/;"	l	language:C
strlen	bitops.c	/^            long strlen = 0;$/;"	l	language:C
strlen	bitops.c	/^    long bit, start, end, strlen;$/;"	l	language:C
strlen	bitops.c	/^    long start, end, strlen;$/;"	l	language:C
strlen	modules/helloworld.c	/^    size_t strlen = 0;$/;"	l	language:C
strlen	modules/helloworld.c	/^    size_t strlen, chlen;$/;"	l	language:C
strlen	t_string.c	/^    size_t strlen;$/;"	l	language:C
strlenCommand	server.h	/^void strlenCommand(client *c);$/;"	p	language:C	signature:(client *c)
strlenCommand	t_string.c	/^void strlenCommand(client *c) {$/;"	f	language:C	signature:(client *c)
strmsg	module.c	/^    sds strmsg = sdsnewlen(prefix,1);$/;"	l	language:C
strp	scripting.c	/^        char *strp = (char*)lua_tolstring(lua,idx,&strl);$/;"	l	language:C
strtold	object.c	/^#define strtold(/;"	d	language:C	file:
su	server.c	/^    struct sockaddr_un su;$/;"	l	language:C
subcmd	bitops.c	/^        char *subcmd = c->argv[j]->ptr; \/* Current command name. *\/$/;"	l	language:C
subcmd	module.c	/^    char *subcmd = c->argv[1]->ptr;$/;"	l	language:C
subject	server.h	/^    robj *subject;$/;"	m	language:C	struct:__anon31	access:public
subject	server.h	/^    robj *subject;$/;"	m	language:C	struct:__anon33	access:public
subject	server.h	/^    robj *subject;$/;"	m	language:C	struct:__anon34	access:public
subject	t_list.c	/^    robj *subject, *obj;$/;"	l	language:C
subject	t_list.c	/^    robj *subject;$/;"	l	language:C
subject	t_zset.c	/^    robj *subject;$/;"	m	language:C	struct:__anon40	file:	access:public
sublen	sort.c	/^    int prefixlen, sublen, postfixlen, fieldlen;$/;"	l	language:C
sublen	sparkline.c	/^        int sublen = (seq->length-j) < columns ? (seq->length-j) : columns;$/;"	l	language:C
subscribeCommand	pubsub.c	/^void subscribeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
subscribeCommand	server.h	/^void subscribeCommand(client *c);$/;"	p	language:C	signature:(client *c)
subscribebulk	server.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
success	intset.c	/^    uint8_t success;$/;"	l	language:C
success	t_set.c	/^            int success;$/;"	l	language:C
success	t_set.c	/^            uint8_t success = 0;$/;"	l	language:C
sum	latency.c	/^    uint64_t sum;$/;"	l	language:C
sum	modules/helloworld.c	/^    long long sum = 0;$/;"	l	language:C
sum	server.c	/^    long long sum = 0;$/;"	l	language:C
summary	help.h	/^  char *summary;$/;"	m	language:C	struct:commandHelp	access:public
sunionCommand	server.h	/^void sunionCommand(client *c);$/;"	p	language:C	signature:(client *c)
sunionCommand	t_set.c	/^void sunionCommand(client *c) {$/;"	f	language:C	signature:(client *c)
sunionDiffGenericCommand	t_set.c	/^void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,$/;"	f	language:C	signature:(client *c, robj **setkeys, int setnum, robj *dstkey, int op)
sunionDiffGenericCommand	t_set.c	/^void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,$/;"	p	language:C	file:	signature:(client *c, robj **setkeys, int setnum, robj *dstkey, int op)
sunionstoreCommand	server.h	/^void sunionstoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
sunionstoreCommand	t_set.c	/^void sunionstoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
supervised	server.h	/^    int supervised;                 \/* 1 if supervised, 0 otherwise. *\/$/;"	m	language:C	struct:redisServer	access:public
supervised_mode	server.h	/^    int supervised_mode;            \/* See SUPERVISED_* *\/$/;"	m	language:C	struct:redisServer	access:public
supervised_mode_enum	config.c	/^configEnum supervised_mode_enum[] = {$/;"	v	language:C
sval	ziplist.c	/^        long long sval;$/;"	l	language:C
sval	ziplist.c	/^    long long zval, sval;$/;"	l	language:C
swap	pqsort.c	/^#define swap(/;"	d	language:C	file:
swapcode	pqsort.c	/^#define swapcode(/;"	d	language:C	file:
swapfunc	pqsort.c	/^static inline void	 swapfunc (char *, char *, size_t, int);$/;"	p	language:C	file:	signature:(char *, char *, size_t, int)
swapfunc	pqsort.c	/^swapfunc(char *a, char *b, size_t n, int swaptype)$/;"	f	language:C	file:	signature:(char *a, char *b, size_t n, int swaptype)
swaptype	pqsort.c	/^	int swaptype, cmp_result;$/;"	l	language:C
switch_to_promoted	sentinel.c	/^    sentinelRedisInstance *switch_to_promoted = NULL;$/;"	l	language:C
symbols	modules/TYPES.md	/^a reliable way? Well if you build a character set of 64 symbols, you can$/;"	v	language:C
syncCommand	replication.c	/^void syncCommand(client *c) {$/;"	f	language:C	signature:(client *c)
syncCommand	server.h	/^void syncCommand(client *c);$/;"	p	language:C	signature:(client *c)
syncRead	server.h	/^ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout);$/;"	p	language:C	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncRead	syncio.c	/^ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f	language:C	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncReadLine	server.h	/^ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout);$/;"	p	language:C	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncReadLine	syncio.c	/^ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f	language:C	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncWithMaster	replication.c	/^void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
syncWrite	server.h	/^ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout);$/;"	p	language:C	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncWrite	syncio.c	/^ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f	language:C	signature:(int fd, char *ptr, ssize_t size, long long timeout)
sync_in_progress	aof.c	/^    int sync_in_progress = 0;$/;"	l	language:C
sync_size	replication.c	/^        off_t sync_size = server.repl_transfer_read -$/;"	l	language:C
syntax_error	sort.c	/^    int syntax_error = 0;$/;"	l	language:C
syntaxerr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
syslogLevelMap	server.c	/^    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };$/;"	l	language:C
syslog_enabled	server.h	/^    int syslog_enabled;             \/* Is syslog enabled? *\/$/;"	m	language:C	struct:redisServer	access:public
syslog_facility	server.h	/^    int syslog_facility;            \/* Syslog facility *\/$/;"	m	language:C	struct:redisServer	access:public
syslog_facility_enum	config.c	/^configEnum syslog_facility_enum[] = {$/;"	v	language:C
syslog_ident	server.h	/^    char *syslog_ident;             \/* Syslog ident *\/$/;"	m	language:C	struct:redisServer	access:public
system_memory_size	server.h	/^    size_t system_memory_size;  \/* Total memory in system as reported by OS *\/$/;"	m	language:C	struct:redisServer	access:public
sz	debug.c	/^            size_t sz = sizeof(unsigned);$/;"	l	language:C
sz	debug.c	/^            unsigned long sz = 0;$/;"	l	language:C
sz	quicklist.c	/^                    int sz = ll2string(num, sizeof(num), nums[i]);$/;"	l	language:C
sz	quicklist.c	/^                int sz = ll2string(num, sizeof(num), nums[i]);$/;"	l	language:C
sz	quicklist.c	/^                unsigned int sz;$/;"	l	language:C
sz	quicklist.c	/^            unsigned int sz;$/;"	l	language:C
sz	quicklist.c	/^    unsigned int sz;$/;"	l	language:C
sz	quicklist.h	/^    unsigned int sz;             \/* ziplist size in bytes *\/$/;"	m	language:C	struct:quicklistNode	access:public
sz	quicklist.h	/^    unsigned int sz; \/* LZF size in bytes*\/$/;"	m	language:C	struct:quicklistLZF	access:public
sz	quicklist.h	/^    unsigned int sz;$/;"	m	language:C	struct:quicklistEntry	access:public
sz	util.c	/^    int sz;$/;"	l	language:C
t	endianconv.c	/^    unsigned char *x = p, t;$/;"	l	language:C
t	expire.c	/^    long long t = dictGetSignedIntegerVal(de);$/;"	l	language:C
t	module.c	/^        char *t = tokens[j];$/;"	l	language:C
t	redis-cli.c	/^    char *t = getenv("TERM");$/;"	l	language:C
t	redis-cli.c	/^    unsigned char s[256], i, j, t;$/;"	l	language:C
t	scripting.c	/^    int t = lua_type(lua,-1);$/;"	l	language:C
t	scripting.c	/^    int t = lua_type(lua,idx);$/;"	l	language:C
t	sds.c	/^    char *t;$/;"	l	language:C
t	sds.c	/^    char staticbuf[1024], *buf = staticbuf, *t;$/;"	l	language:C
t	server.c	/^    long long t = mstime() - server.inst_metric[metric].last_sample_time;$/;"	l	language:C
t	util.c	/^                        int t = start;$/;"	l	language:C
t0	dict.c	/^    dictht *t0, *t1;$/;"	l	language:C
t1	dict.c	/^    dictht *t0, *t1;$/;"	l	language:C
t32	rdb.c	/^    int32_t t32;$/;"	l	language:C
t64	rdb.c	/^    int64_t t64 = (int64_t) t;$/;"	l	language:C
t64	rdb.c	/^    int64_t t64;$/;"	l	language:C
t_info	zmalloc.c	/^    struct task_basic_info t_info;$/;"	l	language:C
t_info_count	zmalloc.c	/^    mach_msg_type_number_t t_info_count = TASK_BASIC_INFO_COUNT;$/;"	l	language:C
table	dict.c	/^    int table;$/;"	l	language:C
table	dict.c	/^    unsigned int h, idx, table;$/;"	l	language:C
table	dict.h	/^    dictEntry **table;$/;"	m	language:C	struct:dictht	access:public
table	dict.h	/^    int table, safe;$/;"	m	language:C	struct:dictIterator	access:public
table	sentinel.c	/^    dict *table = NULL;$/;"	l	language:C
tables	dict.c	/^    unsigned long tables; \/* 1 or 2 tables? *\/$/;"	l	language:C
tail	adlist.c	/^    listNode *tail = list->tail;$/;"	l	language:C
tail	adlist.h	/^    listNode *tail;$/;"	m	language:C	struct:list	access:public
tail	networking.c	/^        sds tail = listNodeValue(ln);$/;"	l	language:C
tail	quicklist.h	/^    quicklistNode *tail;$/;"	m	language:C	struct:quicklist	access:public
tail	server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	language:C	struct:zskiplist	typeref:struct:zskiplist::	access:public
tail	ziplist.c	/^    zlentry first, tail;$/;"	l	language:C
tail	ziplist.c	/^    zlentry tail;$/;"	l	language:C
taken	modules/INTRO.md	/^If the API version is wrong, the name is already taken, or there are other$/;"	v	language:C
takeover	cluster.c	/^        int force = 0, takeover = 0;$/;"	l	language:C
target	cluster.c	/^    clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;$/;"	l	language:C
target	quicklist.c	/^    quicklistNode *prev, *prev_prev, *next, *next_next, *target;$/;"	l	language:C
target	server.c	/^                int target = rop->target;$/;"	l	language:C
target	server.h	/^    int argc, dbid, target;$/;"	m	language:C	struct:redisOp	access:public
target	server.h	/^    robj *target;           \/* The key that should receive the element,$/;"	m	language:C	struct:blockingState	access:public
target	ziplist.c	/^    unsigned char *source, *target;$/;"	l	language:C
target_bytes	ziplist.c	/^    size_t target_bytes, source_bytes;$/;"	l	language:C
targetkey	bitops.c	/^    robj *o, *targetkey = c->argv[2];$/;"	l	language:C
task	zmalloc.c	/^    task_t task = MACH_PORT_NULL;$/;"	l	language:C
tcp_backlog	server.h	/^    int tcp_backlog;            \/* TCP listen() backlog *\/$/;"	m	language:C	struct:redisServer	access:public
tcpkeepalive	server.h	/^    int tcpkeepalive;               \/* Set SO_KEEPALIVE if non-zero. *\/$/;"	m	language:C	struct:redisServer	access:public
te	ae.c	/^    aeTimeEvent *te = eventLoop->timeEventHead;$/;"	l	language:C
te	ae.c	/^    aeTimeEvent *te, *prev;$/;"	l	language:C
te	ae.c	/^    aeTimeEvent *te;$/;"	l	language:C
tell	rio.h	/^    off_t (*tell)(struct _rio *);$/;"	m	language:C	struct:_rio	access:public
test_cond	testhelp.h	/^#define test_cond(/;"	d	language:C
test_end	redis-cli.c	/^    long long test_end, run_time, max_latency = 0, runs = 0;$/;"	l	language:C
test_is_selected	redis-benchmark.c	/^int test_is_selected(char *name) {$/;"	f	language:C	signature:(char *name)
test_ll2string	util.c	/^static void test_ll2string(void) {$/;"	f	language:C	file:	signature:(void)
test_report	testhelp.h	/^#define test_report(/;"	d	language:C
test_string2l	util.c	/^static void test_string2l(void) {$/;"	f	language:C	file:	signature:(void)
test_string2ll	util.c	/^static void test_string2ll(void) {$/;"	f	language:C	file:	signature:(void)
tests	redis-benchmark.c	/^    char *tests;$/;"	m	language:C	struct:config	file:	access:public
thing	modules/TYPES.md	/^However for the calls to do the right thing, we need to check if the key$/;"	v	language:C
this	cluster.c	/^            clusterNode *this = dictGetVal(de);$/;"	l	language:C
this	cluster.c	/^        clusterNode *this = dictGetVal(de);$/;"	l	language:C
this	modules/TYPES.md	/^A trivial implementation of the free method can be something like this,$/;"	v	language:C
this	modules/TYPES.md	/^Oh, I understand you need to understand this, so here is a very specific$/;"	v	language:C
this_slaves	cluster.c	/^    int this_slaves; \/* Number of ok slaves for our master (if we are slave). *\/$/;"	l	language:C
thiskey	cluster.c	/^            robj *thiskey = margv[keyindex[j]];$/;"	l	language:C
thislen	aof.c	/^            unsigned long thislen = (block->free < len) ? block->free : len;$/;"	l	language:C
thislen	replication.c	/^        long long thislen =$/;"	l	language:C
thislen	replication.c	/^        size_t thislen = server.repl_backlog_size - server.repl_backlog_idx;$/;"	l	language:C
thisline	scripting.c	/^    sds thisline = sdscatprintf(sdsempty(),"%s%-3d %s", prefix, lnum, line);$/;"	l	language:C
thisop	bitops.c	/^        struct bitfieldOp *thisop = ops+j;$/;"	l	language:C
thisslot	cluster.c	/^            int thisslot = keyHashSlot((char*)thiskey->ptr,$/;"	l	language:C
thread	bio.c	/^    pthread_t thread;$/;"	l	language:C
tilt	sentinel.c	/^    int tilt;           \/* Are we in TILT mode? *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
tilt_start_time	sentinel.c	/^    mstime_t tilt_start_time;       \/* When TITL started. *\/$/;"	m	language:C	struct:sentinelState	file:	access:public
time	bio.c	/^    time_t time; \/* Time at which the job was created. *\/$/;"	m	language:C	struct:bio_job	file:	access:public
time	cluster.h	/^    mstime_t time;             \/* Time of the last report from this node. *\/$/;"	m	language:C	struct:clusterNodeFailReport	access:public
time	intset.c	/^    srand(time(NULL));$/;"	p	language:C	file:
time	latency.h	/^    int32_t time; \/* We don't use time_t to force 4 bytes usage everywhere. *\/$/;"	m	language:C	struct:latencySample	access:public
time	modules/INTRO.md	/^able to work in Redis at the same time, since the function$/;"	v	language:C
time	redis-benchmark.c	/^    srandom(time(NULL));$/;"	p	language:C	file:
time	redis-cli.c	/^    srand(time(NULL));$/;"	p	language:C	file:
time	slowlog.h	/^    time_t time;        \/* Unix time at which the query was executed. *\/$/;"	m	language:C	struct:slowlogEntry	access:public
timeCommand	server.c	/^void timeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
timeCommand	server.h	/^void timeCommand(client *c);$/;"	p	language:C	signature:(client *c)
timeEventHead	ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	language:C	struct:aeEventLoop	access:public
timeEventNextId	ae.h	/^    long long timeEventNextId;$/;"	m	language:C	struct:aeEventLoop	access:public
timeInMilliseconds	dict.c	/^long long timeInMilliseconds(void) {$/;"	f	language:C	signature:(void)
timeProc	ae.h	/^    aeTimeProc *timeProc;$/;"	m	language:C	struct:aeTimeEvent	access:public
time_independent_strcmp	server.c	/^int time_independent_strcmp(char *a, char *b) {$/;"	f	language:C	signature:(char *a, char *b)
timelimit	expire.c	/^    long long start = ustime(), timelimit;$/;"	l	language:C
timelimit	scripting.c	/^        mstime_t timelimit = server.lua_time_limit ?$/;"	l	language:C
timelimit_exit	expire.c	/^    static int timelimit_exit = 0;      \/* Time limit hit in previous call? *\/$/;"	l	language:C	file:
timeout	ae_evport.c	/^    struct timespec timeout, *tsp;$/;"	l	language:C
timeout	ae_kqueue.c	/^        struct timespec timeout;$/;"	l	language:C
timeout	cluster.c	/^    long timeout;$/;"	l	language:C
timeout	replication.c	/^    mstime_t timeout;$/;"	l	language:C
timeout	scripting.c	/^    int timeout = 0;$/;"	l	language:C
timeout	sentinel.c	/^    int not_reconfigured = 0, timeout = 0;$/;"	l	language:C
timeout	server.h	/^    mstime_t timeout;       \/* Blocking operation timeout. If UNIX current time$/;"	m	language:C	struct:blockingState	access:public
timeout	t_list.c	/^    mstime_t timeout;$/;"	l	language:C
times	modules/API.md	/^   executes a module command multiple times, it can be recognized as$/;"	v	language:C
title	redis-benchmark.c	/^        sds title = sdsnew(argv[0]);$/;"	l	language:C
title	redis-benchmark.c	/^    const char *title;$/;"	m	language:C	struct:config	file:	access:public
tmp	debug.c	/^            char tmp[32];$/;"	l	language:C
tmp	networking.c	/^                    long long tmp;$/;"	l	language:C
tmp	redis-cli.c	/^            sds tmp = cliFormatReplyCSV(r->element[i]);$/;"	l	language:C
tmp	redis-cli.c	/^            sds tmp;$/;"	l	language:C
tmp	redis-cli.c	/^    helpEntry tmp;$/;"	l	language:C
tmp	redis-cli.c	/^    sds out = sdsempty(), tmp;$/;"	l	language:C
tmp	redis-cli.c	/^    sds tmp;$/;"	l	language:C
tmp	setproctitle.c	/^	char *base, *end, *nul, *tmp;$/;"	l	language:C
tmp	setproctitle.c	/^	char *tmp;$/;"	l	language:C
tmp	t_zset.c	/^    sds tmp;$/;"	l	language:C
tmpargv	aof.c	/^    robj *tmpargv[3];$/;"	l	language:C
tmpfile	aof.c	/^        char tmpfile[256];$/;"	l	language:C
tmpfile	aof.c	/^    char tmpfile[256];$/;"	l	language:C
tmpfile	rdb.c	/^    char tmpfile[256];$/;"	l	language:C
tmpfile	replication.c	/^    char tmpfile[256], *err = NULL;$/;"	l	language:C
to	modules/TYPES.md	/^the raw string saving API to, for example, save a structure on disk, you$/;"	v	language:C
toIntType	redis-cli.c	/^static int toIntType(char *key, char *type) {$/;"	f	language:C	file:	signature:(char *key, char *type)
to_meter	geo.c	/^    double to_meter = 1;$/;"	l	language:C
to_meters	geo.c	/^    double to_meters = extractUnitOrReply(c,argv[1]);$/;"	l	language:C
todo_before_sleep	cluster.h	/^    int todo_before_sleep; \/* Things to do in clusterBeforeSleep(). *\/$/;"	m	language:C	struct:clusterState	access:public
token	sentinel.c	/^    char **token = sdssplitlen(hello, hello_len, ",", 1, &numtokens);$/;"	l	language:C
tokens	module.c	/^    sds *tokens = sdssplitlen(s,strlen(s)," ",1,&count);$/;"	l	language:C
tokens	sds.c	/^    sds *tokens;$/;"	l	language:C
toport	sentinel.c	/^    char fromport[32], toport[32];$/;"	l	language:C
toremove	redis-cli.c	/^            int toremove = argc-1;$/;"	l	language:C
toremove	t_list.c	/^    long toremove;$/;"	l	language:C
tot	redis-cli.c	/^    long long start, latency, min = 0, max = 0, tot = 0, count = 0;$/;"	l	language:C
total	aof.c	/^    ssize_t nread, total = 0;$/;"	l	language:C
total_keys	evict.c	/^                unsigned long total_keys = 0, keys;$/;"	l	language:C
total_keys	redis-cli.c	/^    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;$/;"	l	language:C
total_system_hmem	server.c	/^        char total_system_hmem[64];$/;"	l	language:C
total_system_mem	server.c	/^        size_t total_system_mem = server.system_memory_size;$/;"	l	language:C
totalsize	redis-cli.c	/^    unsigned long long biggest[5] = {0}, counts[5] = {0}, totalsize[5] = {0};$/;"	l	language:C
totchainlen	dict.c	/^    unsigned long totchainlen = 0;$/;"	l	language:C
totentries	slowlog.c	/^        void *totentries;$/;"	l	language:C
totlatency	redis-benchmark.c	/^    long long totlatency;$/;"	m	language:C	struct:config	file:	access:public
totlen	anet.c	/^    ssize_t nread, totlen = 0;$/;"	l	language:C
totlen	anet.c	/^    ssize_t nwritten, totlen = 0;$/;"	l	language:C
totlen	cluster.c	/^    int totlen = 0;$/;"	l	language:C
totlen	cluster.c	/^    int totlen; \/* Total packet length. *\/$/;"	l	language:C
totlen	cluster.c	/^    uint32_t totlen = ntohl(hdr->totlen);$/;"	l	language:C
totlen	cluster.c	/^    uint32_t totlen;$/;"	l	language:C
totlen	cluster.h	/^    uint32_t totlen;    \/* Total length of this message *\/$/;"	m	language:C	struct:__anon10	access:public
totlen	redis-cli.c	/^    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;$/;"	l	language:C
totlen	t_string.c	/^    size_t totlen;$/;"	l	language:C
totlen	ziplist.c	/^    unsigned int i, totlen, deleted = 0;$/;"	l	language:C
totlen	zipmap.c	/^    unsigned int totlen;$/;"	l	language:C
totlines	config.c	/^    int linenum = 0, totlines, i;$/;"	l	language:C
totread	syncio.c	/^    ssize_t nread, totread = 0;$/;"	l	language:C
totwritten	networking.c	/^    ssize_t nwritten = 0, totwritten = 0;$/;"	l	language:C
touchCommand	expire.c	/^void touchCommand(client *c) {$/;"	f	language:C	signature:(client *c)
touchCommand	server.h	/^void touchCommand(client *c);$/;"	p	language:C	signature:(client *c)
touchWatchedKey	multi.c	/^void touchWatchedKey(redisDb *db, robj *key) {$/;"	f	language:C	signature:(redisDb *db, robj *key)
touchWatchedKey	server.h	/^void touchWatchedKey(redisDb *db, robj *key);$/;"	p	language:C	signature:(redisDb *db, robj *key)
touchWatchedKeysOnFlush	multi.c	/^void touchWatchedKeysOnFlush(int dbid) {$/;"	f	language:C	signature:(int dbid)
touchWatchedKeysOnFlush	server.h	/^void touchWatchedKeysOnFlush(int dbid);$/;"	p	language:C	signature:(int dbid)
touched	expire.c	/^    int touched = 0;$/;"	l	language:C
touched	t_zset.c	/^    int touched = 0;$/;"	l	language:C
touchedkey	t_list.c	/^        robj *touchedkey = c->argv[1];$/;"	l	language:C
towrite	cluster.c	/^        size_t pos = 0, towrite;$/;"	l	language:C
trace	debug.c	/^    void *trace[101];$/;"	l	language:C
trace_size	debug.c	/^    int trace_size = 0, fd = openDirectLogFiledes();$/;"	l	language:C
traces	scripting.c	/^    list *traces; \/* Messages about Redis commands executed since last stop.*\/$/;"	m	language:C	struct:ldbState	file:	access:public
trackInstantaneousMetric	server.c	/^void trackInstantaneousMetric(int metric, long long current_reading) {$/;"	f	language:C	signature:(int metric, long long current_reading)
traversed	t_zset.c	/^    unsigned long traversed = 0, removed = 0;$/;"	l	language:C
traversed	t_zset.c	/^    unsigned long traversed = 0;$/;"	l	language:C
tries	redis-cli.c	/^    int tries = 0;$/;"	l	language:C
trimlen	util.c	/^            int trimlen = 1;$/;"	l	language:C
trimmed	scripting.c	/^    int trimmed = 0;$/;"	l	language:C
tryObjectEncoding	object.c	/^robj *tryObjectEncoding(robj *o) {$/;"	f	language:C	signature:(robj *o)
tryObjectEncoding	server.h	/^robj *tryObjectEncoding(robj *o);$/;"	p	language:C	signature:(robj *o)
tryResizeHashTables	server.c	/^void tryResizeHashTables(int dbid) {$/;"	f	language:C	signature:(int dbid)
ts	latency.c	/^        struct latencyTimeSeries *ts = dictGetVal(de);$/;"	l	language:C
ts	latency.c	/^    struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);$/;"	l	language:C
ts	latency.c	/^    struct latencyTimeSeries *ts;$/;"	l	language:C
tsp	ae_evport.c	/^    struct timespec timeout, *tsp;$/;"	l	language:C
ttl	cluster.c	/^    long long ttl, expireat;$/;"	l	language:C
ttl	cluster.c	/^    long long ttl;$/;"	l	language:C
ttl	expire.c	/^                long long ttl;$/;"	l	language:C
ttl	expire.c	/^    long long expire, ttl = -1;$/;"	l	language:C
ttlCommand	expire.c	/^void ttlCommand(client *c) {$/;"	f	language:C	signature:(client *c)
ttlCommand	server.h	/^void ttlCommand(client *c);$/;"	p	language:C	signature:(client *c)
ttlGenericCommand	expire.c	/^void ttlGenericCommand(client *c, int output_ms) {$/;"	f	language:C	signature:(client *c, int output_ms)
ttl_samples	expire.c	/^            int ttl_samples;$/;"	l	language:C
ttl_sum	expire.c	/^            long long now, ttl_sum;$/;"	l	language:C
tv	ae.c	/^        struct timeval tv, *tvp;$/;"	l	language:C
tv	ae.c	/^    struct timeval tv;$/;"	l	language:C
tv	anet.c	/^    struct timeval tv;$/;"	l	language:C
tv	debug.c	/^        struct timespec tv;$/;"	l	language:C
tv	dict.c	/^    struct timeval tv;$/;"	l	language:C
tv	intset.c	/^    struct timeval tv;$/;"	l	language:C
tv	quicklist.c	/^    struct timeval tv;$/;"	l	language:C
tv	redis-benchmark.c	/^    struct timeval tv;$/;"	l	language:C
tv	redis-cli.c	/^    struct timeval tv;$/;"	l	language:C
tv	replication.c	/^    struct timeval tv;$/;"	l	language:C
tv	server.c	/^        struct timeval tv;$/;"	l	language:C
tv	server.c	/^    struct timeval tv;$/;"	l	language:C
tv	util.c	/^        struct timeval tv;$/;"	l	language:C
tv	ziplist.c	/^    struct timeval tv;$/;"	l	language:C
tval	blocked.c	/^    long long tval;$/;"	l	language:C
tvp	ae.c	/^        struct timeval tv, *tvp;$/;"	l	language:C
two	modules/API.md	/^aligned to the next power of two, so for example a 3 bytes request is$/;"	v	language:C
type	bio.c	/^    unsigned long type = (unsigned long) arg;$/;"	l	language:C
type	cluster.c	/^    int j, type, replace = 0;$/;"	l	language:C
type	cluster.c	/^    uint16_t type = ntohs(hdr->type);$/;"	l	language:C
type	cluster.h	/^    uint16_t type;      \/* Message type *\/$/;"	m	language:C	struct:__anon10	access:public
type	db.c	/^    char *type;$/;"	l	language:C
type	dict.h	/^    dictType *type;$/;"	m	language:C	struct:dict	access:public
type	module.c	/^    int type;       \/* REDISMODULE_REPLY_... *\/$/;"	m	language:C	struct:RedisModuleCallReply	file:	access:public
type	module.c	/^    int type;$/;"	m	language:C	struct:AutoMemEntry	file:	access:public
type	modules/API.md	/^If the key is NULL, is not associated with a module type, or is empty,$/;"	v	language:C
type	modules/API.md	/^If the string is open for writing and is of string type, resize it, padding$/;"	v	language:C
type	modules/API.md	/^In the context of the rdb_load method of a module data type, loads a string$/;"	v	language:C
type	modules/API.md	/^In the context of the rdb_save method of a module data type, loads back the$/;"	v	language:C
type	modules/API.md	/^In the context of the rdb_save method of a module data type, saves a double$/;"	v	language:C
type	modules/API.md	/^In the context of the rdb_save method of a module type, saves a$/;"	v	language:C
type	modules/INTRO.md	/^Called with a reply object of the wrong type, the above function always$/;"	v	language:C
type	modules/INTRO.md	/^If the reply is not of the right type, NULL is returned.$/;"	v	language:C
type	modules/INTRO.md	/^type, the `RedisModuleString`. This is an opaque data type you have API$/;"	v	language:C
type	modules/TYPES.md	/^    int type = RedisModule_KeyType(key);$/;"	v	language:C
type	modules/TYPES.md	/^Then if we successfully verified the key is not of the wrong type, and$/;"	v	language:C
type	modules/TYPES.md	/^are used in order to store the *encoding version* of the type, so that$/;"	v	language:C
type	modules/TYPES.md	/^native type, as obtained during the type registration, and finally a `void*`$/;"	v	language:C
type	modules/hellotype.c	/^    int type = RedisModule_KeyType(key);$/;"	l	language:C
type	modules/helloworld.c	/^    int type = RedisModule_KeyType(key);$/;"	l	language:C
type	networking.c	/^        int type = -1;$/;"	l	language:C
type	rdb.c	/^    int type, rdbver;$/;"	l	language:C
type	rdb.c	/^    int type;$/;"	l	language:C
type	rdb.c	/^    unsigned char type;$/;"	l	language:C
type	redis-check-rdb.c	/^    int type, rdbver;$/;"	l	language:C
type	redis-cli.c	/^    int type, *types=NULL;$/;"	l	language:C
type	redis-cli.c	/^    int type;$/;"	m	language:C	struct:__anon24	file:	access:public
type	sds.c	/^                int type = x[-1]&SDS_TYPE_MASK;$/;"	l	language:C
type	sds.c	/^    char type = sdsReqType(initlen);$/;"	l	language:C
type	sds.c	/^    char type, oldtype = s[-1] & SDS_TYPE_MASK;$/;"	l	language:C
type	server.h	/^    int type;$/;"	m	language:C	struct:_redisSortOperation	access:public
type	server.h	/^    moduleType *type;   \/* Module type doing the operation. *\/$/;"	m	language:C	struct:RedisModuleIO	access:public
type	server.h	/^    moduleType *type;$/;"	m	language:C	struct:moduleValue	access:public
type	server.h	/^    unsigned type:4;$/;"	m	language:C	struct:redisObject	access:public
type	t_zset.c	/^    int type; \/* Set, sorted set *\/$/;"	m	language:C	struct:__anon40	file:	access:public
typeCommand	db.c	/^void typeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
typeCommand	server.h	/^void typeCommand(client *c);$/;"	p	language:C	signature:(client *c)
typename	redis-cli.c	/^    char *typename[] = {"string","list","set","hash","zset"};$/;"	l	language:C
typename	scripting.c	/^        char *typename = "unknown";$/;"	l	language:C
types	module.c	/^    list *types;    \/* Module data types. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
types	redis-cli.c	/^    int type, *types=NULL;$/;"	l	language:C
typeunit	redis-cli.c	/^    char *typeunit[] = {"bytes","items","members","fields","members"};$/;"	l	language:C
u	bitops.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon1	file:	access:public
u	geo.c	/^    char *u = unit->ptr;$/;"	l	language:C
u	geohash_helper.c	/^    double lat1r, lon1r, lat2r, lon2r, u, v;$/;"	l	language:C
u	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon21	file:	access:public
u	module.c	/^    union {uint64_t u; int64_t i;} conv;$/;"	m	language:C	union:__anon22	file:	access:public
u	scripting.c	/^      int u = luaL_checkint(L, 1);$/;"	l	language:C
u	scripting.c	/^      int u = luaL_checkint(L, 2);$/;"	l	language:C
u	server.h	/^    } u;$/;"	m	language:C	struct:_redisSortObject	typeref:union:_redisSortObject::__anon30	access:public
u	util.c	/^    const char *u;$/;"	l	language:C
u16	lzfP.h	/^    typedef unsigned int u16;$/;"	t	language:C
u16	lzfP.h	/^    typedef unsigned short u16;$/;"	t	language:C
u64	dict.h	/^        uint64_t u64;$/;"	m	language:C	union:dictEntry::__anon12	access:public
u8	lzfP.h	/^typedef unsigned char u8;$/;"	t	language:C
u_int	solarisfixes.h	/^#define u_int /;"	d	language:C
u_int32_t	solarisfixes.h	/^#define u_int32_t /;"	d	language:C
uc	debug.c	/^    ucontext_t *uc = (ucontext_t*) secret;$/;"	l	language:C
um	zmalloc.c	/^    size_t um;$/;"	l	language:C
unblockClient	blocked.c	/^void unblockClient(client *c) {$/;"	f	language:C	signature:(client *c)
unblockClient	server.h	/^void unblockClient(client *c);$/;"	p	language:C	signature:(client *c)
unblockClientWaitingData	server.h	/^void unblockClientWaitingData(client *c);$/;"	p	language:C	signature:(client *c)
unblockClientWaitingData	t_list.c	/^void unblockClientWaitingData(client *c) {$/;"	f	language:C	signature:(client *c)
unblockClientWaitingReplicas	replication.c	/^void unblockClientWaitingReplicas(client *c) {$/;"	f	language:C	signature:(client *c)
unblockClientWaitingReplicas	server.h	/^void unblockClientWaitingReplicas(client *c);$/;"	p	language:C	signature:(client *c)
unblocked_clients	server.h	/^    list *unblocked_clients; \/* list of clients to unblock before next loop *\/$/;"	m	language:C	struct:redisServer	access:public
undoConnectWithMaster	replication.c	/^void undoConnectWithMaster(void) {$/;"	f	language:C	signature:(void)
uniq	t_set.c	/^    int uniq = 1;$/;"	l	language:C
unit	t_string.c	/^    int unit = UNIT_SECONDS;$/;"	l	language:C
unixsocket	server.h	/^    char *unixsocket;           \/* UNIX socket path *\/$/;"	m	language:C	struct:redisServer	access:public
unixsocketperm	server.h	/^    mode_t unixsocketperm;      \/* UNIX socket permission *\/$/;"	m	language:C	struct:redisServer	access:public
unixtime	server.h	/^    time_t unixtime;    \/* Unix time sampled every cron cycle. *\/$/;"	m	language:C	struct:redisServer	access:public
unlikely	quicklist.c	/^#define unlikely(/;"	d	language:C	file:
unlink	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
unlinkClient	networking.c	/^void unlinkClient(client *c) {$/;"	f	language:C	signature:(client *c)
unlinkClient	server.h	/^void unlinkClient(client *c);$/;"	p	language:C	signature:(client *c)
unlinkCommand	db.c	/^void unlinkCommand(client *c) {$/;"	f	language:C	signature:(client *c)
unlinkCommand	server.h	/^void unlinkCommand(client *c);$/;"	p	language:C	signature:(client *c)
unsubscribeCommand	pubsub.c	/^void unsubscribeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
unsubscribeCommand	server.h	/^void unsubscribeCommand(client *c);$/;"	p	language:C	signature:(client *c)
unsubscribebulk	server.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
unum	sds.c	/^        unsigned long long unum;$/;"	l	language:C
unwatchAllKeys	multi.c	/^void unwatchAllKeys(client *c) {$/;"	f	language:C	signature:(client *c)
unwatchAllKeys	server.h	/^void unwatchAllKeys(client *c);$/;"	p	language:C	signature:(client *c)
unwatchCommand	multi.c	/^void unwatchCommand(client *c) {$/;"	f	language:C	signature:(client *c)
unwatchCommand	server.h	/^void unwatchCommand(client *c);$/;"	p	language:C	signature:(client *c)
update	cluster.h	/^    } update;$/;"	m	language:C	union:clusterMsgData	typeref:struct:clusterMsgData::__anon9	access:public
update	t_hash.c	/^    int update = 0;$/;"	l	language:C
update	t_hash.c	/^    int update;$/;"	l	language:C
update	t_zset.c	/^    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;$/;"	l	language:C
updateCachedTime	server.c	/^void updateCachedTime(void) {$/;"	f	language:C	signature:(void)
updateCachedTime	server.h	/^void updateCachedTime(void);$/;"	p	language:C	signature:(void)
updateDictResizePolicy	server.c	/^void updateDictResizePolicy(void) {$/;"	f	language:C	signature:(void)
updateDictResizePolicy	server.h	/^void updateDictResizePolicy(void);$/;"	p	language:C	signature:(void)
updateSlavesWaitingBgsave	replication.c	/^void updateSlavesWaitingBgsave(int bgsaveerr, int type) {$/;"	f	language:C	signature:(int bgsaveerr, int type)
updateSlavesWaitingBgsave	server.h	/^void updateSlavesWaitingBgsave(int bgsaveerr, int type);$/;"	p	language:C	signature:(int bgsaveerr, int type)
update_cksum	rio.h	/^        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_write);$/;"	p	language:C
update_cksum	rio.h	/^    void (*update_cksum)(struct _rio *, const void *buf, size_t len);$/;"	m	language:C	struct:_rio	access:public
update_config	cluster.c	/^    int update_config = 0;$/;"	l	language:C
update_state	cluster.c	/^    int update_state = 0;$/;"	l	language:C
update_zmalloc_stat_alloc	zmalloc.c	/^#define update_zmalloc_stat_alloc(/;"	d	language:C	file:
update_zmalloc_stat_free	zmalloc.c	/^#define update_zmalloc_stat_free(/;"	d	language:C	file:
updated	hyperloglog.c	/^    int updated = 0, j;$/;"	l	language:C
updated	module.c	/^    int updated = 0;$/;"	l	language:C
updated	t_zset.c	/^    int updated = 0;    \/* Number of elements with updated score. *\/$/;"	l	language:C
upstart_job	server.c	/^        const char *upstart_job = getenv("UPSTART_JOB");$/;"	l	language:C
upstart_job	server.c	/^    const char *upstart_job = getenv("UPSTART_JOB");$/;"	l	language:C
uptime	server.c	/^    time_t uptime = server.unixtime-server.stat_starttime;$/;"	l	language:C
usable	sentinel.c	/^        int usable;$/;"	l	language:C
usable	sentinel.c	/^    int usable = 1; \/* Number of usable Sentinels. Init to 1 to count myself. *\/$/;"	l	language:C
usage	redis-cli.c	/^static void usage(void) {$/;"	f	language:C	file:	signature:(void)
usage	redis-cli.c	/^static void usage(void);$/;"	p	language:C	file:	signature:(void)
usage	server.c	/^void usage(void) {$/;"	f	language:C	signature:(void)
usage	server.h	/^void usage(void);$/;"	p	language:C	signature:(void)
use_pattern	db.c	/^    int patlen = 0, use_pattern = 0;$/;"	l	language:C
usec	intset.c	/^static long long usec(void) {$/;"	f	language:C	file:	signature:(void)
usec	ziplist.c	/^static long long usec(void) {$/;"	f	language:C	file:	signature:(void)
used	aof.c	/^    unsigned long used, free;$/;"	m	language:C	struct:aofrwblock	file:	access:public
used	debug.c	/^            int used = snprintf(nextra, remaining, " ql_nodes:%u", ql->len);$/;"	l	language:C
used	dict.h	/^    unsigned long used;$/;"	m	language:C	struct:dictht	access:public
used	geo.h	/^    size_t used;$/;"	m	language:C	struct:geoArray	access:public
used	module.c	/^    uint32_t used;$/;"	m	language:C	struct:RedisModulePoolAllocBlock	file:	access:public
used	modules/API.md	/^  whatever 'encver' is used, however the module can understand if$/;"	v	language:C
used	modules/INTRO.md	/^In order to obtain the value of an integer reply, the following function is used, as already shown in the example above:$/;"	v	language:C
used	server.c	/^            long long size, used, vkeys;$/;"	l	language:C
used	server.c	/^    long long size, used;$/;"	l	language:C
used	zipmap.c	/^    unsigned int used;$/;"	l	language:C
used_mem	networking.c	/^    unsigned long used_mem = getClientOutputBufferMemoryUsage(c);$/;"	l	language:C
used_memory	zmalloc.c	/^static size_t used_memory = 0;$/;"	v	language:C	file:
used_memory_lua_hmem	server.c	/^        char used_memory_lua_hmem[64];$/;"	l	language:C
used_memory_mutex	zmalloc.c	/^pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	language:C
used_memory_rss_hmem	server.c	/^        char used_memory_rss_hmem[64];$/;"	l	language:C
useful	modules/INTRO.md	/^Most Redis modules, in order to be useful, have to interact with the Redis$/;"	v	language:C
usehash	bitops.c	/^    int usehash = 0;$/;"	l	language:C
usemark	replication.c	/^    static int usemark = 0;$/;"	l	language:C	file:
ust	quicklist.c	/^    long long ust;$/;"	l	language:C
ust	redis-benchmark.c	/^    long long ust;$/;"	l	language:C
ust	redis-cli.c	/^    long long ust;$/;"	l	language:C
ust	server.c	/^    long long ust;$/;"	l	language:C
ustime	quicklist.c	/^static long long ustime(void) {$/;"	f	language:C	file:	signature:(void)
ustime	redis-benchmark.c	/^static long long ustime(void) {$/;"	f	language:C	file:	signature:(void)
ustime	redis-cli.c	/^static long long ustime(void) {$/;"	f	language:C	file:	signature:(void)
ustime	server.c	/^long long ustime(void) {$/;"	f	language:C	signature:(void)
ustime	server.h	/^long long ustime(void);$/;"	p	language:C	signature:(void)
usually	modules/INTRO.md	/^as usually, or by enabling automatic memory management (see corresponding$/;"	v	language:C
utilTest	util.c	/^int utilTest(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
utilTest	util.h	/^int utilTest(int argc, char **argv);$/;"	p	language:C	signature:(int argc, char **argv)
utime	debug.c	/^        long long utime = dtime*1000000;$/;"	l	language:C
uv	bitops.c	/^    uint64_t uv = value; \/* Casting will add UINT64_MAX + 1 if v is negative. *\/$/;"	l	language:C
uv	util.c	/^        uint64_t uv = (v != LLONG_MIN) ?$/;"	l	language:C
v	config.c	/^        sds *v = sdssplitlen(o->ptr,sdslen(o->ptr)," ",1,&vlen);$/;"	l	language:C
v	debug.c	/^    unsigned char *v = value;$/;"	l	language:C
v	dict.h	/^    } v;$/;"	m	language:C	struct:dictEntry	typeref:union:dictEntry::__anon12	access:public
v	geohash_helper.c	/^    double lat1r, lon1r, lat2r, lon2r, u, v;$/;"	l	language:C
v	memtest.c	/^    unsigned long off, w, *l1, *l2, v;$/;"	l	language:C
v	module.c	/^             robj **v = va_arg(ap, void*);$/;"	l	language:C
v	rdb.c	/^        uint16_t v;$/;"	l	language:C
v	rdb.c	/^        uint32_t v;$/;"	l	language:C
v	sds.c	/^    unsigned long long v;$/;"	l	language:C
v	t_hash.c	/^            sds f,v;$/;"	l	language:C
v	util.c	/^    long long v;$/;"	l	language:C
v	util.c	/^    long v;$/;"	l	language:C
v	util.c	/^    unsigned long long v;$/;"	l	language:C
v	ziplist.c	/^        char v[3][257] = {{0}};$/;"	l	language:C
v1	hyperloglog.c	/^            int v1 = HLL_SPARSE_VAL_VALUE(p);$/;"	l	language:C
v1	intset.c	/^        int i, v1, v2;$/;"	l	language:C
v1	ziplist.c	/^        char v1[257] = {0}, v2[257] = {0};$/;"	l	language:C
v16	intset.c	/^    int16_t v16;$/;"	l	language:C
v2	hyperloglog.c	/^            int v2 = HLL_SPARSE_VAL_VALUE(p+1);$/;"	l	language:C
v2	intset.c	/^        int i, v1, v2;$/;"	l	language:C
v2	ziplist.c	/^        char v1[257] = {0}, v2[257] = {0};$/;"	l	language:C
v32	intset.c	/^    int32_t v32;$/;"	l	language:C
v64	intset.c	/^    int64_t v64;$/;"	l	language:C
val	anet.c	/^    int val = 1;$/;"	l	language:C
val	bio.c	/^    unsigned long long val;$/;"	l	language:C
val	bitops.c	/^                int64_t val = getSignedBitfield(buf,thisop->offset-(byte*8),$/;"	l	language:C
val	bitops.c	/^                uint64_t val = getUnsignedBitfield(buf,thisop->offset-(byte*8),$/;"	l	language:C
val	config.c	/^            long val;$/;"	l	language:C
val	config.c	/^    const int val;$/;"	m	language:C	struct:configEnum	file:	access:public
val	db.c	/^        robj *val = dictGetVal(de);$/;"	l	language:C
val	db.c	/^    robj *key, *val = NULL;$/;"	l	language:C
val	db.c	/^    robj *val;$/;"	l	language:C
val	debug.c	/^        robj *key, *val;$/;"	l	language:C
val	debug.c	/^        robj *val, *key;$/;"	l	language:C
val	debug.c	/^        robj *val;$/;"	l	language:C
val	debug.c	/^        unsigned long val = (unsigned long) sp[i];$/;"	l	language:C
val	dict.h	/^        void *val;$/;"	m	language:C	union:dictEntry::__anon12	access:public
val	geo.c	/^        robj *val = c->argv[2 + i * 3 + 2];$/;"	l	language:C
val	hyperloglog.c	/^            uint8_t val;$/;"	l	language:C
val	hyperloglog.c	/^            unsigned int val;$/;"	l	language:C
val	hyperloglog.c	/^        uint8_t val;$/;"	l	language:C
val	lazyfree.c	/^        robj *val = dictGetVal(de);$/;"	l	language:C
val	module.c	/^    } val;$/;"	m	language:C	struct:RedisModuleCallReply	typeref:union:RedisModuleCallReply::__anon19	file:	access:public
val	modules/helloworld.c	/^        long long val;$/;"	l	language:C
val	modules/testmodule.c	/^    long long val = RedisModule_CallReplyInteger(reply);$/;"	l	language:C
val	rdb.c	/^        robj *key, *val;$/;"	l	language:C
val	rdb.c	/^    char *val = NULL;$/;"	l	language:C
val	rdb.c	/^    long long val;$/;"	l	language:C
val	redis-check-rdb.c	/^        robj *key, *val;$/;"	l	language:C
val	redis-cli.c	/^                char val[6];$/;"	l	language:C
val	sort.c	/^                    robj *val = lookupKeyByPattern(c->db,sop->pattern,$/;"	l	language:C
val	sort.c	/^                robj *val = lookupKeyByPattern(c->db,sop->pattern,$/;"	l	language:C
val	util.c	/^    long long val;$/;"	l	language:C
valDestructor	dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	language:C	struct:dictType	access:public
valDup	dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	language:C	struct:dictType	access:public
valenc	intset.c	/^    uint8_t valenc = _intsetValueEncoding(value);$/;"	l	language:C
valid_up_to	aof.c	/^    off_t valid_up_to = 0; \/* Offset of the latest well-formed command loaded. *\/$/;"	l	language:C
vals	quicklist.c	/^                char *vals[] = {"abc", "def", "jkl", "oop"};$/;"	l	language:C
value	adlist.c	/^        void *value;$/;"	l	language:C
value	adlist.h	/^    void *value;$/;"	m	language:C	struct:listNode	access:public
value	aof.c	/^        sds value = hashTypeCurrentFromHashTable(hi, what);$/;"	l	language:C
value	bitops.c	/^    int64_t value;$/;"	l	language:C
value	bitops.c	/^    uint64_t byte, bit, byteval, bitval, j, value = 0;$/;"	l	language:C
value	config.c	/^    int value = server.syslog_facility;$/;"	l	language:C
value	intset.c	/^    uint64_t value;$/;"	l	language:C
value	module.c	/^        RedisModuleString *field, *value;$/;"	l	language:C
value	module.c	/^    double value;$/;"	l	language:C
value	module.c	/^    robj *value;    \/* Value object, or NULL if the key was not found. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
value	module.c	/^    robj *value;$/;"	l	language:C
value	module.c	/^    uint64_t value;$/;"	l	language:C
value	modules/API.md	/^Return the key expire value, as milliseconds of remaining TTL.$/;"	v	language:C
value	modules/API.md	/^hash value, in order to set the specified field.$/;"	v	language:C
value	modules/TYPES.md	/^When the RDB file is loaded back, it reads the 64 bit value, masks the final$/;"	v	language:C
value	modules/TYPES.md	/^value, it needs help from the module in order to release the memory. This$/;"	v	language:C
value	modules/hellotype.c	/^    int64_t value;$/;"	m	language:C	struct:HelloTypeNode	file:	access:public
value	modules/hellotype.c	/^    long long value;$/;"	l	language:C
value	object.c	/^    double value;$/;"	l	language:C
value	object.c	/^    long double value;$/;"	l	language:C
value	object.c	/^    long long value;$/;"	l	language:C
value	object.c	/^    long value;$/;"	l	language:C
value	quicklist.c	/^    unsigned char *value;$/;"	l	language:C
value	quicklist.h	/^    unsigned char *value;$/;"	m	language:C	struct:quicklistEntry	access:public
value	rdb.c	/^                sds value = dictGetVal(de);$/;"	l	language:C
value	rdb.c	/^        sds field, value;$/;"	l	language:C
value	rdb.c	/^    long long value;$/;"	l	language:C
value	redis-cli.c	/^    char *value = getInfoField(info,field);$/;"	l	language:C
value	scripting.c	/^    long long value;$/;"	l	language:C
value	sentinel.c	/^    char *option, *value;$/;"	l	language:C
value	server.h	/^    void *value;$/;"	m	language:C	struct:moduleValue	access:public
value	sparkline.h	/^    double value;$/;"	m	language:C	struct:sample	access:public
value	t_hash.c	/^            sds key, value;$/;"	l	language:C
value	t_hash.c	/^        sds value = hashTypeCurrentFromHashTable(hi, what);$/;"	l	language:C
value	t_hash.c	/^        sds value = hashTypeGetFromHashTable(o, field);$/;"	l	language:C
value	t_hash.c	/^        sds value;$/;"	l	language:C
value	t_hash.c	/^    long double value, incr;$/;"	l	language:C
value	t_hash.c	/^    long long value, incr, oldvalue;$/;"	l	language:C
value	t_list.c	/^                        robj *value = listTypePop(o,where);$/;"	l	language:C
value	t_list.c	/^                    robj *value = listTypePop(o,where);$/;"	l	language:C
value	t_list.c	/^    robj *sobj, *value;$/;"	l	language:C
value	t_list.c	/^    robj *value = NULL;$/;"	l	language:C
value	t_list.c	/^    robj *value = c->argv[3];$/;"	l	language:C
value	t_string.c	/^    long double incr, value;$/;"	l	language:C
value	t_string.c	/^    long long value, oldvalue;$/;"	l	language:C
value	t_string.c	/^    sds value = c->argv[3]->ptr;$/;"	l	language:C
value	t_zset.c	/^                double score, value;$/;"	l	language:C
value	t_zset.c	/^    sds value = ziplistGetObject(p);$/;"	l	language:C
value	util.c	/^    long double value;$/;"	l	language:C
value	util.c	/^    unsigned long long value;$/;"	l	language:C
value	ziplist.c	/^    long long value = 123456789; \/* initialized to avoid warning. Using a value$/;"	l	language:C
value	ziplist.c	/^    long long value;$/;"	l	language:C
value	zipmap.c	/^        unsigned char *key, *value;$/;"	l	language:C
value	zipmap.c	/^        unsigned char *value;$/;"	l	language:C
valueptr	module.c	/^        RedisModuleString *field, **valueptr;$/;"	l	language:C
values	modules/TYPES.md	/^        double *values;$/;"	m	language:C	struct:double_array	file:	access:public
values	modules/TYPES.md	/^double values, with the following structure:$/;"	v	language:C
vars	scripting.c	/^    int vars = 0;$/;"	l	language:C
vbuf	t_zset.c	/^    unsigned char vbuf[32];$/;"	l	language:C
vecswap	pqsort.c	/^#define vecswap(/;"	d	language:C	file:
vector	modules/INTRO.md	/^to all the other API calls, the command argument vector, and total number$/;"	v	language:C
vector	sds.c	/^    char **vector = NULL;$/;"	l	language:C
vector	sort.c	/^    redisSortObject *vector; \/* Resulting vector to sort *\/$/;"	l	language:C
vectorlen	sort.c	/^    int j, dontsort = 0, vectorlen;$/;"	l	language:C
vempty	zipmap.c	/^    unsigned int empty, vempty;$/;"	l	language:C
vencoding	ziplist.c	/^    unsigned char vencoding = 0;$/;"	l	language:C
ver	cluster.h	/^    uint16_t ver;       \/* Protocol version, currently set to 0. *\/$/;"	m	language:C	struct:__anon10	access:public
ver	module.c	/^    int ver;        \/* Module version. We use just progressive integers. *\/$/;"	m	language:C	struct:RedisModule	file:	access:public
verbosity	server.h	/^    int verbosity;                  \/* Loglevel in redis.conf *\/$/;"	m	language:C	struct:redisServer	access:public
verify	ziplist.c	/^static void verify(unsigned char *zl, zlentry *e) {$/;"	f	language:C	file:	signature:(unsigned char *zl, zlentry *e)
verifyClusterConfigWithData	cluster.c	/^int verifyClusterConfigWithData(void) {$/;"	f	language:C	signature:(void)
verifyClusterConfigWithData	server.h	/^int verifyClusterConfigWithData(void);$/;"	p	language:C	signature:(void)
verifyDumpPayload	cluster.c	/^int verifyDumpPayload(unsigned char *p, size_t len) {$/;"	f	language:C	signature:(unsigned char *p, size_t len)
version	redis-cli.c	/^            sds version = cliVersion();$/;"	l	language:C
version	redis-cli.c	/^    sds version = cliVersion();$/;"	l	language:C
version	redis-cli.c	/^    sds version;$/;"	l	language:C
version	server.c	/^void version(void) {$/;"	f	language:C	signature:(void)
vkeys	server.c	/^            long long keys, vkeys;$/;"	l	language:C
vkeys	server.c	/^            long long size, used, vkeys;$/;"	l	language:C
vlen	aof.c	/^        unsigned int vlen = UINT_MAX;$/;"	l	language:C
vlen	aof.c	/^        unsigned int vlen;$/;"	l	language:C
vlen	config.c	/^        int vlen, j;$/;"	l	language:C
vlen	db.c	/^        unsigned int vlen;$/;"	l	language:C
vlen	debug.c	/^                    unsigned int vlen;$/;"	l	language:C
vlen	geo.c	/^        unsigned int vlen = 0;$/;"	l	language:C
vlen	module.c	/^             size_t vlen = va_arg(ap, size_t);$/;"	l	language:C
vlen	quicklist.c	/^    unsigned int vlen;$/;"	l	language:C
vlen	rdb.c	/^                    unsigned int flen, vlen;$/;"	l	language:C
vlen	rdb.c	/^    int vlen = ll2string(buf,sizeof(buf),val);$/;"	l	language:C
vlen	t_hash.c	/^        unsigned int vlen = UINT_MAX;$/;"	l	language:C
vlen	t_hash.c	/^    unsigned int vlen;$/;"	l	language:C
vlen	t_zset.c	/^        unsigned int vlen;$/;"	l	language:C
vlen	t_zset.c	/^    unsigned int vlen;$/;"	l	language:C
vlen	ziplist.c	/^    unsigned int vlen;$/;"	l	language:C
vlen	zipmap.c	/^        unsigned int klen, vlen;$/;"	l	language:C
vlen	zipmap.c	/^        unsigned int vlen, i;$/;"	l	language:C
vlen	zipmap.c	/^        unsigned int vlen;$/;"	l	language:C
vll	aof.c	/^        long long vll = LLONG_MAX;$/;"	l	language:C
vll	aof.c	/^        long long vll;$/;"	l	language:C
vll	db.c	/^        long long vll;$/;"	l	language:C
vll	debug.c	/^                    long long vll;$/;"	l	language:C
vll	t_hash.c	/^        long long vll = LLONG_MAX;$/;"	l	language:C
vll	t_hash.c	/^    long long vll;$/;"	l	language:C
vll	ziplist.c	/^    long long vll = 0;$/;"	l	language:C
vlong	geo.c	/^        long long vlong = 0;$/;"	l	language:C
vlong	quicklist.c	/^    long long vlong;$/;"	l	language:C
vlong	t_list.c	/^    long long vlong;$/;"	l	language:C
vlong	t_zset.c	/^        long long vlong;$/;"	l	language:C
vlong	t_zset.c	/^    long long vlong;$/;"	l	language:C
vlong	ziplist.c	/^    long long vlong;$/;"	l	language:C
voted_time	cluster.h	/^    mstime_t voted_time;     \/* Last time we voted for a slave of this master *\/$/;"	m	language:C	struct:clusterNode	access:public
voters	sentinel.c	/^    int voters = dictSize(master->sentinels)+1; \/* Known Sentinels + myself. *\/$/;"	l	language:C
voters	sentinel.c	/^    unsigned int voters = 0, voters_quorum;$/;"	l	language:C
voters_quorum	sentinel.c	/^    unsigned int voters = 0, voters_quorum;$/;"	l	language:C
votes	sentinel.c	/^        uint64_t votes = dictGetUnsignedIntegerVal(de);$/;"	l	language:C
votes	sentinel.c	/^        uint64_t votes = sentinelLeaderIncr(counters,myvote);$/;"	l	language:C
votes	sentinel.c	/^    unsigned long votes;$/;"	m	language:C	struct:sentinelLeader	file:	access:public
vptr	server.h	/^    unsigned char *fptr, *vptr;$/;"	m	language:C	struct:__anon34	access:public
vptr	t_hash.c	/^        unsigned char *fptr, *vptr;$/;"	l	language:C
vptr	t_hash.c	/^        unsigned char *zl, *fptr, *vptr;$/;"	l	language:C
vptr	t_hash.c	/^    unsigned char *zl, *fptr = NULL, *vptr = NULL;$/;"	l	language:C
vstr	aof.c	/^        unsigned char *vstr = NULL;$/;"	l	language:C
vstr	aof.c	/^        unsigned char *vstr;$/;"	l	language:C
vstr	db.c	/^        unsigned char *vstr;$/;"	l	language:C
vstr	debug.c	/^                    unsigned char *vstr;$/;"	l	language:C
vstr	geo.c	/^        unsigned char *vstr = NULL;$/;"	l	language:C
vstr	quicklist.c	/^    unsigned char *vstr;$/;"	l	language:C
vstr	rdb.c	/^                    unsigned char *fstr, *vstr;$/;"	l	language:C
vstr	t_hash.c	/^        unsigned char *vstr = NULL;$/;"	l	language:C
vstr	t_hash.c	/^    unsigned char *vstr;$/;"	l	language:C
vstr	t_zset.c	/^        unsigned char *vstr;$/;"	l	language:C
vstr	t_zset.c	/^    unsigned char *vstr;$/;"	l	language:C
vstr	ziplist.c	/^    unsigned char *p, *vstr;$/;"	l	language:C
w	memtest.c	/^    unsigned long off, w, *l1, *l2, v;$/;"	l	language:C
w	memtest.c	/^    unsigned long off, w, *l1, *l2;$/;"	l	language:C
w	memtest.c	/^    unsigned long w, *l1, *l2;$/;"	l	language:C
wait	syncio.c	/^        long long wait = (remaining > SYNCIO__RESOLUTION) ?$/;"	l	language:C
waitCommand	replication.c	/^void waitCommand(client *c) {$/;"	f	language:C	signature:(client *c)
waitCommand	server.h	/^void waitCommand(client *c);$/;"	p	language:C	signature:(client *c)
wait_time	sentinel.c	/^            mstime_t wait_time = SENTINEL_PUBLISH_PERIOD*4;$/;"	l	language:C
wait_time	sentinel.c	/^        mstime_t wait_time = ri->master->failover_timeout;$/;"	l	language:C
want	modules/INTRO.md	/^However, if you want, you can create new string objects using the following$/;"	v	language:C	file:
want	modules/INTRO.md	/^in your source tree, link all the libraries you want, and create$/;"	v	language:C
wanted	cluster.c	/^    int wanted; \/* Number of gossip sections we want to append if possible. *\/$/;"	l	language:C
was_empty	config.c	/^    int j, was_empty = 0;$/;"	l	language:C
watchCommand	multi.c	/^void watchCommand(client *c) {$/;"	f	language:C	signature:(client *c)
watchCommand	server.h	/^void watchCommand(client *c);$/;"	p	language:C	signature:(client *c)
watchForKey	multi.c	/^void watchForKey(client *c, robj *key) {$/;"	f	language:C	signature:(client *c, robj *key)
watchdogScheduleSignal	debug.c	/^void watchdogScheduleSignal(int period) {$/;"	f	language:C	signature:(int period)
watchdogScheduleSignal	server.h	/^void watchdogScheduleSignal(int period);$/;"	p	language:C	signature:(int period)
watchdogSignalHandler	debug.c	/^void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {$/;"	f	language:C	signature:(int sig, siginfo_t *info, void *secret)
watchdog_period	server.h	/^    int watchdog_period;  \/* Software watchdog period in ms. 0 = off *\/$/;"	m	language:C	struct:redisServer	access:public
watchedKey	multi.c	/^typedef struct watchedKey {$/;"	s	language:C	file:
watchedKey	multi.c	/^} watchedKey;$/;"	t	language:C	typeref:struct:watchedKey	file:
watchedKey::db	multi.c	/^    redisDb *db;$/;"	m	language:C	struct:watchedKey	file:	access:public
watchedKey::key	multi.c	/^    robj *key;$/;"	m	language:C	struct:watchedKey	file:	access:public
watched_keys	server.h	/^    dict *watched_keys;         \/* WATCHED keys for MULTI\/EXEC CAS *\/$/;"	m	language:C	struct:redisDb	access:public
watched_keys	server.h	/^    list *watched_keys;     \/* Keys WATCHED for MULTI\/EXEC CAS *\/$/;"	m	language:C	struct:client	access:public
way	modules/INTRO.md	/^be accessed using in the following way, making sure to never write to$/;"	v	language:C
weight	t_zset.c	/^    double weight;$/;"	m	language:C	struct:__anon40	file:	access:public
west	geohash.h	/^    GeoHashBits west;$/;"	m	language:C	struct:__anon17	access:public
west	geohash_helper.c	/^        GeoHashArea north, south, east, west;$/;"	l	language:C
wfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	language:C	struct:aeApiState	file:	access:public
wfileProc	ae.h	/^    aeFileProc *wfileProc;$/;"	m	language:C	struct:aeFileEvent	access:public
when	aof.c	/^    long long when;$/;"	l	language:C
when	db.c	/^    mstime_t when = getExpire(db,key);$/;"	l	language:C
when	expire.c	/^    long long when; \/* unix time in milliseconds when the key will expire. *\/$/;"	l	language:C
when_ms	ae.c	/^    long cur_sec, cur_ms, when_sec, when_ms;$/;"	l	language:C
when_ms	ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	language:C	struct:aeTimeEvent	access:public
when_sec	ae.c	/^    long cur_sec, cur_ms, when_sec, when_ms;$/;"	l	language:C
when_sec	ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	language:C	struct:aeTimeEvent	access:public
where	t_list.c	/^                        int where = (receiver->lastcmd &&$/;"	l	language:C
where	t_list.c	/^    int where;$/;"	l	language:C
where	ziplist.c	/^        int i,j,len,where;$/;"	l	language:C
wide	modules/INTRO.md	/^in some `static` global variable that can be accessed module wide, so that$/;"	v	language:C	file:
winner	sentinel.c	/^    char *winner = NULL;$/;"	l	language:C
withcoords	geo.c	/^    int withdist = 0, withhash = 0, withcoords = 0;$/;"	l	language:C
withdist	geo.c	/^    int withdist = 0, withhash = 0, withcoords = 0;$/;"	l	language:C
withhash	geo.c	/^    int withdist = 0, withhash = 0, withcoords = 0;$/;"	l	language:C
withscores	t_zset.c	/^    int withscores = 0;$/;"	l	language:C
wk	multi.c	/^            watchedKey *wk = listNodeValue(ln);$/;"	l	language:C
wk	multi.c	/^        watchedKey *wk;$/;"	l	language:C
wk	multi.c	/^    watchedKey *wk;$/;"	l	language:C
woff	server.h	/^    long long woff;         \/* Last write global replication offset. *\/$/;"	m	language:C	struct:client	access:public
word	bitops.c	/^    unsigned long skipval, word = 0, one;$/;"	l	language:C
word	hyperloglog.c	/^    uint64_t *word = (uint64_t*) registers;$/;"	l	language:C
words	memtest.c	/^    unsigned long words = bytes\/sizeof(unsigned long);$/;"	l	language:C
words	memtest.c	/^    unsigned long words = bytes\/sizeof(unsigned long)\/2;$/;"	l	language:C
words	quicklist.c	/^                char *words[] = {"abc", "foo", "bar",  "foobar", "foobared",$/;"	l	language:C
work_done	server.c	/^                int work_done = incrementallyRehash(rehash_db % server.dbnum);$/;"	l	language:C
wrapped	bitops.c	/^                int64_t oldval, newval, wrapped, retval;$/;"	l	language:C
wrapped	bitops.c	/^                uint64_t oldval, newval, wrapped, retval;$/;"	l	language:C
write	rio.h	/^    size_t (*write)(struct _rio *, const void *buf, size_t len);$/;"	m	language:C	struct:_rio	access:public
writeHandler	redis-benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	language:C	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
writeHandler	redis-benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	language:C	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
writeToClient	networking.c	/^int writeToClient(int fd, client *c, int handler_installed) {$/;"	f	language:C	signature:(int fd, client *c, int handler_installed)
writeToClient	server.h	/^int writeToClient(int fd, client *c, int handler_installed);$/;"	p	language:C	signature:(int fd, client *c, int handler_installed)
write_error	cluster.c	/^    int write_error = 0;$/;"	l	language:C
writing	sentinel.c	/^    int reading, writing;$/;"	m	language:C	struct:redisAeEvents	file:	access:public
written	redis-benchmark.c	/^    size_t written;         \/* Bytes of 'obuf' already written *\/$/;"	m	language:C	struct:_client	file:	access:public
wrongtypeerr	server.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	language:C	struct:sharedObjectsStruct	access:public
ws	memtest.c	/^static struct winsize ws;$/;"	v	language:C	typeref:struct:winsize	file:
x	endianconv.c	/^    unsigned char *x = p, t;$/;"	l	language:C
x	geohash.c	/^    uint64_t x = interleaved;$/;"	l	language:C
x	geohash.c	/^    uint64_t x = xlo;$/;"	l	language:C
x	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	language:C	file:
x	sds.c	/^        sds x = sdsnew("foo"), y;$/;"	l	language:C
x	t_zset.c	/^    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;$/;"	l	language:C
x	t_zset.c	/^    zskiplistNode *x;$/;"	l	language:C
x	util.c	/^        char *x = p;$/;"	l	language:C
x	zmalloc.c	/^    char *p, *x;$/;"	l	language:C
xample	modules/TYPES.md	/^the raw string saving API to, for example, save a structure on disk, you$/;"	v	language:C
xorDigest	debug.c	/^void xorDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f	language:C	signature:(unsigned char *digest, void *ptr, size_t len)
xorObjectDigest	debug.c	/^void xorObjectDigest(unsigned char *digest, robj *o) {$/;"	f	language:C	signature:(unsigned char *digest, robj *o)
xorshift64star_next	memtest.c	/^#define xorshift64star_next(/;"	d	language:C	file:
xx	t_zset.c	/^    int xx = (*flags & ZADD_XX) != 0;$/;"	l	language:C
xx	t_zset.c	/^    int xx = (flags & ZADD_XX) != 0;$/;"	l	language:C
xy	geo.c	/^            double xy[2];$/;"	l	language:C
xy	geo.c	/^        double xy[2];$/;"	l	language:C
xy	geo.c	/^    double distance, xy[2];$/;"	l	language:C
xy	geo.c	/^    double xy[2] = { 0 };$/;"	l	language:C
xyxy	geo.c	/^    double score1, score2, xyxy[4];$/;"	l	language:C
xzero	hyperloglog.c	/^        int xzero = HLL_SPARSE_XZERO_MAX_LEN;$/;"	l	language:C
y	geohash.c	/^    uint64_t y = hash->bits & 0x5555555555555555ULL;$/;"	l	language:C
y	geohash.c	/^    uint64_t y = interleaved >> 1;$/;"	l	language:C
y	geohash.c	/^    uint64_t y = ylo;$/;"	l	language:C
y	sds.c	/^        sds x = sdsnew("foo"), y;$/;"	l	language:C
yell	quicklist.c	/^#define yell(/;"	d	language:C	file:
yes	anet.c	/^    int yes = 1;$/;"	l	language:C
yes	config.c	/^            int yes;$/;"	l	language:C
yesnotoi	config.c	/^int yesnotoi(char *s) {$/;"	f	language:C	signature:(char *s)
yesnotoi	sentinel.c	/^int yesnotoi(char *s);$/;"	p	language:C	file:	signature:(char *s)
zaddCommand	server.h	/^void zaddCommand(client *c);$/;"	p	language:C	signature:(client *c)
zaddCommand	t_zset.c	/^void zaddCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zaddGenericCommand	t_zset.c	/^void zaddGenericCommand(client *c, int flags) {$/;"	f	language:C	signature:(client *c, int flags)
zcalloc	zmalloc.c	/^void *zcalloc(size_t size) {$/;"	f	language:C	signature:(size_t size)
zcalloc	zmalloc.h	/^void *zcalloc(size_t size);$/;"	p	language:C	signature:(size_t size)
zcardCommand	server.h	/^void zcardCommand(client *c);$/;"	p	language:C	signature:(client *c)
zcardCommand	t_zset.c	/^void zcardCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zcountCommand	server.h	/^void zcountCommand(client *c);$/;"	p	language:C	signature:(client *c)
zcountCommand	t_zset.c	/^void zcountCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zcurrent	module.c	/^    void *zcurrent;         \/* Zset iterator current node. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
zend	module.c	/^    uint32_t zend;          \/* End pos for positional ranges. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
zer	module.c	/^    int zer;                \/* Zset iterator end reached flag$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
zero	modules/API.md	/^3. If the returned pointer is not NULL, but the length is zero, no$/;"	v	language:C
zfree	zmalloc.c	/^void zfree(void *ptr) {$/;"	f	language:C	signature:(void *ptr)
zfree	zmalloc.h	/^void zfree(void *ptr);$/;"	p	language:C	signature:(void *ptr)
zi	quicklist.h	/^    unsigned char *zi;$/;"	m	language:C	struct:quicklistEntry	access:public
zi	quicklist.h	/^    unsigned char *zi;$/;"	m	language:C	struct:quicklistIter	access:public
zi	rdb.c	/^                    unsigned char *zi = zipmapRewind(o->ptr);$/;"	l	language:C
zincrbyCommand	server.h	/^void zincrbyCommand(client *c);$/;"	p	language:C	signature:(client *c)
zincrbyCommand	t_zset.c	/^void zincrbyCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zinterstoreCommand	server.h	/^void zinterstoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
zinterstoreCommand	t_zset.c	/^void zinterstoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zipEncodeLength	ziplist.c	/^static unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) {$/;"	f	language:C	file:	signature:(unsigned char *p, unsigned char encoding, unsigned int rawlen)
zipEntry	ziplist.c	/^static void zipEntry(unsigned char *p, zlentry *e) {$/;"	f	language:C	file:	signature:(unsigned char *p, zlentry *e)
zipIntSize	ziplist.c	/^static unsigned int zipIntSize(unsigned char encoding) {$/;"	f	language:C	file:	signature:(unsigned char encoding)
zipLoadInteger	ziplist.c	/^static int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {$/;"	f	language:C	file:	signature:(unsigned char *p, unsigned char encoding)
zipPrevEncodeLength	ziplist.c	/^static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	language:C	file:	signature:(unsigned char *p, unsigned int len)
zipPrevEncodeLengthForceLarge	ziplist.c	/^static void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len) {$/;"	f	language:C	file:	signature:(unsigned char *p, unsigned int len)
zipPrevLenByteDiff	ziplist.c	/^static int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {$/;"	f	language:C	file:	signature:(unsigned char *p, unsigned int len)
zipRawEntryLength	ziplist.c	/^static unsigned int zipRawEntryLength(unsigned char *p) {$/;"	f	language:C	file:	signature:(unsigned char *p)
zipSaveInteger	ziplist.c	/^static void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {$/;"	f	language:C	file:	signature:(unsigned char *p, int64_t value, unsigned char encoding)
zipTryEncoding	ziplist.c	/^static int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {$/;"	f	language:C	file:	signature:(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding)
ziplistBlobLen	ziplist.c	/^size_t ziplistBlobLen(unsigned char *zl) {$/;"	f	language:C	signature:(unsigned char *zl)
ziplistBlobLen	ziplist.h	/^size_t ziplistBlobLen(unsigned char *zl);$/;"	p	language:C	signature:(unsigned char *zl)
ziplistCompare	ziplist.c	/^unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {$/;"	f	language:C	signature:(unsigned char *p, unsigned char *sstr, unsigned int slen)
ziplistCompare	ziplist.h	/^unsigned int ziplistCompare(unsigned char *p, unsigned char *s, unsigned int slen);$/;"	p	language:C	signature:(unsigned char *p, unsigned char *s, unsigned int slen)
ziplistDelete	ziplist.c	/^unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char **p)
ziplistDelete	ziplist.h	/^unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);$/;"	p	language:C	signature:(unsigned char *zl, unsigned char **p)
ziplistDeleteRange	ziplist.c	/^unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {$/;"	f	language:C	signature:(unsigned char *zl, int index, unsigned int num)
ziplistDeleteRange	ziplist.h	/^unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num);$/;"	p	language:C	signature:(unsigned char *zl, int index, unsigned int num)
ziplistFind	ziplist.c	/^unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {$/;"	f	language:C	signature:(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip)
ziplistFind	ziplist.h	/^unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);$/;"	p	language:C	signature:(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip)
ziplistGet	ziplist.c	/^unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {$/;"	f	language:C	signature:(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval)
ziplistGet	ziplist.h	/^unsigned int ziplistGet(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval);$/;"	p	language:C	signature:(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval)
ziplistGetObject	server.h	/^sds ziplistGetObject(unsigned char *sptr);$/;"	p	language:C	signature:(unsigned char *sptr)
ziplistGetObject	t_zset.c	/^sds ziplistGetObject(unsigned char *sptr) {$/;"	f	language:C	signature:(unsigned char *sptr)
ziplistIndex	ziplist.c	/^        zipEntry(ziplistIndex(zl, i), &e[i]);$/;"	p	language:C	file:
ziplistIndex	ziplist.c	/^unsigned char *ziplistIndex(unsigned char *zl, int index) {$/;"	f	language:C	signature:(unsigned char *zl, int index)
ziplistIndex	ziplist.h	/^unsigned char *ziplistIndex(unsigned char *zl, int index);$/;"	p	language:C	signature:(unsigned char *zl, int index)
ziplistInsert	ziplist.c	/^unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)
ziplistInsert	ziplist.h	/^unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);$/;"	p	language:C	signature:(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)
ziplistLen	ziplist.c	/^unsigned int ziplistLen(unsigned char *zl) {$/;"	f	language:C	signature:(unsigned char *zl)
ziplistLen	ziplist.h	/^unsigned int ziplistLen(unsigned char *zl);$/;"	p	language:C	signature:(unsigned char *zl)
ziplistMerge	ziplist.c	/^unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {$/;"	f	language:C	signature:(unsigned char **first, unsigned char **second)
ziplistMerge	ziplist.h	/^unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);$/;"	p	language:C	signature:(unsigned char **first, unsigned char **second)
ziplistNew	ziplist.c	/^unsigned char *ziplistNew(void) {$/;"	f	language:C	signature:(void)
ziplistNew	ziplist.h	/^unsigned char *ziplistNew(void);$/;"	p	language:C	signature:(void)
ziplistNext	ziplist.c	/^unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char *p)
ziplistNext	ziplist.h	/^unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);$/;"	p	language:C	signature:(unsigned char *zl, unsigned char *p)
ziplistPrev	ziplist.c	/^unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char *p)
ziplistPrev	ziplist.h	/^unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);$/;"	p	language:C	signature:(unsigned char *zl, unsigned char *p)
ziplistPush	ziplist.c	/^unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char *s, unsigned int slen, int where)
ziplistPush	ziplist.h	/^unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);$/;"	p	language:C	signature:(unsigned char *zl, unsigned char *s, unsigned int slen, int where)
ziplistRepr	ziplist.c	/^void ziplistRepr(unsigned char *zl) {$/;"	f	language:C	signature:(unsigned char *zl)
ziplistRepr	ziplist.c	/^void ziplistRepr(unsigned char *zl);$/;"	p	language:C	file:	signature:(unsigned char *zl)
ziplistResize	ziplist.c	/^static unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {$/;"	f	language:C	file:	signature:(unsigned char *zl, unsigned int len)
ziplistTest	ziplist.c	/^int ziplistTest(int argc, char **argv) {$/;"	f	language:C	signature:(int argc, char **argv)
ziplistTest	ziplist.h	/^int ziplistTest(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
ziplist_overhead	quicklist.c	/^    int ziplist_overhead;$/;"	l	language:C
zipmapBlobLen	zipmap.c	/^size_t zipmapBlobLen(unsigned char *zm) {$/;"	f	language:C	signature:(unsigned char *zm)
zipmapBlobLen	zipmap.h	/^size_t zipmapBlobLen(unsigned char *zm);$/;"	p	language:C	signature:(unsigned char *zm)
zipmapDecodeLength	zipmap.c	/^static unsigned int zipmapDecodeLength(unsigned char *p) {$/;"	f	language:C	file:	signature:(unsigned char *p)
zipmapDel	zipmap.c	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {$/;"	f	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted)
zipmapDel	zipmap.h	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);$/;"	p	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted)
zipmapEncodeLength	zipmap.c	/^static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	language:C	file:	signature:(unsigned char *p, unsigned int len)
zipmapExists	zipmap.c	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {$/;"	f	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen)
zipmapExists	zipmap.h	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);$/;"	p	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen)
zipmapGet	zipmap.c	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {$/;"	f	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen)
zipmapGet	zipmap.h	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);$/;"	p	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen)
zipmapLen	zipmap.c	/^unsigned int zipmapLen(unsigned char *zm) {$/;"	f	language:C	signature:(unsigned char *zm)
zipmapLen	zipmap.h	/^unsigned int zipmapLen(unsigned char *zm);$/;"	p	language:C	signature:(unsigned char *zm)
zipmapLookupRaw	zipmap.c	/^static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {$/;"	f	language:C	file:	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen)
zipmapNew	zipmap.c	/^unsigned char *zipmapNew(void) {$/;"	f	language:C	signature:(void)
zipmapNew	zipmap.h	/^unsigned char *zipmapNew(void);$/;"	p	language:C	signature:(void)
zipmapNext	zipmap.c	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {$/;"	f	language:C	signature:(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen)
zipmapNext	zipmap.h	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen);$/;"	p	language:C	signature:(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen)
zipmapRawEntryLength	zipmap.c	/^static unsigned int zipmapRawEntryLength(unsigned char *p) {$/;"	f	language:C	file:	signature:(unsigned char *p)
zipmapRawKeyLength	zipmap.c	/^static unsigned int zipmapRawKeyLength(unsigned char *p) {$/;"	f	language:C	file:	signature:(unsigned char *p)
zipmapRawValueLength	zipmap.c	/^static unsigned int zipmapRawValueLength(unsigned char *p) {$/;"	f	language:C	file:	signature:(unsigned char *p)
zipmapRepr	zipmap.c	/^static void zipmapRepr(unsigned char *p) {$/;"	f	language:C	file:	signature:(unsigned char *p)
zipmapRepr	zipmap.h	/^void zipmapRepr(unsigned char *p);$/;"	p	language:C	signature:(unsigned char *p)
zipmapRequiredLength	zipmap.c	/^static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {$/;"	f	language:C	file:	signature:(unsigned int klen, unsigned int vlen)
zipmapResize	zipmap.c	/^static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {$/;"	f	language:C	file:	signature:(unsigned char *zm, unsigned int len)
zipmapRewind	zipmap.c	/^unsigned char *zipmapRewind(unsigned char *zm) {$/;"	f	language:C	signature:(unsigned char *zm)
zipmapRewind	zipmap.h	/^unsigned char *zipmapRewind(unsigned char *zm);$/;"	p	language:C	signature:(unsigned char *zm)
zipmapSet	zipmap.c	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {$/;"	f	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update)
zipmapSet	zipmap.h	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);$/;"	p	language:C	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update)
zipmapTest	zipmap.c	/^int zipmapTest(int argc, char *argv[]) {$/;"	f	language:C	signature:(int argc, char *argv[])
zipmapTest	zipmap.h	/^int zipmapTest(int argc, char *argv[]);$/;"	p	language:C	signature:(int argc, char *argv[])
zl	aof.c	/^        unsigned char *zl = o->ptr;$/;"	l	language:C
zl	debug.c	/^                    unsigned char *zl = o->ptr;$/;"	l	language:C
zl	geo.c	/^        unsigned char *zl = zobj->ptr;$/;"	l	language:C
zl	module.c	/^        unsigned char *zl = key->value->ptr;$/;"	l	language:C
zl	object.c	/^    unsigned char *zl = ziplistNew();$/;"	l	language:C
zl	quicklist.c	/^                unsigned char *zl = ziplistNew();$/;"	l	language:C
zl	quicklist.h	/^    unsigned char *zl;$/;"	m	language:C	struct:quicklistNode	access:public
zl	rdb.c	/^                    unsigned char *zl = ziplistNew();$/;"	l	language:C
zl	rdb.c	/^            unsigned char *zl =$/;"	l	language:C
zl	t_hash.c	/^        unsigned char *zl, *fptr, *vptr;$/;"	l	language:C
zl	t_hash.c	/^        unsigned char *zl, *fptr;$/;"	l	language:C
zl	t_hash.c	/^        unsigned char *zl;$/;"	l	language:C
zl	t_hash.c	/^    unsigned char *zl, *fptr = NULL, *vptr = NULL;$/;"	l	language:C
zl	t_zset.c	/^                unsigned char *zl;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
zl	t_zset.c	/^            } zl;$/;"	m	language:C	union:__anon40::__anon41::_iterzset	typeref:struct:__anon40::__anon41::_iterzset::__anon44	file:	access:public
zl	t_zset.c	/^        unsigned char *zl = ziplistNew();$/;"	l	language:C
zl	t_zset.c	/^        unsigned char *zl = zobj->ptr;$/;"	l	language:C
zl	ziplist.c	/^    unsigned char *zl = ziplistNew();$/;"	l	language:C
zl	ziplist.c	/^    unsigned char *zl = zmalloc(bytes);$/;"	l	language:C
zl	ziplist.c	/^    unsigned char *zl, *p;$/;"	l	language:C
zl	ziplist.c	/^    unsigned char *zl;$/;"	l	language:C
zl2	ziplist.c	/^        unsigned char *zl2 = createList();$/;"	l	language:C
zl3	ziplist.c	/^        unsigned char *zl3 = ziplistNew();$/;"	l	language:C
zl4	ziplist.c	/^        unsigned char *zl4 = ziplistNew();$/;"	l	language:C
zl_sz	quicklist.c	/^    size_t zl_sz = node->sz;$/;"	l	language:C
zlbytes	ziplist.c	/^    size_t zlbytes = first_bytes + second_bytes -$/;"	l	language:C
zlen	t_list.c	/^        size_t zlen = server.list_max_ziplist_size;$/;"	l	language:C
zlentry	ziplist.c	/^typedef struct zlentry {$/;"	s	language:C	file:
zlentry	ziplist.c	/^} zlentry;$/;"	t	language:C	typeref:struct:zlentry	file:
zlentry::encoding	ziplist.c	/^    unsigned char encoding;$/;"	m	language:C	struct:zlentry	file:	access:public
zlentry::headersize	ziplist.c	/^    unsigned int headersize;$/;"	m	language:C	struct:zlentry	file:	access:public
zlentry::len	ziplist.c	/^    unsigned int lensize, len;$/;"	m	language:C	struct:zlentry	file:	access:public
zlentry::lensize	ziplist.c	/^    unsigned int lensize, len;$/;"	m	language:C	struct:zlentry	file:	access:public
zlentry::p	ziplist.c	/^    unsigned char *p;$/;"	m	language:C	struct:zlentry	file:	access:public
zlentry::prevrawlen	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	language:C	struct:zlentry	file:	access:public
zlentry::prevrawlensize	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	language:C	struct:zlentry	file:	access:public
zlexcountCommand	server.h	/^void zlexcountCommand(client *c);$/;"	p	language:C	signature:(client *c)
zlexcountCommand	t_zset.c	/^void zlexcountCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zlexrangespec	server.h	/^} zlexrangespec;$/;"	t	language:C	typeref:struct:__anon36
zlibc_free	zmalloc.c	/^void zlibc_free(void *ptr) {$/;"	f	language:C	signature:(void *ptr)
zlibc_free	zmalloc.h	/^void zlibc_free(void *ptr);$/;"	p	language:C	signature:(void *ptr)
zllength	ziplist.c	/^    size_t zllength = first_len + second_len;$/;"	l	language:C
zlrs	module.c	/^    zlexrangespec *zlrs = &key->zlrs;$/;"	l	language:C
zlrs	module.c	/^    zlexrangespec zlrs;     \/* Lex range. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
zm	zipmap.c	/^    unsigned char *zm = zmalloc(2);$/;"	l	language:C
zm	zipmap.c	/^    unsigned char *zm;$/;"	l	language:C
zmalloc	zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f	language:C	signature:(size_t size)
zmalloc	zmalloc.h	/^void *zmalloc(size_t size);$/;"	p	language:C	signature:(size_t size)
zmalloc_default_oom	zmalloc.c	/^static void zmalloc_default_oom(size_t size) {$/;"	f	language:C	file:	signature:(size_t size)
zmalloc_enable_thread_safeness	zmalloc.c	/^void zmalloc_enable_thread_safeness(void) {$/;"	f	language:C	signature:(void)
zmalloc_enable_thread_safeness	zmalloc.h	/^void zmalloc_enable_thread_safeness(void);$/;"	p	language:C	signature:(void)
zmalloc_get_fragmentation_ratio	zmalloc.c	/^float zmalloc_get_fragmentation_ratio(size_t rss) {$/;"	f	language:C	signature:(size_t rss)
zmalloc_get_fragmentation_ratio	zmalloc.h	/^float zmalloc_get_fragmentation_ratio(size_t rss);$/;"	p	language:C	signature:(size_t rss)
zmalloc_get_memory_size	zmalloc.c	/^size_t zmalloc_get_memory_size(void) {$/;"	f	language:C	signature:(void)
zmalloc_get_memory_size	zmalloc.h	/^size_t zmalloc_get_memory_size(void);$/;"	p	language:C	signature:(void)
zmalloc_get_private_dirty	zmalloc.c	/^size_t zmalloc_get_private_dirty(void) {$/;"	f	language:C	signature:(void)
zmalloc_get_private_dirty	zmalloc.h	/^size_t zmalloc_get_private_dirty(void);$/;"	p	language:C	signature:(void)
zmalloc_get_rss	zmalloc.c	/^size_t zmalloc_get_rss(void) {$/;"	f	language:C	signature:(void)
zmalloc_get_rss	zmalloc.h	/^size_t zmalloc_get_rss(void);$/;"	p	language:C	signature:(void)
zmalloc_get_smap_bytes_by_field	zmalloc.c	/^size_t zmalloc_get_smap_bytes_by_field(char *field) {$/;"	f	language:C	signature:(char *field)
zmalloc_get_smap_bytes_by_field	zmalloc.h	/^size_t zmalloc_get_smap_bytes_by_field(char *field);$/;"	p	language:C	signature:(char *field)
zmalloc_oom_handler	zmalloc.c	/^static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;$/;"	v	language:C	file:
zmalloc_set_oom_handler	zmalloc.c	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {$/;"	f	language:C	signature:(void (*oom_handler)(size_t))
zmalloc_set_oom_handler	zmalloc.h	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t));$/;"	p	language:C	signature:(void (*oom_handler)(size_t))
zmalloc_size	zmalloc.c	/^    update_zmalloc_stat_alloc(zmalloc_size(newptr));$/;"	p	language:C	file:
zmalloc_size	zmalloc.c	/^    update_zmalloc_stat_alloc(zmalloc_size(ptr));$/;"	p	language:C	file:
zmalloc_size	zmalloc.c	/^size_t zmalloc_size(void *ptr) {$/;"	f	language:C	signature:(void *ptr)
zmalloc_size	zmalloc.h	/^#define zmalloc_size(/;"	d	language:C
zmalloc_size	zmalloc.h	/^size_t zmalloc_size(void *ptr);$/;"	p	language:C	signature:(void *ptr)
zmalloc_thread_safe	zmalloc.c	/^static int zmalloc_thread_safe = 0;$/;"	v	language:C	file:
zmalloc_used	server.c	/^        size_t zmalloc_used = zmalloc_used_memory();$/;"	l	language:C
zmalloc_used_memory	zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f	language:C	signature:(void)
zmalloc_used_memory	zmalloc.h	/^size_t zmalloc_used_memory(void);$/;"	p	language:C	signature:(void)
zmlen	zipmap.c	/^    unsigned int zmlen, freelen;$/;"	l	language:C
zmlen	zipmap.c	/^    unsigned int zmlen, offset;$/;"	l	language:C
zn	db.c	/^    zskiplistNode *zn;$/;"	l	language:C
zn	t_zset.c	/^        zskiplistNode *zn;$/;"	l	language:C
zn	t_zset.c	/^    zskiplistNode *zn =$/;"	l	language:C
znode	geo.c	/^            zskiplistNode *znode;$/;"	l	language:C
znode	rdb.c	/^            zskiplistNode *znode;$/;"	l	language:C
znode	t_zset.c	/^        zskiplistNode *znode;$/;"	l	language:C
znode	t_zset.c	/^    zskiplistNode *znode;$/;"	l	language:C
zobj	geo.c	/^        robj *zobj;$/;"	l	language:C
zobj	geo.c	/^    robj *zobj = NULL;$/;"	l	language:C
zobj	t_zset.c	/^    robj *zobj;$/;"	l	language:C
zrangeCommand	server.h	/^void zrangeCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrangeCommand	t_zset.c	/^void zrangeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrangeGenericCommand	t_zset.c	/^void zrangeGenericCommand(client *c, int reverse) {$/;"	f	language:C	signature:(client *c, int reverse)
zrangebylexCommand	server.h	/^void zrangebylexCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrangebylexCommand	t_zset.c	/^void zrangebylexCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrangebyscoreCommand	server.h	/^void zrangebyscoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrangebyscoreCommand	t_zset.c	/^void zrangebyscoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrangespec	server.h	/^} zrangespec;$/;"	t	language:C	typeref:struct:__anon35
zrankCommand	server.h	/^void zrankCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrankCommand	t_zset.c	/^void zrankCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrankGenericCommand	t_zset.c	/^void zrankGenericCommand(client *c, int reverse) {$/;"	f	language:C	signature:(client *c, int reverse)
zrealloc	zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f	language:C	signature:(void *ptr, size_t size)
zrealloc	zmalloc.h	/^void *zrealloc(void *ptr, size_t size);$/;"	p	language:C	signature:(void *ptr, size_t size)
zremCommand	server.h	/^void zremCommand(client *c);$/;"	p	language:C	signature:(client *c)
zremCommand	t_zset.c	/^void zremCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zremrangeGenericCommand	t_zset.c	/^void zremrangeGenericCommand(client *c, int rangetype) {$/;"	f	language:C	signature:(client *c, int rangetype)
zremrangebylexCommand	server.h	/^void zremrangebylexCommand(client *c);$/;"	p	language:C	signature:(client *c)
zremrangebylexCommand	t_zset.c	/^void zremrangebylexCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zremrangebyrankCommand	server.h	/^void zremrangebyrankCommand(client *c);$/;"	p	language:C	signature:(client *c)
zremrangebyrankCommand	t_zset.c	/^void zremrangebyrankCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zremrangebyscoreCommand	server.h	/^void zremrangebyscoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
zremrangebyscoreCommand	t_zset.c	/^void zremrangebyscoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrevrangeCommand	server.h	/^void zrevrangeCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrevrangeCommand	t_zset.c	/^void zrevrangeCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrevrangebylexCommand	server.h	/^void zrevrangebylexCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrevrangebylexCommand	t_zset.c	/^void zrevrangebylexCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrevrangebyscoreCommand	server.h	/^void zrevrangebyscoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrevrangebyscoreCommand	t_zset.c	/^void zrevrangebyscoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrevrankCommand	server.h	/^void zrevrankCommand(client *c);$/;"	p	language:C	signature:(client *c)
zrevrankCommand	t_zset.c	/^void zrevrankCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zrs	module.c	/^    zrangespec *zrs = &key->zrs;$/;"	l	language:C
zrs	module.c	/^    zrangespec zrs;         \/* Score range. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
zs	aof.c	/^        zset *zs = o->ptr;$/;"	l	language:C
zs	db.c	/^        zset *zs = o->ptr;$/;"	l	language:C
zs	debug.c	/^                    zset *zs = o->ptr;$/;"	l	language:C
zs	geo.c	/^        zset *zs = zobj->ptr;$/;"	l	language:C
zs	geo.c	/^        zset *zs;$/;"	l	language:C
zs	lazyfree.c	/^        zset *zs = obj->ptr;$/;"	l	language:C
zs	module.c	/^        zset *zs = key->value->ptr;$/;"	l	language:C
zs	object.c	/^    zset *zs = zmalloc(sizeof(*zs));$/;"	l	language:C
zs	object.c	/^    zset *zs;$/;"	l	language:C
zs	rdb.c	/^            zset *zs = o->ptr;$/;"	l	language:C
zs	rdb.c	/^        zset *zs;$/;"	l	language:C
zs	sort.c	/^        zset *zs = sortval->ptr;$/;"	l	language:C
zs	t_zset.c	/^                zset *zs;$/;"	m	language:C	struct:__anon40::__anon41::_iterzset::__anon45	file:	access:public
zs	t_zset.c	/^            zset *zs = op->subject->ptr;$/;"	l	language:C
zs	t_zset.c	/^        zset *zs = zobj->ptr;$/;"	l	language:C
zs	t_zset.c	/^    zset *zs;$/;"	l	language:C
zscanCommand	server.h	/^void zscanCommand(client *c);$/;"	p	language:C	signature:(client *c)
zscanCommand	t_zset.c	/^void zscanCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zscoreCommand	server.h	/^void zscoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
zscoreCommand	t_zset.c	/^void zscoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zset	server.h	/^typedef struct zset {$/;"	s	language:C
zset	server.h	/^} zset;$/;"	t	language:C	typeref:struct:zset
zset	t_zset.c	/^        } zset;$/;"	m	language:C	union:__anon40::__anon41	typeref:union:__anon40::__anon41::_iterzset	file:	access:public
zset::dict	server.h	/^    dict *dict;$/;"	m	language:C	struct:zset	access:public
zset::zsl	server.h	/^    zskiplist *zsl;$/;"	m	language:C	struct:zset	access:public
zsetAdd	server.h	/^int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);$/;"	p	language:C	signature:(robj *zobj, double score, sds ele, int *flags, double *newscore)
zsetAdd	t_zset.c	/^int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore) {$/;"	f	language:C	signature:(robj *zobj, double score, sds ele, int *flags, double *newscore)
zsetConvert	server.h	/^void zsetConvert(robj *zobj, int encoding);$/;"	p	language:C	signature:(robj *zobj, int encoding)
zsetConvert	t_zset.c	/^void zsetConvert(robj *zobj, int encoding) {$/;"	f	language:C	signature:(robj *zobj, int encoding)
zsetConvertToZiplistIfNeeded	server.h	/^void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);$/;"	p	language:C	signature:(robj *zobj, size_t maxelelen)
zsetConvertToZiplistIfNeeded	t_zset.c	/^void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {$/;"	f	language:C	signature:(robj *zobj, size_t maxelelen)
zsetDel	server.h	/^int zsetDel(robj *zobj, sds ele);$/;"	p	language:C	signature:(robj *zobj, sds ele)
zsetDel	t_zset.c	/^int zsetDel(robj *zobj, sds ele) {$/;"	f	language:C	signature:(robj *zobj, sds ele)
zsetDictType	server.c	/^dictType zsetDictType = {$/;"	v	language:C
zsetDictType	server.h	/^extern dictType zsetDictType;$/;"	x	language:C
zsetInitLexRange	module.c	/^int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {$/;"	f	language:C	signature:(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first)
zsetInitScoreRange	module.c	/^int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {$/;"	f	language:C	signature:(RedisModuleKey *key, double min, double max, int minex, int maxex, int first)
zsetKeyReset	module.c	/^static void zsetKeyReset(RedisModuleKey *key);$/;"	p	language:C	file:	signature:(RedisModuleKey *key)
zsetKeyReset	module.c	/^void zsetKeyReset(RedisModuleKey *key) {$/;"	f	language:C	signature:(RedisModuleKey *key)
zsetLength	server.h	/^unsigned int zsetLength(const robj *zobj);$/;"	p	language:C	signature:(const robj *zobj)
zsetLength	t_zset.c	/^unsigned int zsetLength(const robj *zobj) {$/;"	f	language:C	signature:(const robj *zobj)
zsetRank	server.h	/^long zsetRank(robj *zobj, sds ele, int reverse);$/;"	p	language:C	signature:(robj *zobj, sds ele, int reverse)
zsetRank	t_zset.c	/^long zsetRank(robj *zobj, sds ele, int reverse) {$/;"	f	language:C	signature:(robj *zobj, sds ele, int reverse)
zsetScore	server.h	/^int zsetScore(robj *zobj, sds member, double *score);$/;"	p	language:C	signature:(robj *zobj, sds member, double *score)
zsetScore	t_zset.c	/^int zsetScore(robj *zobj, sds member, double *score) {$/;"	f	language:C	signature:(robj *zobj, sds member, double *score)
zset_max_ziplist_entries	server.h	/^    size_t zset_max_ziplist_entries;$/;"	m	language:C	struct:redisServer	access:public
zset_max_ziplist_value	server.h	/^    size_t zset_max_ziplist_value;$/;"	m	language:C	struct:redisServer	access:public
zsetlen	rdb.c	/^        size_t zsetlen;$/;"	l	language:C
zsetlen	sort.c	/^            long zsetlen = dictSize(((zset*)sortval->ptr)->dict);$/;"	l	language:C
zsetopsrc	t_zset.c	/^} zsetopsrc;$/;"	t	language:C	typeref:struct:__anon40	file:
zsetopval	t_zset.c	/^} zsetopval;$/;"	t	language:C	typeref:struct:__anon46	file:
zskiplist	server.h	/^typedef struct zskiplist {$/;"	s	language:C
zskiplist	server.h	/^} zskiplist;$/;"	t	language:C	typeref:struct:zskiplist
zskiplist::header	server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	language:C	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode	access:public
zskiplist::length	server.h	/^    unsigned long length;$/;"	m	language:C	struct:zskiplist	access:public
zskiplist::level	server.h	/^    int level;$/;"	m	language:C	struct:zskiplist	access:public
zskiplist::tail	server.h	/^    struct zskiplistNode *header, *tail;$/;"	m	language:C	struct:zskiplist	typeref:struct:zskiplist::	access:public
zskiplistLevel	server.h	/^    struct zskiplistLevel {$/;"	s	language:C	struct:zskiplistNode	access:public
zskiplistNode	server.h	/^typedef struct zskiplistNode {$/;"	s	language:C
zskiplistNode	server.h	/^} zskiplistNode;$/;"	t	language:C	typeref:struct:zskiplistNode
zskiplistNode::backward	server.h	/^    struct zskiplistNode *backward;$/;"	m	language:C	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode	access:public
zskiplistNode::ele	server.h	/^    sds ele;$/;"	m	language:C	struct:zskiplistNode	access:public
zskiplistNode::level	server.h	/^    } level[];$/;"	m	language:C	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistLevel	access:public
zskiplistNode::score	server.h	/^    double score;$/;"	m	language:C	struct:zskiplistNode	access:public
zskiplistNode::zskiplistLevel	server.h	/^    struct zskiplistLevel {$/;"	s	language:C	struct:zskiplistNode	access:public
zskiplistNode::zskiplistLevel::forward	server.h	/^        struct zskiplistNode *forward;$/;"	m	language:C	struct:zskiplistNode::zskiplistLevel	typeref:struct:zskiplistNode::zskiplistLevel::zskiplistNode	access:public
zskiplistNode::zskiplistLevel::span	server.h	/^        unsigned int span;$/;"	m	language:C	struct:zskiplistNode::zskiplistLevel	access:public
zsl	db.c	/^    zskiplist *zsl = server.cluster->slots_to_keys;$/;"	l	language:C
zsl	geo.c	/^        zskiplist *zsl = zs->zsl;$/;"	l	language:C
zsl	module.c	/^        zskiplist *zsl = zs->zsl;$/;"	l	language:C
zsl	server.h	/^    zskiplist *zsl;$/;"	m	language:C	struct:zset	access:public
zsl	sort.c	/^        zskiplist *zsl = zs->zsl;$/;"	l	language:C
zsl	t_zset.c	/^        zskiplist *zsl = zs->zsl;$/;"	l	language:C
zsl	t_zset.c	/^    zskiplist *zsl;$/;"	l	language:C
zslCreate	server.h	/^zskiplist *zslCreate(void);$/;"	p	language:C	signature:(void)
zslCreate	t_zset.c	/^zskiplist *zslCreate(void) {$/;"	f	language:C	signature:(void)
zslCreateNode	t_zset.c	/^zskiplistNode *zslCreateNode(int level, double score, sds ele) {$/;"	f	language:C	signature:(int level, double score, sds ele)
zslDelete	server.h	/^int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);$/;"	p	language:C	signature:(zskiplist *zsl, double score, sds ele, zskiplistNode **node)
zslDelete	t_zset.c	/^int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {$/;"	f	language:C	signature:(zskiplist *zsl, double score, sds ele, zskiplistNode **node)
zslDeleteNode	t_zset.c	/^void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {$/;"	f	language:C	signature:(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)
zslDeleteRangeByLex	t_zset.c	/^unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {$/;"	f	language:C	signature:(zskiplist *zsl, zlexrangespec *range, dict *dict)
zslDeleteRangeByRank	t_zset.c	/^unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {$/;"	f	language:C	signature:(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict)
zslDeleteRangeByScore	t_zset.c	/^unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {$/;"	f	language:C	signature:(zskiplist *zsl, zrangespec *range, dict *dict)
zslFirstInLexRange	server.h	/^zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);$/;"	p	language:C	signature:(zskiplist *zsl, zlexrangespec *range)
zslFirstInLexRange	t_zset.c	/^zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f	language:C	signature:(zskiplist *zsl, zlexrangespec *range)
zslFirstInRange	server.h	/^zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);$/;"	p	language:C	signature:(zskiplist *zsl, zrangespec *range)
zslFirstInRange	t_zset.c	/^zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {$/;"	f	language:C	signature:(zskiplist *zsl, zrangespec *range)
zslFree	server.h	/^void zslFree(zskiplist *zsl);$/;"	p	language:C	signature:(zskiplist *zsl)
zslFree	t_zset.c	/^void zslFree(zskiplist *zsl) {$/;"	f	language:C	signature:(zskiplist *zsl)
zslFreeLexRange	server.h	/^void zslFreeLexRange(zlexrangespec *spec);$/;"	p	language:C	signature:(zlexrangespec *spec)
zslFreeLexRange	t_zset.c	/^void zslFreeLexRange(zlexrangespec *spec) {$/;"	f	language:C	signature:(zlexrangespec *spec)
zslFreeNode	t_zset.c	/^void zslFreeNode(zskiplistNode *node) {$/;"	f	language:C	signature:(zskiplistNode *node)
zslGetElementByRank	sort.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);$/;"	p	language:C	file:	signature:(zskiplist *zsl, unsigned long rank)
zslGetElementByRank	t_zset.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {$/;"	f	language:C	signature:(zskiplist *zsl, unsigned long rank)
zslGetRank	server.h	/^unsigned long zslGetRank(zskiplist *zsl, double score, sds o);$/;"	p	language:C	signature:(zskiplist *zsl, double score, sds o)
zslGetRank	t_zset.c	/^unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {$/;"	f	language:C	signature:(zskiplist *zsl, double score, sds ele)
zslInsert	server.h	/^zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);$/;"	p	language:C	signature:(zskiplist *zsl, double score, sds ele)
zslInsert	t_zset.c	/^zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {$/;"	f	language:C	signature:(zskiplist *zsl, double score, sds ele)
zslIsInLexRange	t_zset.c	/^int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f	language:C	signature:(zskiplist *zsl, zlexrangespec *range)
zslIsInRange	t_zset.c	/^int zslIsInRange(zskiplist *zsl, zrangespec *range) {$/;"	f	language:C	signature:(zskiplist *zsl, zrangespec *range)
zslLastInLexRange	server.h	/^zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);$/;"	p	language:C	signature:(zskiplist *zsl, zlexrangespec *range)
zslLastInLexRange	t_zset.c	/^zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f	language:C	signature:(zskiplist *zsl, zlexrangespec *range)
zslLastInRange	server.h	/^zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);$/;"	p	language:C	signature:(zskiplist *zsl, zrangespec *range)
zslLastInRange	t_zset.c	/^zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {$/;"	f	language:C	signature:(zskiplist *zsl, zrangespec *range)
zslLexValueGteMin	server.h	/^int zslLexValueGteMin(sds value, zlexrangespec *spec);$/;"	p	language:C	signature:(sds value, zlexrangespec *spec)
zslLexValueGteMin	t_zset.c	/^int zslLexValueGteMin(sds value, zlexrangespec *spec) {$/;"	f	language:C	signature:(sds value, zlexrangespec *spec)
zslLexValueGteMin	t_zset.c	/^int zslLexValueGteMin(sds value, zlexrangespec *spec);$/;"	p	language:C	file:	signature:(sds value, zlexrangespec *spec)
zslLexValueLteMax	server.h	/^int zslLexValueLteMax(sds value, zlexrangespec *spec);$/;"	p	language:C	signature:(sds value, zlexrangespec *spec)
zslLexValueLteMax	t_zset.c	/^int zslLexValueLteMax(sds value, zlexrangespec *spec) {$/;"	f	language:C	signature:(sds value, zlexrangespec *spec)
zslLexValueLteMax	t_zset.c	/^int zslLexValueLteMax(sds value, zlexrangespec *spec);$/;"	p	language:C	file:	signature:(sds value, zlexrangespec *spec)
zslParseLexRange	server.h	/^int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);$/;"	p	language:C	signature:(robj *min, robj *max, zlexrangespec *spec)
zslParseLexRange	t_zset.c	/^int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {$/;"	f	language:C	signature:(robj *min, robj *max, zlexrangespec *spec)
zslParseLexRangeItem	t_zset.c	/^int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {$/;"	f	language:C	signature:(robj *item, sds *dest, int *ex)
zslParseRange	t_zset.c	/^static int zslParseRange(robj *min, robj *max, zrangespec *spec) {$/;"	f	language:C	file:	signature:(robj *min, robj *max, zrangespec *spec)
zslRandomLevel	t_zset.c	/^int zslRandomLevel(void) {$/;"	f	language:C	signature:(void)
zslValueGteMin	server.h	/^int zslValueGteMin(double value, zrangespec *spec);$/;"	p	language:C	signature:(double value, zrangespec *spec)
zslValueGteMin	t_zset.c	/^int zslValueGteMin(double value, zrangespec *spec) {$/;"	f	language:C	signature:(double value, zrangespec *spec)
zslValueLteMax	geo.c	/^int zslValueLteMax(double value, zrangespec *spec);$/;"	p	language:C	file:	signature:(double value, zrangespec *spec)
zslValueLteMax	server.h	/^int zslValueLteMax(double value, zrangespec *spec);$/;"	p	language:C	signature:(double value, zrangespec *spec)
zslValueLteMax	t_zset.c	/^int zslValueLteMax(double value, zrangespec *spec) {$/;"	f	language:C	signature:(double value, zrangespec *spec)
zstart	module.c	/^    uint32_t zstart;        \/* Start pos for positional ranges. *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
zstrdup	zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f	language:C	signature:(const char *s)
zstrdup	zmalloc.h	/^char *zstrdup(const char *s);$/;"	p	language:C	signature:(const char *s)
ztype	module.c	/^    uint32_t ztype;         \/* REDISMODULE_ZSET_RANGE_* *\/$/;"	m	language:C	struct:RedisModuleKey	file:	access:public
zuiBufferFromValue	t_zset.c	/^int zuiBufferFromValue(zsetopval *val) {$/;"	f	language:C	signature:(zsetopval *val)
zuiClearIterator	t_zset.c	/^void zuiClearIterator(zsetopsrc *op) {$/;"	f	language:C	signature:(zsetopsrc *op)
zuiCompareByCardinality	t_zset.c	/^int zuiCompareByCardinality(const void *s1, const void *s2) {$/;"	f	language:C	signature:(const void *s1, const void *s2)
zuiFind	t_zset.c	/^int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {$/;"	f	language:C	signature:(zsetopsrc *op, zsetopval *val, double *score)
zuiInitIterator	t_zset.c	/^void zuiInitIterator(zsetopsrc *op) {$/;"	f	language:C	signature:(zsetopsrc *op)
zuiLength	t_zset.c	/^int zuiLength(zsetopsrc *op) {$/;"	f	language:C	signature:(zsetopsrc *op)
zuiLongLongFromValue	t_zset.c	/^int zuiLongLongFromValue(zsetopval *val) {$/;"	f	language:C	signature:(zsetopval *val)
zuiNewSdsFromValue	t_zset.c	/^sds zuiNewSdsFromValue(zsetopval *val) {$/;"	f	language:C	signature:(zsetopval *val)
zuiNext	t_zset.c	/^int zuiNext(zsetopsrc *op, zsetopval *val) {$/;"	f	language:C	signature:(zsetopsrc *op, zsetopval *val)
zuiSdsFromValue	t_zset.c	/^sds zuiSdsFromValue(zsetopval *val) {$/;"	f	language:C	signature:(zsetopval *val)
zunionInterAggregate	t_zset.c	/^inline static void zunionInterAggregate(double *target, double val, int aggregate) {$/;"	f	language:C	file:	signature:(double *target, double val, int aggregate)
zunionInterDictValue	t_zset.c	/^#define zunionInterDictValue(/;"	d	language:C	file:
zunionInterGenericCommand	t_zset.c	/^void zunionInterGenericCommand(client *c, robj *dstkey, int op) {$/;"	f	language:C	signature:(client *c, robj *dstkey, int op)
zunionInterGetKeys	db.c	/^int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	language:C	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
zunionInterGetKeys	server.h	/^int *zunionInterGetKeys(struct redisCommand *cmd,robj **argv, int argc, int *numkeys);$/;"	p	language:C	signature:(struct redisCommand *cmd,robj **argv, int argc, int *numkeys)
zunionstoreCommand	server.h	/^void zunionstoreCommand(client *c);$/;"	p	language:C	signature:(client *c)
zunionstoreCommand	t_zset.c	/^void zunionstoreCommand(client *c) {$/;"	f	language:C	signature:(client *c)
zval	t_zset.c	/^    zsetopval zval;$/;"	l	language:C
zval	ziplist.c	/^    long long zval, sval;$/;"	l	language:C
zz	geohash.c	/^    uint64_t zz = 0x5555555555555555ULL >> (64 - hash->step * 2);$/;"	l	language:C
zz	geohash.c	/^    uint64_t zz = 0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2);$/;"	l	language:C
zzlCompareElements	t_zset.c	/^int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {$/;"	f	language:C	signature:(unsigned char *eptr, unsigned char *cstr, unsigned int clen)
zzlDelete	t_zset.c	/^unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char *eptr)
zzlDeleteRangeByLex	t_zset.c	/^unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {$/;"	f	language:C	signature:(unsigned char *zl, zlexrangespec *range, unsigned long *deleted)
zzlDeleteRangeByRank	t_zset.c	/^unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted)
zzlDeleteRangeByScore	t_zset.c	/^unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {$/;"	f	language:C	signature:(unsigned char *zl, zrangespec *range, unsigned long *deleted)
zzlFind	t_zset.c	/^unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {$/;"	f	language:C	signature:(unsigned char *zl, sds ele, double *score)
zzlFirstInLexRange	server.h	/^unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range);$/;"	p	language:C	signature:(unsigned char *zl, zlexrangespec *range)
zzlFirstInLexRange	t_zset.c	/^unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f	language:C	signature:(unsigned char *zl, zlexrangespec *range)
zzlFirstInRange	geo.c	/^unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);$/;"	p	language:C	file:	signature:(unsigned char *zl, zrangespec *range)
zzlFirstInRange	server.h	/^unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);$/;"	p	language:C	signature:(unsigned char *zl, zrangespec *range)
zzlFirstInRange	t_zset.c	/^unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {$/;"	f	language:C	signature:(unsigned char *zl, zrangespec *range)
zzlGetScore	server.h	/^double zzlGetScore(unsigned char *sptr);$/;"	p	language:C	signature:(unsigned char *sptr)
zzlGetScore	t_zset.c	/^double zzlGetScore(unsigned char *sptr) {$/;"	f	language:C	signature:(unsigned char *sptr)
zzlInsert	server.h	/^unsigned char *zzlInsert(unsigned char *zl, sds ele, double score);$/;"	p	language:C	signature:(unsigned char *zl, sds ele, double score)
zzlInsert	t_zset.c	/^unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {$/;"	f	language:C	signature:(unsigned char *zl, sds ele, double score)
zzlInsertAt	t_zset.c	/^unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char *eptr, sds ele, double score)
zzlIsInLexRange	t_zset.c	/^int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f	language:C	signature:(unsigned char *zl, zlexrangespec *range)
zzlIsInRange	t_zset.c	/^int zzlIsInRange(unsigned char *zl, zrangespec *range) {$/;"	f	language:C	signature:(unsigned char *zl, zrangespec *range)
zzlLastInLexRange	server.h	/^unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range);$/;"	p	language:C	signature:(unsigned char *zl, zlexrangespec *range)
zzlLastInLexRange	t_zset.c	/^unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f	language:C	signature:(unsigned char *zl, zlexrangespec *range)
zzlLastInRange	server.h	/^unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);$/;"	p	language:C	signature:(unsigned char *zl, zrangespec *range)
zzlLastInRange	t_zset.c	/^unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {$/;"	f	language:C	signature:(unsigned char *zl, zrangespec *range)
zzlLength	t_zset.c	/^unsigned int zzlLength(unsigned char *zl) {$/;"	f	language:C	signature:(unsigned char *zl)
zzlLexValueGteMin	server.h	/^int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec);$/;"	p	language:C	signature:(unsigned char *p, zlexrangespec *spec)
zzlLexValueGteMin	t_zset.c	/^int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {$/;"	f	language:C	signature:(unsigned char *p, zlexrangespec *spec)
zzlLexValueLteMax	server.h	/^int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec);$/;"	p	language:C	signature:(unsigned char *p, zlexrangespec *spec)
zzlLexValueLteMax	t_zset.c	/^int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {$/;"	f	language:C	signature:(unsigned char *p, zlexrangespec *spec)
zzlNext	server.h	/^void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);$/;"	p	language:C	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
zzlNext	t_zset.c	/^void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
zzlPrev	server.h	/^void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);$/;"	p	language:C	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
zzlPrev	t_zset.c	/^void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f	language:C	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
